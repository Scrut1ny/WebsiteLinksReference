i < MAX_IOVA_REGIONS
/dev/vduse/%s
Failed to get features: %s
Looped descriptor
Desc next is %u
read descriptor error
Virtqueue size exceeded: %d
Read request error [%d]: %s
vq->inuse == 0
Failed to get vduse log
Invalid parameter for vduse
Failed to init vqs
/dev/vduse/control
!vduse_name_is_invalid(name)
gdbstub: Bad syscall format string '%s'
Expected key=value format, found %s.
/home/virus/AMD/AMD/include/hw/boards.h
/home/virus/AMD/AMD/include/hw/qdev-core.h
/home/virus/AMD/AMD/include/hw/resettable.h
/home/virus/AMD/AMD/include/hw/core/cpu.h
smp_cache->props[cache1].topology != CPU_TOPOLOGY_LEVEL_DEFAULT
Invalid CPU topology: CPU topology parameters must be greater than zero
modules > 1 not supported by this machine's CPU topology
clusters > 1 not supported by this machine's CPU topology
dies > 1 not supported by this machine's CPU topology
books > 1 not supported by this machine's CPU topology
drawers > 1 not supported by this machine's CPU topology
Invalid CPU topology: product of the hierarchy must match maxcpus: %s != maxcpus (%u)
Invalid CPU topology: maxcpus must be equal to or greater than smp: %s == maxcpus (%u) < smp_cpus (%u)
Invalid SMP CPUs %d. The min CPUs supported by machine '%s' is %d
Invalid SMP CPUs %d. The max CPUs supported by machine '%s' is %d
Invalid cache properties: %s. The cache properties are duplicated
%s cache topology not supported by this machine
%s level cache not supported by this machine
Invalid topology level: %s. The topology level is not supported by this machine
Invalid smp cache topology. L2 cache topology level shouldn't be lower than L1 cache
Invalid smp cache topology. L3 cache topology level shouldn't be lower than L2 cache
/home/virus/AMD/AMD/include/qemu/lockable.h
cpu->cpu_index != UNASSIGNED_CPU_INDEX
%d@%zu.%06zu:breakpoint_insert cpu=%d pc=0x%lx flags=0x%x
breakpoint_insert cpu=%d pc=0x%lx flags=0x%x
%d@%zu.%06zu:breakpoint_remove cpu=%d pc=0x%lx flags=0x%x
breakpoint_remove cpu=%d pc=0x%lx flags=0x%x
Disassembler disagrees with translator over instruction decoding
Please report this to qemu-devel@nongnu.org
0x%08lx: unable to read memory
Disassembler disagrees with TCG over instruction encoding
Please report this to qemu-devel@nongnu.org
Address 0x%lx is out of bounds.
s->info.endian != BFD_ENDIAN_UNKNOWN
s->ftz_detection == float_ftz_after_rounding
../fpu/softfloat-specialize.c.inc
b->cls == float_class_inf || a->cls == float_class_zero
../accel/tcg/cpu-exec-common.c
Calling qemu_plugin_uninstall from the install function is a bug. Instead, return !0 from the install function.
missing earlier '-plugin file=' option
Could not load plugin %s: qemu_plugin_install is NULL
Could not load plugin %s: plugin does not declare API version %s
Could not load plugin %s: plugin requires API version %d, but this QEMU supports only a minimum version of %d
Could not load plugin %s: plugin requires API version %d, but this QEMU supports only up to version %d
Could not load plugin %s: qemu_plugin_install returned error code %d
vcpu_index < qemu_plugin_num_vcpus()
(unsigned)flags < ARRAY_SIZE(info)
/home/virus/AMD/AMD/trace/control-internal.h
trace_event_get_state_static(ev)
/home/virus/AMD/AMD/include/qobject/qobject.h
Path '%s' could not be resolved.
Warning: Path '%s' is ambiguous.
/home/virus/AMD/AMD/include/qom/object_interfaces.h
/home/virus/AMD/AMD/include/hw/nvram/fw_cfg.h
/home/virus/AMD/AMD/include/crypto/tlscreds.h
'priority' property is not set
%d@%zu.%06zu:qcrypto_tls_cipher_suite_priority priority: %s
qcrypto_tls_cipher_suite_priority priority: %s
Syntax error using priority '%s': %s
%d@%zu.%06zu:qcrypto_tls_cipher_suite_info data=[0x%02x,0x%02x] version=%s name=%s
qcrypto_tls_cipher_suite_info data=[0x%02x,0x%02x] version=%s name=%s
%d@%zu.%06zu:qcrypto_tls_cipher_suite_count count: %u
qcrypto_tls_cipher_suite_count count: %u
/home/virus/AMD/AMD/include/crypto/tls-cipher-suites.h
selection < QEMU_CLIPBOARD_SELECTION__COUNT
%d@%zu.%06zu:clipboard_check_serial cur:%d recv:%d %d
clipboard_check_serial cur:%d recv:%d %d
info->selection < QEMU_CLIPBOARD_SELECTION__COUNT
info->owner && info->owner->request
%d@%zu.%06zu:clipboard_reset_serial 
console: no gl-unblock within one second
%d@%zu.%06zu:displaysurface_free surface=%p
displaysurface_free surface=%p
%d@%zu.%06zu:console_refresh interval %d ms
console_refresh interval %d ms
/home/virus/AMD/AMD/include/ui/console.h
surface->share_handle == SHAREABLE_NONE
%d@%zu.%06zu:displaysurface_create_from surface=%p, %dx%d, format 0x%x
displaysurface_create_from surface=%p, %dx%d, format 0x%x
%d@%zu.%06zu:displaysurface_create %dx%d
%d@%zu.%06zu:displaysurface_create_pixman surface=%p
displaysurface_create_pixman surface=%p
Unexpected touch slot number: % ld >= %d
The console already has an OpenGL context.
%d@%zu.%06zu:displaychangelistener_register %p [ %s ]
displaychangelistener_register %p [ %s ]
Display %s is incompatible with the GL context
The console requires a GL context.
The console requires display DMABUF support.
%d@%zu.%06zu:displaychangelistener_unregister %p [ %s ]
displaychangelistener_unregister %p [ %s ]
Device %s (head %d) is not bound to a QemuConsole
%d@%zu.%06zu:console_gfx_reuse %d
%d@%zu.%06zu:console_gfx_new 
%d@%zu.%06zu:console_gfx_close %d
opts->type < DISPLAY_TYPE__MAX
Display '%s' is not available.
Available display backend types:
Some display backends support suboptions, which can be set with
   -display backend,option=value,option=value...
For a short list of the suboptions for each display, see the top-level -help output; more detail is in the documentation.
X                               
XX                              
X.X                             
X..X                            
X...X                           
X....X                          
X.....X                         
X......X                        
X.......X                       
X........X                      
X.....XXXXX                     
X..X..X                         
X.X X..X                        
XX  X..X                        
X    X..X                       
     X..X                       
      X..X                      
       XX                       
                                
value->type == KEY_VALUE_KIND_NUMBER
/home/virus/AMD/AMD/include/io/channel.h
x-origin property must be in the range [0..%d]
height property must be in the range [0..%d]
width property must be in the range [0..%d]
y-origin property must be in the range [0..%d]
%d@%zu.%06zu:input_event_key_number con %d, key number 0x%x [%s], down %d
input_event_key_number con %d, key number 0x%x [%s], down %d
%d@%zu.%06zu:input_event_key_qcode con %d, key qcode %s, down %d
input_event_key_qcode con %d, key qcode %s, down %d
%d@%zu.%06zu:input_event_btn con %d, button %s, down %d
input_event_btn con %d, button %s, down %d
%d@%zu.%06zu:input_event_rel con %d, axis %s, value %d
input_event_rel con %d, axis %s, value %d
%d@%zu.%06zu:input_event_abs con %d, axis %s, value 0x%x
input_event_abs con %d, axis %s, value 0x%x
%d@%zu.%06zu:input_event_mtt con %d, axis %s, value 0x%x
input_event_mtt con %d, axis %s, value 0x%x
!(evt->type == INPUT_EVENT_KIND_KEY && evt->u.key.data->key->type == KEY_VALUE_KIND_NUMBER)
item->type == QEMU_INPUT_QUEUE_DELAY
%d@%zu.%06zu:input_event_sync 
Input handler not found for event type %s
Input device '%s' is not a mouse
more than %zd keycodes for keysym %d
%d@%zu.%06zu:keymap_add sym=0x%04x code=0x%04x (line: %s)
keymap_add sym=0x%04x code=0x%04x (line: %s)
%d@%zu.%06zu:keymap_parse file %s
could not read keymap file: '%s'
keymap include files are not supported any more
%d@%zu.%06zu:keymap_unmapped sym=0x%04x
no scancode found for keysym %d
Parameter 'read-only-mode' is invalid for VNC
Expected 'password' after 'vnc'
/home/virus/AMD/AMD/include/ui/qemu-spice.h
opts->protocol == DISPLAY_PROTOCOL_VNC
parameter 'connected' must be 'keep' when 'protocol' is 'vnc'
Parameter 'time' doesn't take value '%s'
Could not set password expire time
/home/virus/AMD/AMD/include/ui/dbus-display.h
parameter 'port' or 'tls-port' is required
Could not set up display for migration
'head' must be specified together with 'device'
There is no console to take a screendump from
Failed to create file from file descriptor
PNG creation failed. Unable to write struct
PNG creation failed. Unable to write info
PNG creation failed. Unable to close file
%d@%zu.%06zu:ppm_save fd=%d image=%p
/home/virus/AMD/AMD/include/hw/pci/pci.h
Setting device address of a display device: Not a PCI device.
Setting device address of a display device: Too many PCI devices in the chain.
/home/virus/AMD/AMD/include/chardev/char.h
s->scanout.kind == SCANOUT_SURFACE
%d@%zu.%06zu:console_txt_new %dx%d
%d@%zu.%06zu:console_putchar_csi escape sequence CSI%d;%d%c, %d parameters
console_putchar_csi escape sequence CSI%d;%d%c, %d parameters
%d@%zu.%06zu:console_putchar_unhandled unhandled escape character '%c'
console_putchar_unhandled unhandled escape character '%c'
%d@%zu.%06zu:vdagent_send msg %s
%d@%zu.%06zu:vdagent_recv_msg msg %s, size %d
vdagent_recv_msg msg %s, size %d
%d@%zu.%06zu:vdagent_peer_cap cap %s
%d@%zu.%06zu:vdagent_cb_grab_selection selection %s
vdagent_cb_grab_selection selection %s
%d@%zu.%06zu:vdagent_cb_grab_discard selection %s, cur:%d recv:%d
vdagent_cb_grab_discard selection %s, cur:%d recv:%d
%d@%zu.%06zu:vdagent_cb_grab_type type %s
%d@%zu.%06zu:vdagent_send_empty_clipboard 
vdagent_send_empty_clipboard 
%d@%zu.%06zu:vdagent_disconnect 
%d@%zu.%06zu:vdagent_recv_chunk size %d
%s: message too small: %d < %zd
The vdagent chardev doesn't yet support migration
%d@%zu.%06zu:vdagent_fe_open fe_open=%d
clipboard-no-release-on-regrab
%s: failed to get get absolute X value
%s: failed to get get absolute Y value
%s: failed to get global key state
Unsupported socket address type %s
%d@%zu.%06zu:vnc_client_throttle_threshold VNC client throttle threshold state=%p ioc=%p oldoffset=%zu newoffset=%zu width=%d height=%d bpp=%d audio=%p
vnc_client_throttle_threshold VNC client throttle threshold state=%p ioc=%p oldoffset=%zu newoffset=%zu width=%d height=%d bpp=%d audio=%p
Port range not support with UNIX socket
explicit websocket port is required
%d@%zu.%06zu:vnc_key_map_init %s
%d@%zu.%06zu:vnc_client_disconnect_start VNC client disconnect start state=%p ioc=%p
vnc_client_disconnect_start VNC client disconnect start state=%p ioc=%p
%d@%zu.%06zu:vnc_client_eof VNC client EOF state=%p ioc=%p
vnc_client_eof VNC client EOF state=%p ioc=%p
%d@%zu.%06zu:vnc_client_io_error VNC client I/O error state=%p ioc=%p errmsg=%s
vnc_client_io_error VNC client I/O error state=%p ioc=%p errmsg=%s
%d@%zu.%06zu:vnc_client_unthrottle_forced VNC client unthrottle forced offset state=%p ioc=%p
vnc_client_unthrottle_forced VNC client unthrottle forced offset state=%p ioc=%p
%d@%zu.%06zu:vnc_client_unthrottle_incremental VNC client unthrottle incremental state=%p ioc=%p offset=%zu
vnc_client_unthrottle_incremental VNC client unthrottle incremental state=%p ioc=%p offset=%zu
%d@%zu.%06zu:vnc_key_sync_numlock %d
%d@%zu.%06zu:vnc_key_sync_capslock %d
%d@%zu.%06zu:vnc_key_event_map down %d, sym 0x%x -> keycode 0x%x [%s]
vnc_key_event_map down %d, sym 0x%x -> keycode 0x%x [%s]
%s doesn't support to reload TLS credential
%d@%zu.%06zu:vnc_client_disconnect_finish VNC client disconnect finish state=%p ioc=%p
vnc_client_disconnect_finish VNC client disconnect finish state=%p ioc=%p
%d@%zu.%06zu:vnc_client_throttle_incremental VNC client throttle incremental state=%p ioc=%p job-update=%d offset=%zu
vnc_client_throttle_incremental VNC client throttle incremental state=%p ioc=%p job-update=%d offset=%zu
%d@%zu.%06zu:vnc_client_throttle_forced VNC client throttle forced state=%p ioc=%p job-update=%d offset=%zu
vnc_client_throttle_forced VNC client throttle forced state=%p ioc=%p job-update=%d offset=%zu
%d@%zu.%06zu:vnc_client_output_limit VNC client output limit state=%p ioc=%p offset=%zu threshold=%zu
vnc_client_output_limit VNC client output limit state=%p ioc=%p offset=%zu threshold=%zu
pixman_image_get_width(vs->vd->server) < 65536 && pixman_image_get_width(vs->vd->server) >= 0
pixman_image_get_height(vs->vd->server) < 65536 && pixman_image_get_height(vs->vd->server) >= 0
%d@%zu.%06zu:vnc_key_guest_leds caps %d, num %d, scroll %d
vnc_key_guest_leds caps %d, num %d, scroll %d
%d@%zu.%06zu:vnc_msg_server_audio_data VNC server msg audio data state=%p ioc=%p buf=%p len=%zd
vnc_msg_server_audio_data VNC server msg audio data state=%p ioc=%p buf=%p len=%zd
%d@%zu.%06zu:vnc_client_throttle_audio VNC client throttle audio state=%p ioc=%p offset=%zu
vnc_client_throttle_audio VNC client throttle audio state=%p ioc=%p offset=%zu
%d@%zu.%06zu:vnc_msg_server_audio_end VNC server msg audio end state=%p ioc=%p
vnc_msg_server_audio_end VNC server msg audio end state=%p ioc=%p
%d@%zu.%06zu:vnc_msg_server_audio_begin VNC server msg audio begin state=%p ioc=%p
vnc_msg_server_audio_begin VNC server msg audio begin state=%p ioc=%p
%d@%zu.%06zu:vnc_msg_server_ext_desktop_resize VNC server msg ext resize state=%p ioc=%p size=%dx%d reason=%d
vnc_msg_server_ext_desktop_resize VNC server msg ext resize state=%p ioc=%p size=%dx%d reason=%d
vs->vd->true_width < 65536 && vs->vd->true_width >= 0
%d@%zu.%06zu:vnc_msg_server_desktop_resize VNC server msg ext resize state=%p ioc=%p size=%dx%d
vnc_msg_server_desktop_resize VNC server msg ext resize state=%p ioc=%p size=%dx%d
vnc: client_cut_text msg payload has %u bytes which exceeds our limit of 1MB.
vnc: extended clipboard message while disabled
vnc: malformed payload (header less than 4 bytes) in extended clipboard pseudo-encoding.
vnc: xvp client message while disabled
vnc: xvp client message version %d != 1
%d@%zu.%06zu:vnc_key_event_ext down %d, sym 0x%x, keycode 0x%x [%s]
vnc_key_event_ext down %d, sym 0x%x, keycode 0x%x [%s]
Audio message %d with audio disabled
%d@%zu.%06zu:vnc_msg_client_audio_enable VNC client msg audio enable state=%p ioc=%p
vnc_msg_client_audio_enable VNC client msg audio enable state=%p ioc=%p
%d@%zu.%06zu:vnc_msg_client_audio_disable VNC client msg audio disable state=%p ioc=%p
vnc_msg_client_audio_disable VNC client msg audio disable state=%p ioc=%p
%d@%zu.%06zu:vnc_msg_client_audio_format VNC client msg audio format state=%p ioc=%p fmt=%d channels=%d freq=%d
vnc_msg_client_audio_format VNC client msg audio format state=%p ioc=%p fmt=%d channels=%d freq=%d
%d@%zu.%06zu:vnc_msg_client_set_desktop_size VNC client msg set desktop size  state=%p ioc=%p size=%dx%d screens=%d
vnc_msg_client_set_desktop_size VNC client msg set desktop size  state=%p ioc=%p size=%dx%d screens=%d
%d@%zu.%06zu:vnc_server_dpy_pageflip VNC server dpy pageflip dpy=%p size=%dx%d fmt=%d
vnc_server_dpy_pageflip VNC server dpy pageflip dpy=%p size=%dx%d fmt=%d
%d@%zu.%06zu:vnc_server_dpy_recreate VNC server dpy recreate dpy=%p size=%dx%d fmt=%d
vnc_server_dpy_recreate VNC server dpy recreate dpy=%p size=%dx%d fmt=%d
%d@%zu.%06zu:vnc_auth_fail VNC client auth failed state=%p method=%d message=%s reason=%s
vnc_auth_fail VNC client auth failed state=%p method=%d message=%s reason=%s
cannot encrypt challenge response
mis-matched challenge response
%d@%zu.%06zu:vnc_auth_pass VNC client auth passed state=%p method=%d
vnc_auth_pass VNC client auth passed state=%p method=%d
%d@%zu.%06zu:vnc_client_connect VNC client connect state=%p ioc=%p
vnc_client_connect VNC client connect state=%p ioc=%p
%d@%zu.%06zu:vnc_auth_start VNC client auth start state=%p method=%d
vnc_auth_start VNC client auth start state=%p method=%d
Unsupported auth method for v3.3
%d@%zu.%06zu:vnc_auth_reject VNC client auth rejected state=%p method expected=%d got=%d
vnc_auth_reject VNC client auth rejected state=%p method expected=%d got=%d
If you want use passwords please enable password auth using '-vnc ${dpy},password'.
SHA1 hash support is required for websockets
'password' flag is redundant with 'password-secret'
Cipher backend does not support DES algorithm
No TLS credentials with id '%s'
Object with id '%s' is not TLS credentials
'tls-authz' provided but TLS is not enabled
'sasl-authz' provided but SASL auth is not enabled
%d@%zu.%06zu:vnc_auth_init VNC auth init state=%p websock=%d auth=%d subauth=%d
vnc_auth_init VNC auth init state=%p websock=%d auth=%d subauth=%d
Cannot use websockets in reverse mode
Expected a single address in reverse mode
VNC: error during zlib compression
../ui/vnc-enc-hextile-template.h
vs->client_pf.bytes_per_pixel <= MAX_BYTES_PER_PIXEL
VNC: error during tight compression
VNC: error during zrle compression
%d@%zu.%06zu:vnc_auth_vencrypt_version VNC client auth vencrypt version state=%p major=%d minor=%d
vnc_auth_vencrypt_version VNC client auth vencrypt version state=%p major=%d minor=%d
%d@%zu.%06zu:vnc_auth_vencrypt_subauth VNC client auth vencrypt subauth state=%p auth=%d
vnc_auth_vencrypt_subauth VNC client auth vencrypt subauth state=%p auth=%d
%d@%zu.%06zu:vnc_client_io_wrap VNC client I/O wrap state=%p ioc=%p type=%s
vnc_client_io_wrap VNC client I/O wrap state=%p ioc=%p type=%s
%d@%zu.%06zu:vnc_job_clamp_rect VNC job clamp rect state=%p job=%p offset=%d,%d size=%dx%d
vnc_job_clamp_rect VNC job clamp rect state=%p job=%p offset=%d,%d size=%dx%d
%d@%zu.%06zu:vnc_job_clamped_rect VNC job clamp rect state=%p job=%p offset=%d,%d size=%dx%d
vnc_job_clamped_rect VNC job clamp rect state=%p job=%p offset=%d,%d size=%dx%d
%d@%zu.%06zu:vnc_job_discard_rect VNC job discard rect state=%p job=%p offset=%d,%d size=%dx%d
vnc_job_discard_rect VNC job discard rect state=%p job=%p offset=%d,%d size=%dx%d
%d@%zu.%06zu:vnc_job_nrects VNC job state=%p job=%p nrects=%d
vnc_job_nrects VNC job state=%p job=%p nrects=%d
%d@%zu.%06zu:vnc_job_add_rect VNC add rect state=%p job=%p offset=%d,%d size=%dx%d
vnc_job_add_rect VNC add rect state=%p job=%p offset=%d,%d size=%dx%d
%d@%zu.%06zu:vnc_auth_sasl_ssf VNC client auth SASL SSF state=%p size=%d
vnc_auth_sasl_ssf VNC client auth SASL SSF state=%p size=%d
%d@%zu.%06zu:vnc_auth_sasl_mech_choose VNC client auth SASL state=%p mech=%s
vnc_auth_sasl_mech_choose VNC client auth SASL state=%p mech=%s
%d@%zu.%06zu:vnc_auth_sasl_username VNC client auth SASL user state=%p name=%s
vnc_auth_sasl_username VNC client auth SASL user state=%p name=%s
%d@%zu.%06zu:vnc_auth_sasl_acl VNC client auth SASL ACL state=%p allow=%d
vnc_auth_sasl_acl VNC client auth SASL ACL state=%p allow=%d
%d@%zu.%06zu:vnc_auth_sasl_start VNC client auth SASL start state=%p clientdata=%p clientlen=%zu serverdata=%p serverlen=%zu ret=%d
vnc_auth_sasl_start VNC client auth SASL start state=%p clientdata=%p clientlen=%zu serverdata=%p serverlen=%zu ret=%d
%d@%zu.%06zu:vnc_auth_sasl_step VNC client auth SASL step state=%p clientdata=%p clientlen=%zu serverdata=%p serverlen=%zu ret=%d
vnc_auth_sasl_step VNC client auth SASL step state=%p clientdata=%p clientlen=%zu serverdata=%p serverlen=%zu ret=%d
Failed to initialize SASL auth: %s
cannot set SASL security props
%d@%zu.%06zu:vnc_auth_sasl_mech_list VNC client auth SASL state=%p mechlist=%s
vnc_auth_sasl_mech_list VNC client auth SASL state=%p mechlist=%s
security_model property not set
Valid options are: security_model=[passthrough|mapped-xattr|mapped-file|none]
invalid security_model property '%s'
invalid multidevs property '%s'
Valid options are: multidevs=[remap|forbid|warn]
invalid throttle configuration: 
fmode is only valid for mapped security modes
dmode is only valid for mapped security modes
failed to stat file system at '%s'
9p: broken or compromised client detected; attempt to open special file (i.e. neither regular file, nor directory)
user.virtfs.system.posix_acl_access
user.virtfs.system.posix_acl_default
/home/virus/AMD/AMD/include/qemu/rcu.h
sizeof(struct dirent) + NAME_MAX >= offsetof(struct dirent, d_name) + sz
9p: Potential degraded performance of inode remapping
9p: No more prefixes available for remapping inodes from host to guest.
9p: Multiple devices detected in same VirtFS export. Access of guest to additional devices is (partly) denied due to virtfs option 'multidevs=forbid' being effective.
9p: Multiple devices detected in same VirtFS export, which might lead to file ID collisions and severe misbehaviours on guest! You should either use a separate export for each device shared from host or use virtfs option 'multidevs=remap'!
%d@%zu.%06zu:v9fs_rcancel tag %d id %d
%d@%zu.%06zu:v9fs_rerror tag %d id %d err %d
v9fs_rerror tag %d id %d err %d
%d@%zu.%06zu:v9fs_wstat tag %u id %u fid %d stat={mode %d atime %d mtime %d}
v9fs_wstat tag %u id %u fid %d stat={mode %d atime %d mtime %d}
%d@%zu.%06zu:v9fs_stat tag %d id %d fid %d
v9fs_stat tag %d id %d fid %d
%d@%zu.%06zu:v9fs_stat_return tag %d id %d stat={mode %d atime %d mtime %d length %ld}
v9fs_stat_return tag %d id %d stat={mode %d atime %d mtime %d length %ld}
%d@%zu.%06zu:v9fs_remove tag %d id %d fid %d
v9fs_remove tag %d id %d fid %d
%d@%zu.%06zu:v9fs_clunk tag %d id %d fid %d
v9fs_clunk tag %d id %d fid %d
%d@%zu.%06zu:v9fs_write tag %d id %d fid %d off %lu count %u cnt %d
v9fs_write tag %d id %d fid %d off %lu count %u cnt %d
%d@%zu.%06zu:v9fs_write_return tag %d id %d total %d err %zd
v9fs_write_return tag %d id %d total %d err %zd
%d@%zu.%06zu:v9fs_read tag %d id %d fid %d off %lu max_count %u
v9fs_read tag %d id %d fid %d off %lu max_count %u
9p: bad client: T_read request on directory only expected with 9P2000.u protocol version
%d@%zu.%06zu:v9fs_read_return tag %d id %d count %d err %zd
v9fs_read_return tag %d id %d count %d err %zd
%d@%zu.%06zu:v9fs_create tag %d id %d fid %d name %s perm %d mode %d
v9fs_create tag %d id %d fid %d name %s perm %d mode %d
%d@%zu.%06zu:v9fs_create_return tag %u id %u qid={type %u version %u path %lu} iounit %d
v9fs_create_return tag %u id %u qid={type %u version %u path %lu} iounit %d
%d@%zu.%06zu:v9fs_walk tag=%d id=%d fid=%d newfid=%d nwnames=%d wnames={%s}
v9fs_walk tag=%d id=%d fid=%d newfid=%d nwnames=%d wnames={%s}
%d@%zu.%06zu:v9fs_walk_return tag %d id %d nwnames %d qids %p
v9fs_walk_return tag %d id %d nwnames %d qids %p
%d@%zu.%06zu:v9fs_attach tag %u id %u fid %d afid %d uname %s aname %s
v9fs_attach tag %u id %u fid %d afid %d uname %s aname %s
Migration is disabled when VirtFS export path '%s' is mounted in the guest using mount_tag '%s'
%d@%zu.%06zu:v9fs_attach_return tag %u id %u type %u version %u path %lu
v9fs_attach_return tag %u id %u type %u version %u path %lu
%d@%zu.%06zu:v9fs_version tag %d id %d msize %d version %s
v9fs_version tag %d id %d msize %d version %s
9pfs: Client requested msize < minimum msize (4096) supported by this server.
9p: degraded performance: a reasonable high msize should be chosen on client/guest side (chosen msize is <= 8192). See https://wiki.qemu.org/Documentation/9psetup#msize for details.
%d@%zu.%06zu:v9fs_version_return tag %d id %d msize %d version %s
v9fs_version_return tag %d id %d msize %d version %s
%d@%zu.%06zu:v9fs_mkdir tag %u id %u fid %d name %s mode %d gid %u
v9fs_mkdir tag %u id %u fid %d name %s mode %d gid %u
%d@%zu.%06zu:v9fs_mkdir_return tag %u id %u qid={type %u version %u path %lu} err %d
v9fs_mkdir_return tag %u id %u qid={type %u version %u path %lu} err %d
%d@%zu.%06zu:v9fs_link tag %d id %d dfid %d oldfid %d name %s
v9fs_link tag %d id %d dfid %d oldfid %d name %s
%d@%zu.%06zu:v9fs_getlock tag %d id %d fid %d type %d start %lu length %lu
v9fs_getlock tag %d id %d fid %d type %d start %lu length %lu
%d@%zu.%06zu:v9fs_getlock_return tag %d id %d type %d start %lu length %lu proc_id %u
v9fs_getlock_return tag %d id %d type %d start %lu length %lu proc_id %u
%d@%zu.%06zu:v9fs_lock tag %d id %d fid %d type %d start %lu length %lu
v9fs_lock tag %d id %d fid %d type %d start %lu length %lu
%d@%zu.%06zu:v9fs_lock_return tag %d id %d status %d
v9fs_lock_return tag %d id %d status %d
%d@%zu.%06zu:v9fs_fsync tag %d id %d fid %d datasync %d
v9fs_fsync tag %d id %d fid %d datasync %d
%d@%zu.%06zu:v9fs_readdir tag %d id %d fid %d offset %lu max_count %u
v9fs_readdir tag %d id %d fid %d offset %lu max_count %u
9p: bad client: T_readdir with count > msize - 11
9p: bad client: T_readdir on non-directory stream
9p: bad client: T_readdir request only expected with 9P2000.L protocol version
%d@%zu.%06zu:v9fs_readdir_return tag %d id %d count %u retval %zd
v9fs_readdir_return tag %d id %d count %u retval %zd
%d@%zu.%06zu:v9fs_xattrcreate tag %d id %d fid %d name %s size %lu flags %d
v9fs_xattrcreate tag %d id %d fid %d name %s size %lu flags %d
%d@%zu.%06zu:v9fs_xattrwalk tag %d id %d fid %d newfid %d name %s
v9fs_xattrwalk tag %d id %d fid %d newfid %d name %s
%d@%zu.%06zu:v9fs_xattrwalk_return tag %d id %d size %ld
v9fs_xattrwalk_return tag %d id %d size %ld
%d@%zu.%06zu:v9fs_setattr tag %u id %u fid %d iattr={valid %d mode %d uid %d gid %d size %ld atime=%ld mtime=%ld }
v9fs_setattr tag %u id %u fid %d iattr={valid %d mode %d uid %d gid %d size %ld atime=%ld mtime=%ld }
%d@%zu.%06zu:v9fs_setattr_return tag %u id %u
v9fs_setattr_return tag %u id %u
%d@%zu.%06zu:v9fs_getattr tag %d id %d fid %d request_mask %lu
v9fs_getattr tag %d id %d fid %d request_mask %lu
%d@%zu.%06zu:v9fs_getattr_return tag %d id %d getattr={result_mask %ld mode %u uid %u gid %u}
v9fs_getattr_return tag %d id %d getattr={result_mask %ld mode %u uid %u gid %u}
%d@%zu.%06zu:v9fs_readlink tag %d id %d fid %d
v9fs_readlink tag %d id %d fid %d
%d@%zu.%06zu:v9fs_readlink_return tag %d id %d name %s
v9fs_readlink_return tag %d id %d name %s
%d@%zu.%06zu:v9fs_mknod tag %d id %d fid %d mode %d major %d minor %d
v9fs_mknod tag %d id %d fid %d mode %d major %d minor %d
%d@%zu.%06zu:v9fs_mknod_return tag %u id %u qid={type %u version %u path %lu}
v9fs_mknod_return tag %u id %u qid={type %u version %u path %lu}
%d@%zu.%06zu:v9fs_symlink tag %d id %d fid %d name %s symname %s gid %u
v9fs_symlink tag %d id %d fid %d name %s symname %s gid %u
%d@%zu.%06zu:v9fs_symlink_return tag %u id %u qid={type %u version %u path %lu}
v9fs_symlink_return tag %u id %u qid={type %u version %u path %lu}
%d@%zu.%06zu:v9fs_lcreate tag %d id %d dfid %d flags %d mode %d gid %u
v9fs_lcreate tag %d id %d dfid %d flags %d mode %d gid %u
%d@%zu.%06zu:v9fs_lcreate_return tag %u id %u qid={type %u version %u path %lu} iounit %d
v9fs_lcreate_return tag %u id %u qid={type %u version %u path %lu} iounit %d
%d@%zu.%06zu:v9fs_open tag=%d id=%d fid=%d mode=%d(%s)
v9fs_open tag=%d id=%d fid=%d mode=%d(%s)
%d@%zu.%06zu:v9fs_open_return tag %u id %u qid={type %u version %u path %lu} iounit %d
v9fs_open_return tag %u id %u qid={type %u version %u path %lu} iounit %d
%d@%zu.%06zu:v9fs_flush tag %d id %d flush_tag %d
v9fs_flush tag %d id %d flush_tag %d
the guest sent a self-referencing 9P flush request
9pfs device couldn't find fsdev with the id = %s
fsdev with id %s needs mount_tag arguments
mount tag '%s' (%d bytes) is longer than maximum (%d bytes)
cannot initialize fsdev '%s': 
error in converting name to path %s
share path %s is not a directory
Failed to get the resource limit
%d@%zu.%06zu:xen_9pfs_connect name %s
xenevtchn_bind_interdomain failed port=%d
%d@%zu.%06zu:xen_9pfs_free name %s
%d@%zu.%06zu:xen_9pfs_alloc name %s
%d@%zu.%06zu:xen_9pfs_disconnect name %s
Failed to decode VirtFS request type %d
Failed to encode VirtFS reply type %d
/home/virus/AMD/AMD/include/hw/acpi/acpi_dev_interface.h
/home/virus/AMD/AMD/include/hw/acpi/acpi_aml_interface.h
seg_count > 0 && seg_count <= 255
g_array_get_element_size(table) == 1
ms->numa_state->nodes[i].distance[j]
cpus->cpus[n].props.socket_id > socket_id
cpus->cpus[n].props.cluster_id > cluster_id
cpus->cpus[n].props.core_id > core_id
/home/virus/AMD/AMD/include/system/tpm.h
entry->limit <= UINT32_MAX && (entry->limit - entry->base + 1) <= UINT32_MAX
../hw/acpi/bios-linker-loader.c
!(alloc_align & (alloc_align - 1))
!bios_linker_find_file(linker, file_name)
start_offset < file->blob->len
start_offset + size <= file->blob->len
checksum_offset >= start_offset
checksum_offset + 1 <= start_offset + size
dst_patched_offset < dst_file->blob->len
dst_patched_offset + dst_patched_size <= dst_file->blob->len
src_offset < source_file->blob->len
dst_patched_size == 1 || dst_patched_size == 2 || dst_patched_size == 4 || dst_patched_size == 8
'-acpitable' requires one of 'data' or 'file'
'-acpitable' requires at least one pathname
ACPI table claiming to have header is too short, available: %zu, expected: %zu
ACPI table too big, requested: %zu, max: %u
ACPI table has wrong length, header says %u, actual size %zu bytes
ACPI table: no headers are specified
%d@%zu.%06zu:acpi_gpe_sts_ioport_writeb addr: 0x%x <== 0x%02x
acpi_gpe_sts_ioport_writeb addr: 0x%x <== 0x%02x
%d@%zu.%06zu:acpi_gpe_en_ioport_writeb addr: 0x%x <== 0x%02x
acpi_gpe_en_ioport_writeb addr: 0x%x <== 0x%02x
%d@%zu.%06zu:acpi_gpe_sts_ioport_readb addr: 0x%x ==> 0x%02x
acpi_gpe_sts_ioport_readb addr: 0x%x ==> 0x%02x
%d@%zu.%06zu:acpi_gpe_en_ioport_readb addr: 0x%x ==> 0x%02x
acpi_gpe_en_ioport_readb addr: 0x%x ==> 0x%02x
acpi_data_len(blob) <= max_size
%d@%zu.%06zu:cpuhp_acpi_read_flags idx[0x%x] flags: 0x%x
cpuhp_acpi_read_flags idx[0x%x] flags: 0x%x
%d@%zu.%06zu:cpuhp_acpi_read_cmd_data idx[0x%x] data: 0x%x
cpuhp_acpi_read_cmd_data idx[0x%x] data: 0x%x
%d@%zu.%06zu:cpuhp_acpi_read_cmd_data2 idx[0x%x] data: 0x%x
cpuhp_acpi_read_cmd_data2 idx[0x%x] data: 0x%x
%d@%zu.%06zu:cpuhp_acpi_invalid_idx_selected 0x%x
cpuhp_acpi_invalid_idx_selected 0x%x
%d@%zu.%06zu:cpuhp_acpi_write_idx set active cpu idx: 0x%x
cpuhp_acpi_write_idx set active cpu idx: 0x%x
%d@%zu.%06zu:cpuhp_acpi_clear_inserting_evt idx[0x%x]
cpuhp_acpi_clear_inserting_evt idx[0x%x]
%d@%zu.%06zu:cpuhp_acpi_clear_remove_evt idx[0x%x]
cpuhp_acpi_clear_remove_evt idx[0x%x]
%d@%zu.%06zu:cpuhp_acpi_ejecting_invalid_cpu 0x%x
cpuhp_acpi_ejecting_invalid_cpu 0x%x
%d@%zu.%06zu:cpuhp_acpi_ejecting_cpu 0x%x
%d@%zu.%06zu:cpuhp_acpi_fw_remove_invalid_cpu 0x%x
cpuhp_acpi_fw_remove_invalid_cpu 0x%x
%d@%zu.%06zu:cpuhp_acpi_fw_remove_cpu 0x%x
cpuhp_acpi_fw_remove_cpu 0x%x
%d@%zu.%06zu:cpuhp_acpi_write_cmd idx[0x%x] cmd: 0x%x
cpuhp_acpi_write_cmd idx[0x%x] cmd: 0x%x
%d@%zu.%06zu:cpuhp_acpi_cpu_has_events idx[0x%x] inserting: %d, removing: %d
cpuhp_acpi_cpu_has_events idx[0x%x] inserting: %d, removing: %d
%d@%zu.%06zu:cpuhp_acpi_write_ost_ev idx[0x%x] OST EVENT: 0x%x
cpuhp_acpi_write_ost_ev idx[0x%x] OST EVENT: 0x%x
%d@%zu.%06zu:cpuhp_acpi_write_ost_status idx[0x%x] OST STATUS: 0x%x
cpuhp_acpi_write_ost_status idx[0x%x] OST STATUS: 0x%x
(rs == AML_SYSTEM_IO) || (rs == AML_SYSTEM_MEMORY)
/home/virus/AMD/AMD/include/hw/pci/pci_device.h
/home/virus/AMD/AMD/include/hw/i386/x86.h
max_cpus is too large. APIC ID of last CPU is %u
cpu_apic_id < ACPI_CPU_HOTPLUG_ID_LIMIT
acpi_memory_slot_status: device [%s] returned invalid memory slot[%d]
%d@%zu.%06zu:mhp_acpi_invalid_slot_selected 0x%x
mhp_acpi_invalid_slot_selected 0x%x
%d@%zu.%06zu:mhp_acpi_write_slot set active slot: 0x%x
mhp_acpi_write_slot set active slot: 0x%x
%d@%zu.%06zu:mhp_acpi_write_ost_ev slot[0x%x] OST EVENT: 0x%x
mhp_acpi_write_ost_ev slot[0x%x] OST EVENT: 0x%x
%d@%zu.%06zu:mhp_acpi_write_ost_status slot[0x%x] OST STATUS: 0x%x
mhp_acpi_write_ost_status slot[0x%x] OST STATUS: 0x%x
%d@%zu.%06zu:mhp_acpi_clear_insert_evt slot[0x%x] clear insert event
mhp_acpi_clear_insert_evt slot[0x%x] clear insert event
%d@%zu.%06zu:mhp_acpi_clear_remove_evt slot[0x%x] clear remove event
mhp_acpi_clear_remove_evt slot[0x%x] clear remove event
%d@%zu.%06zu:mhp_acpi_ejecting_invalid_slot 0x%x
mhp_acpi_ejecting_invalid_slot 0x%x
%d@%zu.%06zu:mhp_acpi_pc_dimm_delete_failed slot[0x%x] pc-dimm delete failed
mhp_acpi_pc_dimm_delete_failed slot[0x%x] pc-dimm delete failed
%d@%zu.%06zu:mhp_acpi_pc_dimm_deleted slot[0x%x] pc-dimm deleted
mhp_acpi_pc_dimm_deleted slot[0x%x] pc-dimm deleted
%d@%zu.%06zu:mhp_acpi_read_addr_lo slot[0x%x] addr lo: 0x%x
mhp_acpi_read_addr_lo slot[0x%x] addr lo: 0x%x
%d@%zu.%06zu:mhp_acpi_read_addr_hi slot[0x%x] addr hi: 0x%x
mhp_acpi_read_addr_hi slot[0x%x] addr hi: 0x%x
%d@%zu.%06zu:mhp_acpi_read_size_lo slot[0x%x] size lo: 0x%x
mhp_acpi_read_size_lo slot[0x%x] size lo: 0x%x
%d@%zu.%06zu:mhp_acpi_read_size_hi slot[0x%x] size hi: 0x%x
mhp_acpi_read_size_hi slot[0x%x] size hi: 0x%x
%d@%zu.%06zu:mhp_acpi_read_pxm slot[0x%x] proximity: 0x%x
mhp_acpi_read_pxm slot[0x%x] proximity: 0x%x
%d@%zu.%06zu:mhp_acpi_read_flags slot[0x%x] flags: 0x%x
mhp_acpi_read_flags slot[0x%x] flags: 0x%x
%d@%zu.%06zu:acpi_nvdimm_read_io_port Alert: we never read _DSM IO Port
acpi_nvdimm_read_io_port Alert: we never read _DSM IO Port
%d@%zu.%06zu:acpi_nvdimm_label_overflow offset 0x%x + length 0x%x is overflow
acpi_nvdimm_label_overflow offset 0x%x + length 0x%x is overflow
%d@%zu.%06zu:acpi_nvdimm_label_oversize position 0x%x is beyond label data (len = %lu)
acpi_nvdimm_label_oversize position 0x%x is beyond label data (len = %lu)
%d@%zu.%06zu:acpi_nvdimm_label_xfer_exceed length (0x%x) is larger than max_xfer (0x%x)
acpi_nvdimm_label_xfer_exceed length (0x%x) is larger than max_xfer (0x%x)
%d@%zu.%06zu:acpi_nvdimm_dsm_mem_addr dsm memory address 0x%lx
acpi_nvdimm_dsm_mem_addr dsm memory address 0x%lx
%d@%zu.%06zu:acpi_nvdimm_dsm_info Revision 0x%x Handle 0x%x Function 0x%x
acpi_nvdimm_dsm_info Revision 0x%x Handle 0x%x Function 0x%x
%d@%zu.%06zu:acpi_nvdimm_invalid_revision Revision 0x%x is not supported, expect 0x1
acpi_nvdimm_invalid_revision Revision 0x%x is not supported, expect 0x1
%d@%zu.%06zu:acpi_nvdimm_read_fit Read FIT: offset 0x%x FIT size 0x%x Dirty %s
acpi_nvdimm_read_fit Read FIT: offset 0x%x FIT size 0x%x Dirty %s
%d@%zu.%06zu:acpi_nvdimm_label_info label_size 0x%x, max_xfer 0x%x
acpi_nvdimm_label_info label_size 0x%x, max_xfer 0x%x
/home/virus/AMD/AMD/include/hw/mem/nvdimm.h
%d@%zu.%06zu:acpi_nvdimm_read_label Read Label Data: offset 0x%x length 0x%x
acpi_nvdimm_read_label Read Label Data: offset 0x%x length 0x%x
size <= NVDIMM_DSM_MEMORY_SIZE
%d@%zu.%06zu:acpi_nvdimm_write_label Write Label Data: offset 0x%x length 0x%x
acpi_nvdimm_write_label Write Label Data: offset 0x%x length 0x%x
offsetof(NvdimmDsmIn, arg3) + sizeof(*set_label_data) + set_label_data->length <= NVDIMM_DSM_MEMORY_SIZE
2F10E7A4-9E91-11E4-89D3-123B93F75CBA
648B9CF2-CDA1-4312-8AD9-49C4AF32BD62
4309AC30-0D11-11E4-9191-0800200C9A66
PCI device to associate with the node
NUMA node associated with the PCI device
PCI Bus of the host bridge associated with this GP affinity structure
The NUMA node like ID to index HMAT/SLIT NUMA properties involving GP
%s: Specified node %d is invalid.
%s: Specified device must be a PCI device.
devfn >= 0 && devfn < PCI_DEVFN_MAX
%s: device must be a CXL host bridge.
%s: Invalid NUMA node specified
/home/virus/AMD/AMD/include/hw/pci/pci_bridge.h
/home/virus/AMD/AMD/include/hw/sysbus.h
F365F9A6-A7DE-4071-A66A-B40C0B4F8E52
68F2D50B-C469-4D8A-BD3D-941A103FD3FC
33DB4D5B-1FF7-401C-9657-7441C03DD766
/home/virus/AMD/AMD/include/hw/acpi/vmgenid.h
%s requires DMA write support in fw_cfg, which this machine type does not provide
at most one %s device is permitted
/home/virus/AMD/AMD/include/hw/acpi/vmclock.h
/home/virus/AMD/AMD/include/hw/hotplug.h
/home/virus/AMD/AMD/include/hw/acpi/generic_event_device.h
GED: Unsupported event %d. No irq injected
acpi: device unplug for unsupported device type: %s
../hw/acpi/generic_event_device.c
acpi: device unplug request for unsupported device type: %s
virt: device plug request for unsupported device type: %s
/home/virus/AMD/AMD/include/hw/acpi/piix4.h
memory hotplug is not enabled: %s.memory-hotplug-support is not set
acpi: device pre plug request for not supported device type: %s
acpi: device unplug for not supported device type: %s
acpi: device unplug request for not supported device type: %s
acpi-pci-hotplug-with-bridge-support
acpi_pci_hotplug.acpi_pcihp_pci_status[0x0]
acpi_pci_hotplug.hotplug_select
acpi_pci_hotplug.acpi_pcihp_pci_status
%d@%zu.%06zu:acpi_pci_up_read %u
%d@%zu.%06zu:acpi_pci_down_read %u
%d@%zu.%06zu:acpi_pci_features_read %u
%d@%zu.%06zu:acpi_pci_rmv_read %u
%d@%zu.%06zu:acpi_pci_sel_read %u
%d@%zu.%06zu:acpi_pci_acpi_index_read %u
%d@%zu.%06zu:acpi_pci_eject_slot bsel: %u slot: %u
acpi_pci_eject_slot bsel: %u slot: %u
%d@%zu.%06zu:acpi_pci_acpi_index_write bsel: %u slot: %u aidx: %u
acpi_pci_acpi_index_write bsel: %u slot: %u aidx: %u
%d@%zu.%06zu:acpi_pci_ej_write 0x%lx <== %lu
acpi_pci_ej_write 0x%lx <== %lu
%d@%zu.%06zu:acpi_pci_sel_write 0x%lx <== %lu
acpi_pci_sel_write 0x%lx <== %lu
/home/virus/AMD/AMD/include/hw/pci/pci_host.h
Unsupported bus. Bus doesn't have property 'acpi-pcihp-bsel' set
%d@%zu.%06zu:acpi_pci_unplug bsel: %d slot: %d
acpi_pci_unplug bsel: %d slot: %d
acpi_pci_unplug_request bsel: %d slot: %d
%d@%zu.%06zu:acpi_pci_unplug_request bsel: %d slot: %d
/home/virus/AMD/AMD/include/hw/pci/pcie_port.h
/home/virus/AMD/AMD/include/hw/southbridge/ich9.h
(pm_io_base & ICH9_PMIO_MASK) == 0
cpu hotplug with SMI wasn't enabled by firmware
update machine type to newer than 5.1 and firmware that suppors CPU hotplug with SMM
acpi: device plug request for not supported device type: %s
cpu hot-unplug with SMI wasn't enabled by firmware
update machine type to a version having x-smi-cpu-hotunplug=on and firmware that supports CPU hot-unplug with SMM
%d@%zu.%06zu:tco_io_read addr=0x%lx val=0x%x
tco_io_read addr=0x%lx val=0x%x
%d@%zu.%06zu:tco_timer_expired timeouts_no=%d no_reboot=%d/%d
tco_timer_expired timeouts_no=%d no_reboot=%d/%d
%d@%zu.%06zu:tco_timer_reload ticks=%d (%d ms)
tco_timer_reload ticks=%d (%d ms)
%d@%zu.%06zu:tco_io_write addr=0x%lx val=0x%x
tco_io_write addr=0x%lx val=0x%x
%d@%zu.%06zu:acpi_erst_reset_in record_count %u
acpi_erst_reset_in record_count %u
%d@%zu.%06zu:acpi_erst_reset_out record_count %u
acpi_erst_reset_out record_count %u
%d@%zu.%06zu:acpi_erst_reg_read  addr: 0x%04lx ==> 0x%016lx (size: %u)
acpi_erst_reg_read  addr: 0x%04lx ==> 0x%016lx (size: %u)
%d@%zu.%06zu:acpi_erst_realizefn_in 
can't use already busy memdev: %s
QEMU_PTR_IS_ALIGNED(header, sizeof(uint64_t))
ERST record_size %u is invalid
ERST backend storage header is invalid
ACPI ERST requires storage size be multiple of record size (%uKiB)
%d@%zu.%06zu:acpi_erst_realizefn_out total nvram size %u bytes
acpi_erst_realizefn_out total nvram size %u bytes
%d@%zu.%06zu:acpi_erst_class_init_in 
ACPI Error Record Serialization Table (ERST) device
%d@%zu.%06zu:acpi_erst_class_init_out 
%d@%zu.%06zu:acpi_erst_post_load header: 0x%p slot_size %u
acpi_erst_post_load header: 0x%p slot_size %u
%d@%zu.%06zu:acpi_erst_reg_write addr: 0x%04lx <== 0x%016lx (size: %u)
acpi_erst_reg_write addr: 0x%04lx <== 0x%016lx (size: %u)
%d@%zu.%06zu:acpi_erst_pci_bar_0 BAR0: 0x%016lx
acpi_erst_pci_bar_0 BAR0: 0x%016lx
(table_instruction_data->len) % 32 == 0
/home/virus/AMD/AMD/include/hw/ipmi/ipmi.h
info.ipmi_spec_minor_revision <= 15
3DDDFAA6-361B-4EB4-A424-8D10089D1653
376054ED-CC13-4675-901C-4756D7F2D45D
command is not supported, missing ACPI device
soundhw_count < ARRAY_SIZE(soundhw) - 1
Valid sound card names (comma separated):
Machine has no user-selectable audio hardware (it may or may not have always-present audio hardware).
only one -soundhw option is allowed
invalid bm_index(%d) in voice_set_active
attempt to use voice %d with invalid frequency %d
Initializing audio voice failed
/home/virus/AMD/AMD/include/hw/isa/isa.h
error: unsupported frequency (val=%#x)
error: attempt to use reserved format value (%#x)
error: ADPCM 4 bit IMA compatible format is not supported
warning: attempt to write %#x to reserved indirect register %d
warning: [P]MCE(%#x, %#x) is not set, val=%#x
warning: PIO is not supported (%#x)
warning: attempt to write to read only register %d
error: timer is not yet supported
warning: write to Version_Chip_ID register %#x
warning: attempt to write value %#x to PIO register
ISA controller does not support DMA
%d@%zu.%06zu:es1370_stream_format ch=%d fmt=%u:%s:%s shift=%u
es1370_stream_format ch=%d fmt=%u:%s:%s shift=%u
%d@%zu.%06zu:es1370_sample_count_rd ch=%d CURR_SAMP_CT=%u SAMP_CT=%u
es1370_sample_count_rd ch=%d CURR_SAMP_CT=%u SAMP_CT=%u
%d@%zu.%06zu:es1370_frame_count_rd ch=%d CURR_CT=%u BUF_SIZE=%u
es1370_frame_count_rd ch=%d CURR_CT=%u BUF_SIZE=%u
%d@%zu.%06zu:es1370_frame_address_rd ch=%d addr=0x%08x
es1370_frame_address_rd ch=%d addr=0x%08x
%d@%zu.%06zu:es1370_lost_interrupt ch=%d lost interrupt
es1370_lost_interrupt ch=%d lost interrupt
%d@%zu.%06zu:es1370_transfer_audio ch=%d CURR_CT=%u BUF_SIZE=%u CURR_SAMP_CT=%u SAMP_CT=%u leftover=%u irq=%d
es1370_transfer_audio ch=%d CURR_CT=%u BUF_SIZE=%u CURR_SAMP_CT=%u SAMP_CT=%u leftover=%u irq=%d
%d@%zu.%06zu:es1370_sample_count_wr ch=%d CURR_SAMP_CT=%u SAMP_CT=%u
es1370_sample_count_wr ch=%d CURR_SAMP_CT=%u SAMP_CT=%u
%d@%zu.%06zu:es1370_frame_address_wr ch=%d addr=0x%08x
es1370_frame_address_wr ch=%d addr=0x%08x
%d@%zu.%06zu:es1370_frame_count_wr ch=%d CURR_CT=%u BUF_SIZE=%u
es1370_frame_count_wr ch=%d CURR_CT=%u BUF_SIZE=%u
You have to use msi=auto (default) or msi=off with this machine type.
!err || d->msi == ON_OFF_AUTO_AUTO
intel-hda: write to r/o reg %s
previous register op repeated %d times
Intel HD Audio Controller (ich9)
Intel HD Audio Controller (ich6)
st #%d: start %d (ring buf %d bytes)
%s: [irr] response 0x%x, cad 0x%x
%s: rirb dma disabled, drop codec response
%s: [wp 0x%x] response 0x%x, extra 0x%x
dma: entry %d, pos %d/%d, copy %d
HDA audio codec address is full
%s: indirect node addressing (guest bug?)
%s: addressed non-existing codec
%d@%zu.%06zu:hda_audio_format st %s, %d x %s @ %d Hz
hda_audio_format st %s, %d x %s @ %d Hz
%d@%zu.%06zu:hda_audio_overrun st %s
%d@%zu.%06zu:hda_audio_adjust st %s, pos %d
hda_audio_adjust st %s, pos %d
%d@%zu.%06zu:hda_audio_running st %s, nr %d, run %d
hda_audio_running st %s, nr %d, run %d
%s: nid %d (%s), verb 0x%x, payload 0x%x
amp (%s): %s%s%s%s index %d  gain %3d %s
%s: not handled: nid %d (%s), verb 0x%x, payload 0x%x
HDA Audio Codec, output-only (line-out)
HDA Audio Codec, duplex (speaker, microphone)
HDA Audio Codec, duplex (line-out, line-in)
node->stindex < ARRAY_SIZE(a->st)
empty output buffer for command %#x
attempt to change DMA 8bit %d(%d), 16bit %d(%d) (val=%#x)
attempt to write into IRQ status register (val=%#x)
sampling range too low: %d, increasing to %u
sampling range too high: %d, decreasing to %u
warning: misaligned block size %d, alignment %d
invalid block size=%d nchan=%d dma_pos=%d dma_len=%d
warning: Could not create auxiliary timer
ADC not yet supported (command %#x)
0x35 - MIDI command not implemented
0x75 - DMA DAC, 4-bit ADPCM not implemented
0x74 - DMA DAC, 4-bit ADPCM Reference not implemented
0x74 - DMA DAC, 2.6-bit ADPCM not implemented
0x74 - DMA DAC, 2.6-bit ADPCM Reference not implemented
0x7d - Autio-Initialize DMA DAC, 4-bit ADPCM Reference
0x7d - Autio-Initialize DMA DAC, 2.6-bit ADPCM Reference
Attempt to probe for ESS (0xe7)?
warning: command %#x,%d is not truly understood yet
ADC params cmd = %#x d0 = %d, d1 = %d, d2 = %d
complete: unrecognized command %#x
%d@%zu.%06zu:virtio_snd_get_features snd %p: get_features 0x%lx
virtio_snd_get_features snd %p: get_features 0x%lx
virtio_snd: event queue is unimplemented.
%d@%zu.%06zu:virtio_snd_handle_event event queue callback called
virtio_snd_handle_event event queue callback called
%d@%zu.%06zu:virtio_snd_vm_state_running vm state running
virtio_snd_vm_state_running vm state running
%d@%zu.%06zu:virtio_snd_vm_state_stopped vm state stopped
virtio_snd_vm_state_stopped vm state stopped
%d@%zu.%06zu:virtio_snd_get_config snd %p: get_config jacks=%u streams=%u chmaps=%u
virtio_snd_get_config snd %p: get_config jacks=%u streams=%u chmaps=%u
/home/virus/AMD/AMD/include/hw/virtio/virtio.h
!QSIMPLEQ_EMPTY(&vsnd->invalid)
Streams have not been initialized.
Number of channels is not supported.
Stream format is not supported.
QSIMPLEQ_EMPTY(&vsnd->invalid)
size <= MIN(buffer->size, available)
%s: virtio-snd command size incorrect %zu vs                 %zu
%d@%zu.%06zu:virtio_snd_handle_pcm_start_stop %s called for stream %u
virtio_snd_handle_pcm_start_stop %s called for stream %u
%d@%zu.%06zu:virtio_snd_handle_tx_xfer tx queue callback called
virtio_snd_handle_tx_xfer tx queue callback called
%d@%zu.%06zu:virtio_snd_handle_code ctrl code msg val = %u == %s
virtio_snd_handle_code ctrl code msg val = %u == %s
virtio_snd: jack functionality is unimplemented.
pcm info: buffer too small, got: %zu, needed: %zu
%d@%zu.%06zu:virtio_snd_handle_pcm_info VIRTIO_SND_R_PCM_INFO called for stream %u
virtio_snd_handle_pcm_info VIRTIO_SND_R_PCM_INFO called for stream %u
%d@%zu.%06zu:virtio_snd_handle_pcm_set_params VIRTIO_SND_PCM_SET_PARAMS called for stream %u
virtio_snd_handle_pcm_set_params VIRTIO_SND_PCM_SET_PARAMS called for stream %u
%d@%zu.%06zu:virtio_snd_handle_pcm_release VIRTIO_SND_PCM_RELEASE called for stream %u
virtio_snd_handle_pcm_release VIRTIO_SND_PCM_RELEASE called for stream %u
%d@%zu.%06zu:virtio_snd_pcm_stream_flush flushing stream %u
virtio_snd_pcm_stream_flush flushing stream %u
virtio_snd: chmap info functionality is unimplemented.
%d@%zu.%06zu:virtio_snd_handle_chmap_info VIRTIO_SND_CHMAP_INFO called
virtio_snd_handle_chmap_info VIRTIO_SND_CHMAP_INFO called
virtio snd header not recognized: %u
%d@%zu.%06zu:virtio_snd_unrealize snd %p: unrealize
virtio_snd_unrealize snd %p: unrealize
%d@%zu.%06zu:virtio_snd_realize snd %p: realize
virtio_snd_realize snd %p: realize
Invalid number of channel maps: %u
Can't initialize stream params, device responded with %s.
Can't prepare streams, device responded with %s.
%d@%zu.%06zu:virtio_snd_handle_ctrl snd %p: handle ctrl event for queue %p
virtio_snd_handle_ctrl snd %p: handle ctrl event for queue %p
%d@%zu.%06zu:virtio_snd_handle_rx_xfer rx queue callback called
virtio_snd_handle_rx_xfer rx queue callback called
/home/virus/AMD/AMD/include/hw/virtio/virtio-pci.h
can't get size of %s block backend
%s device '%s' requires %lu bytes, %s block backend provides %lu bytes
size <= BDRV_REQUEST_MAX_BYTES
can't read %s block backend for %s device '%s'
logical_block_size > physical_block_size not supported
min_io_size must be a multiple of logical_block_size
min_io_size must not exceed %u logical blocks
opt_io_size must be a multiple of logical_block_size
discard_granularity must be a multiple of logical_block_size
heads must be between 1 and %u
%d@%zu.%06zu:hd_geometry_lchs_guess blk %p LCHS %d %d %d
hd_geometry_lchs_guess blk %p LCHS %d %d %d
%d@%zu.%06zu:hd_geometry_guess blk %p CHS %u %u %u trans %d
hd_geometry_guess blk %p CHS %u %u %u trans %d
fdc: unimplemented command 0x%02x
type_match != -1 && "misconfigured fd_format"
Can't create floppy unit %d, bus supports only %d units
Physical and logical block size must be 512 for floppy
fdc doesn't support drive option werror
fdc doesn't support drive option rerror
drv->drive != FLOPPY_DRIVE_TYPE_AUTO
fdctrl_start_transfer_del() unimplemented
!(fdctrl->msr & FD_MSR_NONDMA)
%d@%zu.%06zu:fdc_ioport_read read reg 0x%02x val 0x%02x
fdc_ioport_read read reg 0x%02x val 0x%02x
%d@%zu.%06zu:fdc_ioport_write write reg 0x%02x val 0x%02x
fdc_ioport_write write reg 0x%02x val 0x%02x
fdctrl->data_pos < FD_SECTOR_LEN
Cannot choose a fallback FDrive type of 'auto'
%d@%zu.%06zu:pflash_postload_cb %s: updating bdrv
pflash_postload_cb %s: updating bdrv
/home/virus/AMD/AMD/include/qemu/bitops.h
start >= 0 && length > 0 && length <= 32 - start
%d@%zu.%06zu:pflash_data_write_block %s: data offset:0x%04lx size:%u value:0x%04x counter:0x%016lx
pflash_data_write_block %s: data offset:0x%04lx size:%u value:0x%04x counter:0x%016lx
%d@%zu.%06zu:pflash_data_write %s: data offset:0x%04lx size:%u value:0x%04x
pflash_data_write %s: data offset:0x%04lx size:%u value:0x%04x
/home/virus/AMD/AMD/include/qemu/bswap.h
/home/virus/AMD/AMD/include/hw/block/flash.h
attribute "sector-length" not specified or zero.
attribute "num-blocks" not specified or zero.
attribute "name" not specified.
%d@%zu.%06zu:pflash_data_read %s: data offset:0x%04lx size:%u value:0x%04x
pflash_data_read %s: data offset:0x%04lx size:%u value:0x%04x
%d@%zu.%06zu:pflash_reset %s: reset
%d@%zu.%06zu:pflash_read_unknown_state %s: unknown command state:0x%x
pflash_read_unknown_state %s: unknown command state:0x%x
%d@%zu.%06zu:pflash_read_status %s: status:0x%x
pflash_read_status %s: status:0x%x
%d@%zu.%06zu:pflash_manufacturer_id %s: read manufacturer ID: 0x%04x
pflash_manufacturer_id %s: read manufacturer ID: 0x%04x
%d@%zu.%06zu:pflash_device_id %s: read device ID: 0x%04x
pflash_device_id %s: read device ID: 0x%04x
%d@%zu.%06zu:pflash_device_info %s: read device information offset:0x%04lx
pflash_device_info %s: read device information offset:0x%04lx
%d@%zu.%06zu:pflash_unsupported_device_configuration %s: unsupported device configuration: device_width:%d max_device_width:%d
pflash_unsupported_device_configuration %s: unsupported device configuration: device_width:%d max_device_width:%d
%d@%zu.%06zu:pflash_io_read %s: offset:0x%04lx size:%u value:0x%04x cmd:0x%02x wcycle:%u
pflash_io_read %s: offset:0x%04lx size:%u value:0x%04x cmd:0x%02x wcycle:%u
%d@%zu.%06zu:pflash_io_write %s: offset:0x%04lx size:%u value:0x%04x wcycle:%u
pflash_io_write %s: offset:0x%04lx size:%u value:0x%04x wcycle:%u
%d@%zu.%06zu:pflash_write %s: %s
%d@%zu.%06zu:pflash_write_block_erase %s: block erase offset:0x%lx bytes:0x%lx
pflash_write_block_erase %s: block erase offset:0x%lx bytes:0x%lx
%d@%zu.%06zu:pflash_write_block_start %s: block write start: bytes:0x%x
pflash_write_block_start %s: block write start: bytes:0x%x
%d@%zu.%06zu:pflash_write_block_flush %s: block write flush
pflash_write_block_flush %s: block write flush
%d@%zu.%06zu:pflash_write_block_abort %s: block write abort
pflash_write_block_abort %s: block write abort
%s: Unimplemented flash cmd sequence (offset %016lx, wcycle 0x%x cmd 0x%x value 0x%x)
%d@%zu.%06zu:pflash_mode_read_array %s: read array mode
pflash_mode_read_array %s: read array mode
QEMU_IS_ALIGNED(size, sector_len)
%d@%zu.%06zu:xen_cdrom_unrealize 
%d@%zu.%06zu:xen_disk_unrealize 
/home/virus/AMD/AMD/include/hw/xen/xen-bus.h
invalid virtual disk specifier
%d@%zu.%06zu:xen_block_blockdev_del %s
%d@%zu.%06zu:xen_disk_realize 
%d@%zu.%06zu:xen_block_device_create %u
invalid device-type parameter '%s'
%d@%zu.%06zu:xen_block_blockdev_add %s
/home/virus/AMD/AMD/include/hw/xen/xen-block.h
realization of device %s failed: 
%d@%zu.%06zu:xen_block_size %s d%up%u %li
cannot find device vdev for block device
%d@%zu.%06zu:xen_cdrom_realize 
%d@%zu.%06zu:xen_block_disconnect %s d%up%u
xen_block_disconnect %s d%up%u
%d@%zu.%06zu:xen_block_unrealize %s d%up%u
xen_block_unrealize %s d%up%u
%d@%zu.%06zu:xen_block_device_destroy %u
%d@%zu.%06zu:xen_block_connect %s d%up%u
logical_block_size != %u not supported by frontend
%d@%zu.%06zu:xen_block_realize %s d%up%u
device needs media, but drive is empty
Virtual Disk specifier (d*p*/xvd*/hd*/sd*)
/home/virus/AMD/AMD/include/hw/ipack/ipack.h
size + ch->rx_pending <= RX_FIFO_SIZE
GE IP-Octal 232 8-channel RS-232 IndustryPack
/home/virus/AMD/AMD/include/hw/char/parallel-isa.h
Can't create debugcon device, empty char device
%d@%zu.%06zu:parallel_ioport_read read [%s] addr 0x%02x val 0x%02x
parallel_ioport_read read [%s] addr 0x%02x val 0x%02x
%d@%zu.%06zu:parallel_ioport_write write [%s] addr 0x%02x val 0x%02x
parallel_ioport_write write [%s] addr 0x%02x val 0x%02x
Can't create parallel device, empty char device
Max. supported number of parallel ports is %d.
%d@%zu.%06zu:serial_update_parameters baudrate=%lu parity='%c' data=%d stop=%d
serial_update_parameters baudrate=%lu parity='%c' data=%d stop=%d
start >= 0 && length > 0 && length <= 16 - start
/home/virus/AMD/AMD/include/hw/char/serial.h
!fifo8_is_empty(&s->xmit_fifo)
inconsistent state in serial device (tsr empty, tsr_retry=%d
inconsistent state in serial device (tsr not empty, tsr_retry=0
%d@%zu.%06zu:serial_write write addr 0x%02x val 0x%02x
serial_write write addr 0x%02x val 0x%02x
%d@%zu.%06zu:serial_read read addr 0x%02x val 0x%02x
serial_read read addr 0x%02x val 0x%02x
Max. supported number of ISA serial ports is %d.
/home/virus/AMD/AMD/include/hw/virtio/virtio-serial.h
%d@%zu.%06zu:virtio_console_chr_event port %u, event %d
virtio_console_chr_event port %u, event %d
%d@%zu.%06zu:virtio_console_flush_buf port %u, in_len %zu, out_len %zd
virtio_console_flush_buf port %u, in_len %zu, out_len %zd
%d@%zu.%06zu:virtio_console_chr_read port %u, size %d
virtio_console_chr_read port %u, size %d
Port number 0 on virtio-serial devices reserved for virtconsole devices for backward compatibility.
%d@%zu.%06zu:xen_console_device_create idx %u
xen_console_device_create idx %u
/local/domain/%u/device/console/%u
failed to generate frontend path
failed to read console device type: 
declining to handle console type '%s'
console: No valid chardev found at '%s': 
console: No valid chardev found: 
console: No serial device #%ld found
console: failed to create null device
console: failed to initialize backing chardev: 
realization of console device %lu failed: 
%d@%zu.%06zu:xen_console_device_destroy idx %u
xen_console_device_destroy idx %u
failed to create frontend path
cannot find device index for console device
%d@%zu.%06zu:xen_console_disconnect idx %u
xen_console_disconnect idx %u
%d@%zu.%06zu:xen_console_unrealize idx %u
failed to map console grant ref: 
%d@%zu.%06zu:xen_console_connect idx %u ring_ref %u port %u limit %u
xen_console_connect idx %u ring_ref %u port %u limit %u
cannot create primary Xen console
%d@%zu.%06zu:xen_console_realize idx %u chrdev %s
xen_console_realize idx %u chrdev %s
/home/virus/AMD/AMD/include/hw/core/generic-loader.h
Specifying a file is not supported when loading memory values
Specifying force-raw is not supported when loading memory values
Both data and data-len must be specified
data-len cannot be greater then 8 bytes
cpu_num must be specified when setting a program counter
please include valid arguments
Specified boot CPU#%d is nonexistent
Cannot load specified image %s
s->data_len <= sizeof(s->data)
Cannot specify a kernel and initrd in same stanza
Need to specify a kernel or initrd image
Need to specify the address of guest blob
Boot args only relevant to kernel blobs
Cannot modify FDT fields if the machine has none
Obtaining memory mappings is unsupported on this CPU.
ret < cpu->num_ases && ret >= 0
/home/virus/AMD/AMD/include/hw/fw-path-provider.h
n >= 0 && n < gpio_list->num_in
gpio_list->num_out == 0 || !name
gpio_list->num_in == 0 || !name
ROM images must be loaded at startup
%d@%zu.%06zu:loader_write_rom %s: @0x%lx size=0x%lx ROM=%d
loader_write_rom %s: @0x%lx size=0x%lx ROM=%d
The image is from incompatible architecture
The image has incorrect endianness
The image segments are too big to load
Error: inflateInit2() returned %d
Error: gunzip out of data in header
%s: unable to decompress gzipped kernel file
unable to handle EFI zboot image with "%.*s" compression
unable to handle corrupt EFI zboot image
failed to decompress EFI zboot image
Specifying an Address Space and Memory Region is not valid when loading a rom
Wrong image type %d, expected %d
this image format (kernel_noload) cannot be loaded on this machine type
Unable to load u-boot images with compression type %d
Unable to decompress gzipped image!
Unsupported relocation type %i!
/home/virus/AMD/AMD/include/hw/elf_ops.h.inc
%s ELF program header segment %d
Some ROM regions are overlapping
These ROM regions might have been loaded by direct user request or by default.
They could be BIOS/firmware images, a guest kernel, initrd or some other file loaded into guest memory.
Check whether you intended to load all this guest code, and whether it has been built to load to the correct addresses.
The following two regions overlap (in the %s address space):
  %s (addresses 0x%016lx - 0x%016lx)
/home/virus/AMD/AMD/include/qemu/int128.h
addr=%016lx size=0x%06zx mem=%s name="%s"
fw=%s/%s size=0x%06zx name="%s"
/home/virus/AMD/AMD/include/hw/intc/intc.h
IRQ statistics not available for %s.
Interrupt controller information not available for %s.
machine does not support hot-plugging CPUs
The command is permitted only before the machine has been created
wake-up from suspend is not supported by this guest
VM Generation ID device not found
Dump current dtb to a file and quit
Cache properties list for SMP machine
The first phandle ID we may generate dynamically
Overrides the "compatible" property of the dt root node
Include guest memory in a core dump
Enable/disable memory merge support
Set on/off to enable/disable usb
Set on/off to enable/disable graphics emulation
Set on to disable self-describing migration
Set confidential guest scheme to support
Set memory encryption object to use
Set RAM backendValid value is ID of hostmem based backend
No such memory encryption object '%s'
g_str_has_suffix(cname, TYPE_MACHINE_SUFFIX)
x-use-canonical-path-for-ramblock-id
-machine nvdimm-persistence=%s: unsupported option
Set on/off to enable/disable NVDIMM instantiation
Set NVDIMM persistenceValid values are cpu, mem-ctrl
Set on/off to enable/disable ACPI Heterogeneous Memory Attribute Table (HMAT)
invalid value of maxmem: maximum memory size (0x%lx) must be at least the initial memory size (0x%lx)
invalid value of maxmem: memory slots were specified but maximum memory size (0x%lx) is equal to the initial memory size (0x%lx)
slots specified but no max-size
mapping of CPUs to NUMA node is not supported
CPU is already assigned to node-id: %ld
The initiator of CPU NUMA node %ld should be itself (got %u)
Audiodev to use for default machine devices
memory backend %s can't be used multiple times.
Machine memory size does not match the size of the memory backend
object's id '%s' is reserved for the default RAM backend, it can't be used for any other purposes
Change the object's 'id' to something else or disable automatic creation of the default RAM backend by setting 'memory-backend=%s' with '-machine'.
machine->numa_state->num_nodes
NUMA node %u is missing, use '-numa node' option to declare it first
The initiator of NUMA node %d is invalid
CPU(s) not present in any NUMA nodes: %s
All CPU(s) up to maxcpus should be described in NUMA config, ability to start up with partial NUMA mappings is obsoleted and will be removed in future
CPU-%d and CPU-%d in socket-%ld-cluster-%ld have been associated with node-%ld and node-%ld respectively. It can cause OSes like Linux to misbehave
mc->valid_cpu_types[0] != NULL
CPU model %s is deprecated -- %s
x-config-reg-migration-enabled
virtio-rng-pci-non-transitional
multifd-flush-after-each-section
x-pci-express-writeable-slt-bug
backcompat-pauth-default-use-qarma5
virtio-balloon-pci-transitional
virtio-balloon-pci-non-transitional
/home/virus/AMD/AMD/include/hw/nmi.h
The -kernel parameter is not supported (use the generic 'loader' device instead).
Max number of NUMA nodes reached: %u
ACPI Heterogeneous Memory Attribute Table (HMAT) is disabled, enable it with -machine hmat=on before using any of hmat specific options
The initiator id %u expects an integer between 0 and %d
CPU index (%u) should be smaller than maxcpus (%d)
numa configuration should use either mem= or memdev=,mixing both is not allowed
Parameter -numa node,mem is not supported by this machine type
Use -numa node,memdev instead
Parameter -numa node,mem is deprecated, use -numa node,memdev instead
/home/virus/AMD/AMD/include/system/hostmem.h
Invalid initiator=%d, it should be less than %d
Invalid target=%d, it should be less than %d
Invalid initiator=%d, it isn't an initiator proximity domain
The target=%d should point to an existing node
Invalid option 'bandwidth' since the data type is latency
Duplicate configuration of the latency for initiator=%d and target=%d
Latency %lu between initiator=%d and target=%d should not differ from previously entered min or max values on more than %d
Invalid option 'latency' since the data type is bandwidth
Bandwidth %lu between initiator=%d and target=%d should be 1MB aligned
Duplicate configuration of the bandwidth for initiator=%d and target=%d
Bandwidth %lu between initiator=%d and target=%d should not differ from previously entered values on more than %d
Invalid node-id=%u, it should be less than %d
The latency and bandwidth information of node-id=%u should be provided before memory side cache attributes
Invalid level=%u, it should be larger than 0 and less than or equal to %d
node->associativity < HMAT_CACHE_ASSOCIATIVITY__MAX
node->policy < HMAT_CACHE_WRITE_POLICY__MAX
Duplicate configuration of the side cache for node-id=%u and level=%u
Cache level=%u shall be defined first
Invalid size=%lu, the size of level=%u should be larger than the size(%lu) of level=%u
Invalid size=%lu, the size of level=%u should be less than the size(%lu) of level=%u
NUMA is not supported by this machine-type
Parameter '%s' expects an integer between 0 and %d
Source/Destination NUMA node is missing. Please use '-numa node' option to declare it first.
NUMA distance (%u) is invalid, it shouldn't be less than %d.
Local distance of node %d should be %d.
Missing mandatory node-id property
Invalid node-id=%ld, NUMA node must be defined with -numa node,nodeid=ID before it's used with -numa cpu,node-id=ID
could not parse memory size '%s'
ms->numa_state->num_nodes == max_numa_nodeid
total memory for NUMA nodes (0x%lx) should equal RAM size (0x%lx)
'-machine memory-backend' and '-numa memdev' properties are mutually exclusive
The distance between node %d and %d is missing, at least one distance value between each nodes should be provided.
At least one asymmetrical pair of distances is given, please provide distances for both directions of all node pairs.
Device '%s' does not support hotplugging
Bus '%s' does not support hotplugging
Device '%s' can not be hotplugged on this machine
-global %s.%s=... conflicts with %s=%s
../hw/core/qdev-properties-system.c
%s=%s conflicts, and override is not implemented
Different aio context is not supported for new node
Property '%s.%s' can't find value '%s'
Drive '%s' is already in use because it has been automatically connected to another device (did you need 'if=none' in the drive options?)
Drive '%s' is already in use by another device
Property '%s.%s' can't take value '%s': 
queues of backend '%s'(%d) exceeds QEMU limitation(%d)
the 'slew' policy is only available for x86 machines
Invalid parameter type for '%s', expected int or str
start address of '%s' must be a hexadecimal integer
end address of '%s' must be a hexadecimal integer
/home/virus/AMD/AMD/include/qemu/range.h
range->lob <= range->upb || range->lob == range->upb + 1
type of '%s' must be a non-negative decimal integer
reserved region fields must be separated with ':'
'loadparm' can only contain up to 8 characters
invalid character in 'loadparm': '%c' (ASCII 0x%02x)
Endian mode, big/little/unspecified
IOThread virtqueue mapping list [{"iothread":"<id>", "vqs":[1,2,3,...]},...]
auto/low/medium/high (default medium)
UUID (aka GUID) or "auto" for random value (default)
off/auto/bar0/bar1/bar2/bar3/bar4/bar5
Address (bus:device.function) of the host device, example: 04:10.0
Slot and optional function number, example: 06.0 or 06
Reserved Region, example: 0xFEE00000:0xFEEFFFFF:0
Zero page detection (none/legacy/multifd)
Granule page size (4k/8k/16k/64k/host)
Migration mode (normal/cpr-reboot)
multifd_compression values (none/zlib/zstd/qpl/uadk/qatzip)
Floppy drive type (144/288/120/none/auto)
Logical CHS translation algorithm  (auto/none/lba/large/rechs)
Error handling policy (report/ignore/enospc/stop/auto)
A power of two between 512 B and 2 MiB
Policy for handling lost ticks (discard/delay/slew)
ID of an audiodev to use as a backend
ID of a netdev to use as a backend
Ethernet 6-byte MAC Address, example: 52:54:00:12:34:56
ID of a chardev to use as a backend
Node name or ID of a block device to use as a backend
/home/virus/AMD/AMD/include/hw/core/resetcontainer.h
/home/virus/AMD/AMD/include/hw/cpu/core.h
CXL 8 byte cache mem registers not implemented
../hw/cxl/cxl-component-utils.c
offset >= PCI_CFG_SPACE_SIZE && ((offset + length) < PCI_CFG_SPACE_EXP_SIZE)
Interleave ways: %d not supported
Encoded interleave ways: %d not supported
Interleave granularity: %lu invalid
/home/virus/AMD/AMD/include/hw/cxl/cxl_device.h
%s Unexpected 32-bit access to 0x%lx (WI)
%s Unexpected 64-bit access to 0x%lx (WI)
out_pl_len <= CXL_MAILBOX_MAX_PAYLOAD_SIZE
Scan Media Event Log is unsupported
/home/virus/AMD/AMD/include/hw/cxl/cxl.h
Command %04xh not implemented
Tunneled Command sent to non existent FM-LD
DCD_GET_DYNAMIC_CAPACITY_EXTENT_LIST
DCD_ADD_DYNAMIC_CAPACITY_RESPONSE
MEDIA_AND_POISON_GET_POISON_LIST
MEDIA_AND_POISON_INJECT_POISON
MEDIA_AND_POISON_GET_SCAN_MEDIA_CAPABILITIES
MEDIA_AND_POISON_GET_SCAN_MEDIA_RESULTS
Size of a CXL fixed memory window must be a multiple of 256MiB
Could not resolve CXLFM target %s
Set on/off to enable/disable CXL instantiation
CXL Fixed Memory Windows (array)
CXL host bridges present, but cxl=off
Failed to allocate CDAT header
Failed to allocate CDAT entry array
hdr->length == sizeof(CDATDsmas)
hdr->length == sizeof(CDATDslbis)
hdr->length == sizeof(CDATDsmscis)
hdr->length == sizeof(CDATDsis)
hdr->length == sizeof(CDATDsemts)
hdr->length >= sizeof(CDATSslbisHeader)
(hdr->length - sizeof(CDATSslbisHeader)) % sizeof(CDATSslbe) == 0
CDAT: Found checksum mismatch in %s
../hw/cxl/switch-mailbox-cci.c
/home/virus/AMD/AMD/include/hw/display/i2c-ddc.h
/home/virus/AMD/AMD/include/hw/i2c/i2c.h
ramfb device requires fw_cfg with DMA
../hw/display/ramfb-standalone.c
ram framebuffer standalone device
cirrus: linear bitblt is not implemented
cirrus: inport sr_index 0x%02x
cirrus: inport gr_index 0x%02x
cirrus: inport cr_index 0x%02x
%d@%zu.%06zu:vga_cirrus_read_io addr 0x%x, val 0x%x
vga_cirrus_read_io addr 0x%x, val 0x%x
cirrus: invalid DAC value 0x%x in 16bpp
cirrus: mmio read - address 0x%04x
%d@%zu.%06zu:vga_cirrus_write_blt offset 0x%x, val 0x%x
vga_cirrus_write_blt offset 0x%x, val 0x%x
%d@%zu.%06zu:vga_cirrus_bitblt_start rop=0x%02x mode=0x%02x modeext=0x%02x w=%d h=%d dpitch=%d spitch=%d daddr=0x%08x saddr=0x%08x writemask=0x%02x
vga_cirrus_bitblt_start rop=0x%02x mode=0x%02x modeext=0x%02x w=%d h=%d dpitch=%d spitch=%d daddr=0x%08x saddr=0x%08x writemask=0x%02x
cirrus: bitblt - pixel width is unknown
cirrus: bitblt - memory-to-memory copy requested
cirrus: src transparent without colorexpand must be 8bpp or 16bpp
s->cirrus_blt_srcpitch <= CIRRUS_BLTBUFSIZE
cirrus: bitblt (video to cpu) is not implemented
%d@%zu.%06zu:vga_cirrus_write_gr GR addr 0x%02x, val 0x%02x
vga_cirrus_write_gr GR addr 0x%02x, val 0x%02x
cirrus: outport gr_index 0x%02x, gr_value 0x%02x
cirrus: mmio write - addr 0x%04x val 0x%02x (ignored)
cirrus: mem_writeb 0x%016lx value 0x%02lx
%d@%zu.%06zu:vga_cirrus_write_io addr 0x%x, val 0x%x
vga_cirrus_write_io addr 0x%x, val 0x%x
cirrus: outport sr_index 0x%02x, sr_value 0x%02x
cirrus: outport cr_index 0x%02x, cr_value 0x%02x
Invalid cirrus_vga ram size '%u'
../hw/display/cirrus_vga_isa.c
fb size limit %zu exceeds %zu, corrected
frontend fb size %zu limited to %zu
can't handle frontend fb depth %d
invalid frontend width %d limited to %d
invalid frontend offset %d (max %zu)
invalid frontend height %d limited to %d
framebuffer %dx%dx%d offset %d stride %d
%s: oops: convert %d -> %d bpp?
ring mfn %lx, remote-port %d, local-port %d
raw pointer set without abs pointer
%d@%zu.%06zu:xenfb_input_connected %p abs %d
xenfb_input_connected %p abs %d
re-trigger connected (frontend bug)
update: resizing: %dx%d @ %d bpp%s
%d@%zu.%06zu:xenfb_mouse_event %p x %d y %d z %d bs 0x%x abs %d
xenfb_mouse_event %p x %d y %d z %d bs 0x%x abs %d
feature-update=%d, videoram=%d
Couldn't replace the framebuffer with anonymous memory errno=%d
%d@%zu.%06zu:xenfb_key_event %p scancode %d bs 0x%x
xenfb_key_event %p scancode %d bs 0x%x
%d@%zu.%06zu:vmware_scratch_read index %d, value 0x%x
vmware_scratch_read index %d, value 0x%x
%d@%zu.%06zu:vmware_palette_read index %d, value 0x%x
vmware_palette_read index %d, value 0x%x
%d@%zu.%06zu:vmware_value_read index %d, value 0x%x
vmware_value_read index %d, value 0x%x
%s: what are we supposed to return?
%d@%zu.%06zu:vmware_verify_rect_less_than_zero %s: %s was < 0 (%d)
vmware_verify_rect_less_than_zero %s: %s was < 0 (%d)
%d@%zu.%06zu:vmware_verify_rect_greater_than_bound %s: %s was > %d (%d)
vmware_verify_rect_greater_than_bound %s: %s was > %d (%d)
%d@%zu.%06zu:vmware_verify_rect_surface_bound_exceeded %s: %s > %d (%s: %d, %s: %d)
vmware_verify_rect_surface_bound_exceeded %s: %s > %d (%s: %d, %s: %d)
%d@%zu.%06zu:vmware_update_rect_delayed_flush display update FIFO full - forcing flush
vmware_update_rect_delayed_flush display update FIFO full - forcing flush
%s: unhandled bpp %d, using fallback cursor
%s: Unknown command 0x%02x in SVGA command FIFO
%d@%zu.%06zu:vmware_setmode %dx%d @ %d bpp
vmware_setmode %dx%d @ %d bpp
%d@%zu.%06zu:vmware_scratch_write index %d, value 0x%x
vmware_scratch_write index %d, value 0x%x
%d@%zu.%06zu:vmware_palette_write index %d, value 0x%x
vmware_palette_write index %d, value 0x%x
%d@%zu.%06zu:vmware_value_write index %d, value 0x%x
vmware_value_write index %d, value 0x%x
%s: Bad bits per pixel: %i bits
%s: what are we supposed to do with (%08x)?
bochs-display: video memory too small
bochs-display: video memory too big
%d@%zu.%06zu:vga_std_read_io addr 0x%x, val 0x%x
vga_std_read_io addr 0x%x, val 0x%x
%d@%zu.%06zu:vga_vbe_read index 0x%x, val 0x%x
vga_vbe_read index 0x%x, val 0x%x
%d@%zu.%06zu:vga_vbe_write index 0x%x, val 0x%x
vga_vbe_write index 0x%x, val 0x%x
%d@%zu.%06zu:vga_std_write_io addr 0x%x, val 0x%x
vga_std_write_io addr 0x%x, val 0x%x
Only one global VGA device can be used at a time
Use pixman for: 1: fill, 2: blit
Unknown ATI VGA model name, using default rage128p
Unknown ATI VGA device id, only 0x5046 and 0x5159 are supported
Too small video memory for device id
ati_mm_read: mm_index too small: %u
%d@%zu.%06zu:ati_mm_read %u 0x%lx %s -> 0x%lx
ati_mm_read %u 0x%lx %s -> 0x%lx
%d@%zu.%06zu:ati_mm_write %u 0x%lx %s <- 0x%lx
ati_mm_write %u 0x%lx %s <- 0x%lx
ati_mm_write: mm_index too small: %u
blt outside vram not implemented
Unimplemented ati_2d blt op %x
%s: cmd 0x%02lx not supported
/home/virus/AMD/AMD/include/hw/dma/i8257.h
%d@%zu.%06zu:i8257_unregistered_dma unregistered DMA channel used nchan=%d dma_pos=%d dma_len=%d
i8257_unregistered_dma unregistered DMA channel used nchan=%d dma_pos=%d dma_len=%d
dma: invalid channel read %#x
%d@%zu.%06zu:i2c_event %s(addr:0x%02x)
%d@%zu.%06zu:i2c_send send(addr:0x%02x) data:0x%02x
i2c_send send(addr:0x%02x) data:0x%02x
%d@%zu.%06zu:i2c_send_async send_async(addr:0x%02x) data:0x%02x
i2c_send_async send_async(addr:0x%02x) data:0x%02x
%d@%zu.%06zu:i2c_recv recv(addr:0x%02x) data:0x%02x
i2c_recv recv(addr:0x%02x) data:0x%02x
/home/virus/AMD/AMD/include/hw/i2c/smbus_slave.h
%s: smbus: error: Unexpected read in state %d
%s: smbus: error: Too many bytes sent
%s: smbus: error: Unexpected write in state %d
%s: smbus: error: Unexpected send start condition in state %d
%s: smbus: error: Read after write with no data
%s: smbus: error: Unexpected recv start condition in state %d
%s: smbus: error: Unexpected stop during receive
%s: smbus: error: Unexpected NACK in state %d
%d@%zu.%06zu:smbus_transaction addr=0x%02x prot=0x%02x
smbus_transaction addr=0x%02x prot=0x%02x
%d@%zu.%06zu:smbus_ioport_writeb [0x%04x] <- val=0x%02x
smbus_ioport_writeb [0x%04x] <- val=0x%02x
%d@%zu.%06zu:smbus_ioport_readb [0x%04x] -> val=0x%02x
smbus_ioport_readb [0x%04x] -> val=0x%02x
start_transaction_on_status_read
%d@%zu.%06zu:bitbang_i2c_state state %s -> %s
bitbang_i2c_state state %s -> %s
%d@%zu.%06zu:bitbang_i2c_data clk %u dat %u out %u -> %u
bitbang_i2c_data clk %u dat %u out %u -> %u
%d@%zu.%06zu:bitbang_i2c_addr Address 0x%02x
bitbang_i2c_addr Address 0x%02x
%d@%zu.%06zu:bitbang_i2c_send TX byte 0x%02x
bitbang_i2c_send TX byte 0x%02x
%d@%zu.%06zu:bitbang_i2c_recv RX byte 0x%02x
bitbang_i2c_recv RX byte 0x%02x
size == (1ULL << sz_log2) * nbanks
%d@%zu.%06zu:ahci_start_dma ahci(%p)[%d]: start dma
ahci_start_dma ahci(%p)[%d]: start dma
%d@%zu.%06zu:ahci_check_irq ahci(%p): check irq 0x%08x --> 0x%08x
ahci_check_irq ahci(%p): check irq 0x%08x --> 0x%08x
%d@%zu.%06zu:ahci_irq_raise ahci(%p): raise irq
ahci_irq_raise ahci(%p): raise irq
%d@%zu.%06zu:ahci_irq_lower ahci(%p): lower irq
ahci_irq_lower ahci(%p): lower irq
AHCI: Failed to start DMA engine: bad command list buffer address
%d@%zu.%06zu:ahci_unmap_clb_address_null ahci(%p)[%d]: Attempt to unmap NULL CLB address
ahci_unmap_clb_address_null ahci(%p)[%d]: Attempt to unmap NULL CLB address
AHCI: Failed to start FIS receive engine: bad FIS receive buffer address
%d@%zu.%06zu:ahci_unmap_fis_address_null ahci(%p)[%d]: Attempt to unmap NULL FIS address
ahci_unmap_fis_address_null ahci(%p)[%d]: Attempt to unmap NULL FIS address
%d@%zu.%06zu:ahci_populate_sglist ahci(%p)[%d]
ahci_populate_sglist ahci(%p)[%d]
%d@%zu.%06zu:ahci_populate_sglist_no_prdtl ahci(%p)[%d]: no sg list given by guest: 0x%04x
ahci_populate_sglist_no_prdtl ahci(%p)[%d]: no sg list given by guest: 0x%04x
%d@%zu.%06zu:ahci_populate_sglist_no_map ahci(%p)[%d]: DMA mapping failed
ahci_populate_sglist_no_map ahci(%p)[%d]: DMA mapping failed
%d@%zu.%06zu:ahci_populate_sglist_short_map ahci(%p)[%d]: mapped less than expected
ahci_populate_sglist_short_map ahci(%p)[%d]: mapped less than expected
%d@%zu.%06zu:ahci_populate_sglist_bad_offset ahci(%p)[%d]: Incorrect offset! off_idx: %d, off_pos: %ld
ahci_populate_sglist_bad_offset ahci(%p)[%d]: Incorrect offset! off_idx: %d, off_pos: %ld
%d@%zu.%06zu:ahci_dma_prepare_buf_fail ahci(%p)[%d]: sglist population failed
ahci_dma_prepare_buf_fail ahci(%p)[%d]: sglist population failed
%d@%zu.%06zu:ahci_dma_prepare_buf ahci(%p)[%d]: prepare buf limit=%d prepared=%d
ahci_dma_prepare_buf ahci(%p)[%d]: prepare buf limit=%d prepared=%d
%d@%zu.%06zu:execute_ncq_command_read ahci(%p)[%d][tag:%d]: NCQ reading %d sectors from LBA %ld
execute_ncq_command_read ahci(%p)[%d][tag:%d]: NCQ reading %d sectors from LBA %ld
%d@%zu.%06zu:execute_ncq_command_write ahci(%p)[%d][tag:%d]: NCQ writing %d sectors to LBA %ld
execute_ncq_command_write ahci(%p)[%d][tag:%d]: NCQ writing %d sectors to LBA %ld
%d@%zu.%06zu:execute_ncq_command_unsup ahci(%p)[%d][tag:%d]: error: unsupported NCQ command (0x%02x) received
execute_ncq_command_unsup ahci(%p)[%d][tag:%d]: error: unsupported NCQ command (0x%02x) received
%d@%zu.%06zu:ahci_dma_rw_buf ahci(%p)[%d] len=0x%x
ahci_dma_rw_buf ahci(%p)[%d] len=0x%x
%d@%zu.%06zu:ahci_trigger_irq ahci(%p)[%d]: trigger irq +%s (0x%08x); irqstat: 0x%08x --> 0x%08x; effective: 0x%08x
ahci_trigger_irq ahci(%p)[%d]: trigger irq +%s (0x%08x); irqstat: 0x%08x --> 0x%08x; effective: 0x%08x
%d@%zu.%06zu:ahci_pio_transfer ahci(%p)[%d]: %sing %d bytes on %s w/%s sglist
ahci_pio_transfer ahci(%p)[%d]: %sing %d bytes on %s w/%s sglist
%d@%zu.%06zu:ahci_set_signature ahci(%p)[%d]: set signature sector:0x%02x nsector:0x%02x lcyl:0x%02x hcyl:0x%02x (cumulatively: 0x%08x)
ahci_set_signature ahci(%p)[%d]: set signature sector:0x%02x nsector:0x%02x lcyl:0x%02x hcyl:0x%02x (cumulatively: 0x%08x)
%d@%zu.%06zu:ahci_reset_port ahci(%p)[%d]: reset port
ahci_reset_port ahci(%p)[%d]: reset port
%d@%zu.%06zu:ncq_finish ahci(%p)[%d][tag:%d]: NCQ transfer finished
ncq_finish ahci(%p)[%d][tag:%d]: NCQ transfer finished
%d@%zu.%06zu:ahci_cmd_done ahci(%p)[%d]: cmd done
ahci_cmd_done ahci(%p)[%d]: cmd done
%d@%zu.%06zu:handle_cmd_busy ahci(%p)[%d]: engine busy
handle_cmd_busy ahci(%p)[%d]: engine busy
%d@%zu.%06zu:handle_cmd_nolist ahci(%p)[%d]: handle_cmd called without s->dev[port].lst
handle_cmd_nolist ahci(%p)[%d]: handle_cmd called without s->dev[port].lst
%d@%zu.%06zu:handle_cmd_badport ahci(%p)[%d]: guest accessed unused port
handle_cmd_badport ahci(%p)[%d]: guest accessed unused port
%d@%zu.%06zu:handle_cmd_badfis ahci(%p)[%d]: guest provided an invalid cmd FIS
handle_cmd_badfis ahci(%p)[%d]: guest provided an invalid cmd FIS
%d@%zu.%06zu:handle_cmd_badmap ahci(%p)[%d]: dma_memory_map failed, 0x%02lx != 0x80
handle_cmd_badmap ahci(%p)[%d]: dma_memory_map failed, 0x%02lx != 0x80
%d@%zu.%06zu:handle_cmd_fis_dump ahci(%p)[%d]: %s
handle_cmd_fis_dump ahci(%p)[%d]: %s
%d@%zu.%06zu:handle_reg_h2d_fis_pmp ahci(%p)[%d]: Port Multiplier not supported, FIS: 0x%02x-%02x-%02x
handle_reg_h2d_fis_pmp ahci(%p)[%d]: Port Multiplier not supported, FIS: 0x%02x-%02x-%02x
%d@%zu.%06zu:handle_reg_h2d_fis_res ahci(%p)[%d]: Reserved flags set in H2D Register FIS, FIS: 0x%02x-%02x-%02x
handle_reg_h2d_fis_res ahci(%p)[%d]: Reserved flags set in H2D Register FIS, FIS: 0x%02x-%02x-%02x
%d@%zu.%06zu:process_ncq_command_mismatch ahci(%p)[%d][tag:%d]: Warning: NCQ slot (%d) did not match the given tag
process_ncq_command_mismatch ahci(%p)[%d][tag:%d]: Warning: NCQ slot (%d) did not match the given tag
%d@%zu.%06zu:process_ncq_command_aux ahci(%p)[%d][tag:%d]: Warn: Attempt to use NCQ auxiliary fields
process_ncq_command_aux ahci(%p)[%d][tag:%d]: Warn: Attempt to use NCQ auxiliary fields
%d@%zu.%06zu:process_ncq_command_prioicc ahci(%p)[%d][tag:%d]: Warn: Unsupported attempt to use PRIO/ICC fields
process_ncq_command_prioicc ahci(%p)[%d][tag:%d]: Warn: Unsupported attempt to use PRIO/ICC fields
%d@%zu.%06zu:process_ncq_command_fua ahci(%p)[%d][tag:%d]: Warn: Unsupported attempt to use Force Unit Access
process_ncq_command_fua ahci(%p)[%d][tag:%d]: Warn: Unsupported attempt to use Force Unit Access
%d@%zu.%06zu:process_ncq_command_rarc ahci(%p)[%d][tag:%d]: Warn: Unsupported attempt to use Rebuild Assist
process_ncq_command_rarc ahci(%p)[%d][tag:%d]: Warn: Unsupported attempt to use Rebuild Assist
ahci: PRDT length for NCQ command (0x%lx) is smaller than the requested size (0x%zx)
%d@%zu.%06zu:process_ncq_command_large ahci(%p)[%d][tag:%d]: Warn: PRDTL (0x%zx) does not match requested size (0x%zx)
process_ncq_command_large ahci(%p)[%d][tag:%d]: Warn: PRDTL (0x%zx) does not match requested size (0x%zx)
%d@%zu.%06zu:process_ncq_command ahci(%p)[%d][tag:%d]: NCQ op 0x%02x on sectors [%ld,%ld]
process_ncq_command ahci(%p)[%d][tag:%d]: NCQ op 0x%02x on sectors [%ld,%ld]
%d@%zu.%06zu:handle_reg_h2d_fis_dump ahci(%p)[%d]: %s
handle_reg_h2d_fis_dump ahci(%p)[%d]: %s
%d@%zu.%06zu:handle_cmd_unhandled_fis ahci(%p)[%d]: unhandled FIS type. cmd_fis: 0x%02x-%02x-%02x
handle_cmd_unhandled_fis ahci(%p)[%d]: unhandled FIS type. cmd_fis: 0x%02x-%02x-%02x
AHCI: DMA engine should be off, but status bit indicates it is still running.
AHCI: FIS RX engine should be off, but status bit indicates it is still running.
%d@%zu.%06zu:ahci_mem_read_32_host_default ahci(%p): unimplemented mem read [reg:%s] @ 0x%lx
ahci_mem_read_32_host_default ahci(%p): unimplemented mem read [reg:%s] @ 0x%lx
%d@%zu.%06zu:ahci_mem_read_32_host ahci(%p): mem read [reg:%s] @ 0x%lx: 0x%08x
ahci_mem_read_32_host ahci(%p): mem read [reg:%s] @ 0x%lx: 0x%08x
%d@%zu.%06zu:ahci_port_read_default ahci(%p)[%d]: unimplemented port read [reg:%s] @ 0x%x
ahci_port_read_default ahci(%p)[%d]: unimplemented port read [reg:%s] @ 0x%x
%d@%zu.%06zu:ahci_port_read ahci(%p)[%d]: port read [reg:%s] @ 0x%x: 0x%08x
ahci_port_read ahci(%p)[%d]: port read [reg:%s] @ 0x%x: 0x%08x
%d@%zu.%06zu:ahci_mem_read_32_default ahci(%p): mem read @ 0x%lx: 0x%08x
ahci_mem_read_32_default ahci(%p): mem read @ 0x%lx: 0x%08x
%d@%zu.%06zu:ahci_mem_read_32 ahci(%p): mem read @ 0x%lx: 0x%08x
ahci_mem_read_32 ahci(%p): mem read @ 0x%lx: 0x%08x
%d@%zu.%06zu:ahci_mem_read ahci(%p): read%u @ 0x%lx: 0x%016lx
ahci_mem_read ahci(%p): read%u @ 0x%lx: 0x%016lx
%d@%zu.%06zu:ahci_reset ahci(%p): HBA reset
ahci_reset ahci(%p): HBA reset
%d@%zu.%06zu:ahci_mem_write ahci(%p): write%u @ 0x%lx: 0x%016lx
ahci_mem_write ahci(%p): write%u @ 0x%lx: 0x%016lx
ahci: Mis-aligned write to addr 0x%03lX
Attempted write to unimplemented register: AHCI host register %s, offset 0x%lx: 0x%lx
%d@%zu.%06zu:ahci_mem_write_host_unimpl ahci(%p) unimplemented write%u [reg:%s] @ 0x%lx
ahci_mem_write_host_unimpl ahci(%p) unimplemented write%u [reg:%s] @ 0x%lx
%d@%zu.%06zu:ahci_mem_write_host ahci(%p) write%u [reg:%s] @ 0x%lx: 0x%016lx
ahci_mem_write_host ahci(%p) write%u [reg:%s] @ 0x%lx: 0x%016lx
%d@%zu.%06zu:ahci_port_write ahci(%p)[%d]: port write [reg:%s] @ 0x%x: 0x%08x
ahci_port_write ahci(%p)[%d]: port write [reg:%s] @ 0x%x: 0x%08x
%d@%zu.%06zu:ahci_port_write_unimpl ahci(%p)[%d]: unimplemented port write [reg:%s] @ 0x%x: 0x%08x
ahci_port_write_unimpl ahci(%p)[%d]: unimplemented port write [reg:%s] @ 0x%x: 0x%08x
Attempted write to unimplemented register: AHCI port %d register %s, offset 0x%x: 0x%x
Attempted write to unimplemented register: AHCI global register at offset 0x%lx: 0x%lx
%d@%zu.%06zu:ahci_mem_write_unimpl ahci(%p): write%u to unknown register 0x%lx: 0x%016lx
ahci_mem_write_unimpl ahci(%p): write%u to unknown register 0x%lx: 0x%016lx
/home/virus/AMD/AMD/include/hw/ide/ahci-pci.h
/home/virus/AMD/AMD/include/hw/ide/ide-bus.h
/home/virus/AMD/AMD/include/hw/ide/ide-dev.h
req->qiov.size == req->original_qiov->size
/home/virus/AMD/AMD/include/qemu/iov.h
qiov->nalloc == -1 && qiov->iov == &qiov->local_iov
%d@%zu.%06zu:ide_status_read IDE PIO rd @ 0x%x (Alt Status); val 0x%02x; bus %p; IDEState %p
ide_status_read IDE PIO rd @ 0x%x (Alt Status); val 0x%02x; bus %p; IDEState %p
%d@%zu.%06zu:ide_ctrl_write IDE PIO wr @ 0x%x (Device Control); val 0x%02x; bus %p
ide_ctrl_write IDE PIO wr @ 0x%x (Device Control); val 0x%02x; bus %p
%s: invalid end_transfer_func for DRQ_STAT
%d@%zu.%06zu:ide_data_writew IDE PIO wr @ 0x%x (Data: Word); val 0x%04x; bus %p; IDEState %p
ide_data_writew IDE PIO wr @ 0x%x (Data: Word); val 0x%04x; bus %p; IDEState %p
%d@%zu.%06zu:ide_reset IDEstate %p
%d@%zu.%06zu:ide_data_readl IDE PIO rd @ 0x%x (Data: Long); val 0x%08x; bus %p; IDEState %p
ide_data_readl IDE PIO rd @ 0x%x (Data: Long); val 0x%08x; bus %p; IDEState %p
%d@%zu.%06zu:ide_data_writel IDE PIO wr @ 0x%x (Data: Long); val 0x%08x; bus %p; IDEState %p
ide_data_writel IDE PIO wr @ 0x%x (Data: Long); val 0x%08x; bus %p; IDEState %p
%d@%zu.%06zu:ide_data_readw IDE PIO rd @ 0x%x (Data: Word); val 0x%04x; bus %p; IDEState %p
ide_data_readw IDE PIO rd @ 0x%x (Data: Word); val 0x%04x; bus %p; IDEState %p
%d@%zu.%06zu:ide_ioport_read IDE PIO rd @ 0x%x (%s); val 0x%02x; bus %p IDEState %p
ide_ioport_read IDE PIO rd @ 0x%x (%s); val 0x%02x; bus %p IDEState %p
%d@%zu.%06zu:ide_sector_write sector=%ld nsectors=%d
ide_sector_write sector=%ld nsectors=%d
%d@%zu.%06zu:ide_sector_read sector=%ld nsectors=%d
ide_sector_read sector=%ld nsectors=%d
%d@%zu.%06zu:ide_cancel_dma_sync_buffered invoking cb %p of buffered request %p with -ECANCELED
ide_cancel_dma_sync_buffered invoking cb %p of buffered request %p with -ECANCELED
%d@%zu.%06zu:ide_cancel_dma_sync_remaining draining all remaining requests
ide_cancel_dma_sync_remaining draining all remaining requests
prep_size >= 0 && prep_size <= n * 512
%d@%zu.%06zu:ide_dma_cb IDEState %p; sector_num=%ld n=%d cmd=%s
ide_dma_cb IDEState %p; sector_num=%ld n=%d cmd=%s
s->end_transfer_func == ide_atapi_cmd
%d@%zu.%06zu:ide_bus_exec_cmd IDE exec cmd: bus %p; state %p; cmd 0x%02x
ide_bus_exec_cmd IDE exec cmd: bus %p; state %p; cmd 0x%02x
!!s->error == !!(s->status & ERR_STAT)
%d@%zu.%06zu:ide_ioport_write IDE PIO wr @ 0x%x (%s); val 0x%02x; bus %p IDEState %p
ide_ioport_write IDE PIO wr @ 0x%x (%s); val 0x%02x; bus %p IDEState %p
%d@%zu.%06zu:ide_bus_reset_aio aio_cancel
Device needs media, but drive is empty
%d@%zu.%06zu:ide_atapi_cmd_read_dma_cb_aio IDEState: %p; aio read: lba=%d n=%d
ide_atapi_cmd_read_dma_cb_aio IDEState: %p; aio read: lba=%d n=%d
%d@%zu.%06zu:ide_atapi_cmd_error IDEState: %p; sense=0x%x asc=0x%x
ide_atapi_cmd_error IDEState: %p; sense=0x%x asc=0x%x
%d@%zu.%06zu:ide_atapi_cmd_reply_end IDEState %p; reply: tx_size=%d elem_tx_size=%d index=%d
ide_atapi_cmd_reply_end IDEState %p; reply: tx_size=%d elem_tx_size=%d index=%d
%d@%zu.%06zu:cd_read_sector lba=%d
%d@%zu.%06zu:cd_read_sector_sync lba=%d
%d@%zu.%06zu:ide_atapi_cmd_reply_end_bcl IDEState: %p; byte_count_limit=%d
ide_atapi_cmd_reply_end_bcl IDEState: %p; byte_count_limit=%d
%d@%zu.%06zu:ide_atapi_cmd_reply_end_new IDEState: %p; new transfer started, status=0x%x
ide_atapi_cmd_reply_end_new IDEState: %p; new transfer started, status=0x%x
size <= s->io_buffer_total_len
s->io_buffer_index <= s->io_buffer_total_len
%d@%zu.%06zu:ide_atapi_cmd_reply_end_eot IDEState: %p; end of transfer, status=0x%x
ide_atapi_cmd_reply_end_eot IDEState: %p; end of transfer, status=0x%x
%d@%zu.%06zu:ide_atapi_cmd_read IDEState: %p; read %s: LBA=%d nb_sectors=%d
ide_atapi_cmd_read IDEState: %p; read %s: LBA=%d nb_sectors=%d
0 <= lba && lba < (s->nb_sectors >> 2)
%d@%zu.%06zu:cd_read_sector_cb lba=%d ret=%d
cd_read_sector_cb lba=%d ret=%d
%d@%zu.%06zu:ide_atapi_cmd IDEState: %p; cmd: 0x%02x
ide_atapi_cmd IDEState: %p; cmd: 0x%02x
%d@%zu.%06zu:ide_atapi_cmd_packet IDEState: %p; limit=0x%x packet: %s
ide_atapi_cmd_packet IDEState: %p; limit=0x%x packet: %s
%d@%zu.%06zu:ide_atapi_cmd_check_status IDEState: %p
ide_atapi_cmd_check_status IDEState: %p
Can't create IDE unit %d, bus supports only %d units
discard_granularity must be 512 for ide
logical_block_size must be 512 for IDE
/home/virus/AMD/AMD/include/hw/ide/isa.h
%d@%zu.%06zu:bmdma_addr_write data: 0x%016lx
bmdma_addr_write data: 0x%016lx
%d@%zu.%06zu:bmdma_addr_read data: 0x%016lx
bmdma_addr_read data: 0x%016lx
bmdma->bus->retry_unit != (uint8_t)-1
/home/virus/AMD/AMD/include/hw/ide/pci.h
%d@%zu.%06zu:bmdma_cmd_writeb val: 0x%08x
%d@%zu.%06zu:bmdma_write bmdma: writeb 0x%lx : 0x%02lx
bmdma_write bmdma: writeb 0x%lx : 0x%02lx
%d@%zu.%06zu:bmdma_read bmdma: readb 0x%lx : 0x%02x
bmdma_read bmdma: readb 0x%lx : 0x%02x
%d@%zu.%06zu:hid_kbd_queue_full queue full
hid_kbd_queue_full queue full
%d@%zu.%06zu:hid_kbd_queue_empty queue empty
hid_kbd_queue_empty queue empty
/home/virus/AMD/AMD/include/hw/input/i8042.h
/home/virus/AMD/AMD/include/hw/input/ps2.h
%d@%zu.%06zu:pckbd_kbd_read_data 0x%02x
%d@%zu.%06zu:pckbd_kbd_read_status 0x%02x
Maximum value for "kbd-irq" is: %u
Maximum value for "mouse-irq" is: %u
i8042: can't enable kbd-throttle without extended-state, disabling kbd-throttle
%d@%zu.%06zu:pckbd_kbd_write_data 0x%02lx
%d@%zu.%06zu:pckbd_outport_write 0x%02x
%d@%zu.%06zu:pckbd_kbd_write_command 0x%02lx
pckbd_kbd_write_command 0x%02lx
unsupported keyboard cmd=0x%02lx
%d@%zu.%06zu:ps2_mouse_reset %p
%d@%zu.%06zu:ps2_kbd_reset %p
%d@%zu.%06zu:ps2_reset_keyboard %p
%d@%zu.%06zu:ps2_set_ledstate %p ledstate %d
ps2_set_ledstate %p ledstate %d
%d@%zu.%06zu:ps2_put_keycode %p keycode 0x%02x
ps2_put_keycode %p keycode 0x%02x
evt->type == INPUT_EVENT_KIND_KEY
%d@%zu.%06zu:ps2_keyboard_event %p qcode %d down %d modifier 0x%x modifiers 0x%x set %d xlate %d
ps2_keyboard_event %p qcode %d down %d modifier 0x%x modifiers 0x%x set %d xlate %d
ps2: ignoring key with qcode %d
%d@%zu.%06zu:ps2_mouse_send_packet %p x %d y %d z %d bs 0x%x
ps2_mouse_send_packet %p x %d y %d z %d bs 0x%x
%d@%zu.%06zu:ps2_read_data %p
%d@%zu.%06zu:ps2_write_keyboard %p val %d
%d@%zu.%06zu:ps2_keyboard_set_translation %p mode %d
ps2_keyboard_set_translation %p mode %d
%d@%zu.%06zu:ps2_mouse_fake_event %p
%d@%zu.%06zu:ps2_write_mouse %p val %d
/home/virus/AMD/AMD/include/hw/virtio/virtio-input.h
%d@%zu.%06zu:virtio_input_queue_full queue full
virtio_input_queue_full queue full
vinput->cfg_size <= sizeof(virtio_input_config)
virtio_input_host_handle_status: gettimeofday
virtio_input_host_handle_status: write
../hw/input/virtio-input-host.c
%s: failed to get exclusive access
/home/virus/AMD/AMD/include/hw/isa/i8259_internal.h
pic%d: irr=%02x imr=%02x isr=%02x hprio=%d irq_base=%02x rr_sel=%d elcr=%02x fnm=%d
%d@%zu.%06zu:pic_update_irq master %d imr %u irr %u padd %u
pic_update_irq master %d imr %u irr %u padd %u
%d@%zu.%06zu:pic_ioport_write master %d addr 0x%lx val 0x%lx
pic_ioport_write master %d addr 0x%lx val 0x%lx
%d@%zu.%06zu:pic_set_irq master %d irq %d level %d
pic_set_irq master %d irq %d level %d
%d@%zu.%06zu:pic_ioport_read master %d addr 0x%lx val 0x%x
pic_ioport_read master %d addr 0x%lx val 0x%x
%d@%zu.%06zu:pic_interrupt irq %d intno %d
pic_interrupt irq %d intno %d
/home/virus/AMD/AMD/hw/intc/ioapic_internal.h
ioapic0: ver=0x%x id=0x%02x sel=0x%02x
  pin %-2u 0x%016lx dest=%lx vec=%-3lu %s %-5s %-6s %-6s %s
%d@%zu.%06zu:kvm_report_irq_delivered coalescing %d
kvm_report_irq_delivered coalescing %d
%d@%zu.%06zu:kvm_reset_irq_delivered old coalescing %d
kvm_reset_irq_delivered old coalescing %d
%d@%zu.%06zu:kvm_get_irq_delivered returning coalescing %d
kvm_get_irq_delivered returning coalescing %d
ip->slot >= 0 && ip->slot < N_MODULES
TEWS TPCI200 IndustryPack carrier
ipmi:kcs: vmstate transfer received bad out values: %d %d
ipmi:kcs: vmstate transfer received bad in value: %d
ipmi:bt: vmstate transfer received bad out values: %d %d
ipmi:bt: vmstate transfer received bad in value: %d
IPMI external bmc requires chardev attribute
IPMI (%s): msg escape not ended
IPMI (%s): msg checksum failure
IPMI KCS: Got command when not finished with the previous command
IPMI device requires a bmc attribute to be set
%d@%zu.%06zu:apm_io_write write addr=0x%x val=0x%02x
apm_io_write write addr=0x%x val=0x%02x
%d@%zu.%06zu:apm_io_read read addr=0x%x val=0x%02x
apm_io_read read addr=0x%x val=0x%02x
!dev || ISA_BUS(qdev_get_parent_bus(DEVICE(dev))) == isabus
/home/virus/AMD/AMD/include/hw/southbridge/piix.h
Unexpected memory region mapped into device memory region.
Memory devices use more memory slots than indicated as required.
/home/virus/AMD/AMD/include/hw/mem/memory-device.h
the configuration is not prepared for memory devices (e.g., for memory hotplug), consider specifying the maxmem option
hypervisor has not enough free memory slots left
a used vhost backend has not enough free memory slots left
not enough space, currently 0x%lx in use of total space for memory devices 0x%lx
backend memory size must be multiple of 0x%lx
the alignment (0x%lx) exceeds the expected maximum alignment, memory will get fragmented and not all 'maxmem' might be usable for memory devices.
address must be aligned to 0x%lx bytes
can't add memory device [0x%lx:0x%lx], usable range for memory devices [0x%lx:0x%lx]
can't add memory device, device too big
address range conflicts with memory device id='%s'
%d@%zu.%06zu:memory_device_pre_plug id=%s addr=0x%lx
memory_device_pre_plug id=%s addr=0x%lx
could not find position in guest address space for memory device - memory fragmented due to alignments
%d@%zu.%06zu:memory_device_plug id=%s addr=0x%lx
memory_device_plug id=%s addr=0x%lx
%d@%zu.%06zu:memory_device_unplug id=%s addr=0x%lx
memory_device_unplug id=%s addr=0x%lx
/home/virus/AMD/AMD/include/hw/mem/pc-dimm.h
'DIMM property node has value %u' which exceeds the number of numa nodes: %d
invalid slot number %d, valid range is [0-%lu]
no slots where allocated, please specify the 'slots' option
invalid slot# %d, should be less than %d
%d@%zu.%06zu:mhp_pc_dimm_assigned_slot %d
the size of memdev %s (0x%lx) is too small to contain nvdimm label (0x%lx) and aligned PMEM (0x%lx)
'unarmed' property must be 'on' since memdev %s is read-only
Property '%s.%s' (0x%lx) is required at least 0x%lx
!is_write || !nvdimm->readonly
(nvdimm->label_size >= size + offset) && (offset + size > offset)
Property '%s.%s' has invalid value
offset < CXL2_COMPONENT_CM_REGION_SIZE
offset + size <= memory_region_size(mr)
at least one memdev property must be set
[memdev] cannot be used with new [persistent-memdev] property
lsa property must be set for persistent devices
volatile memdev must have backing device
persistent memdev must have backing device
dynamic capacity must have a backing device
backend size is not multiple of region len: 0x%lx
DC region size is unaligned to 0x%lx
DC region base not aligned to 0x%lx
Unable to resolve CXL type 3 device
No dynamic capacity support from the device
extent with 0 length is not allowed
dpa or len is not aligned to region block size
extent range is beyond the region end
duplicate or overlapped extents are detected
cannot release extent with pending DPA range
cannot release extent with non-existing DPA range
cannot add DPA already accessible to the same LD
cannot add DPA again while still pending
Poison injection must be in multiples of 64 bytes
Poison start address must be 64 byte aligned
Path does not point to a CXL type 3 device
Overlap with existing poisoned region not supported
Selection policy not supported
Forced removal not supported yet
Using AppleSMC with invalid key
EDU: DMA range 0x%016lx-0x%016lx out of bounds (0x%016lx-0x%016lx)!
EDU: clamping DMA 0x%016lx to 0x%016lx!
/home/virus/AMD/AMD/include/hw/misc/vmcoreinfo.h
%s device requires fw_cfg with DMA
posn >= 0 && posn < s->nb_peers
'peer' devices are not migratable
s->msg_buffered_bytes < sizeof(s->msg_buf)
kvm_irqchip_add_msi_route failed
ivshmem: vector %d route does not exist
remove_irqfd_notifier_gsi failed
Failed to munmap shared memory %s
server sent invalid message %ld
server sent unexpected shared memory message
can't determine size of shared memory sent by server
Too many eventfd received, device has %d vectors
size >= 0 && s->msg_buffered_bytes + size <= sizeof(s->msg_buf)
server sent version %ld, expecting %d
server sent invalid version message
server sent invalid ID message
master must connect to the server before any peers
Failed to initialize interrupts: 
Migration is disabled when using feature 'peer mode' in device 'ivshmem'
ivshmem: msix_set_vector_notifiers failed
%d@%zu.%06zu:ivshmem_flat_new_peer New peer ID: %d
ivshmem_flat_new_peer New peer ID: %d
%d@%zu.%06zu:ivshmem_flat_add_vector_failure Failed to add vector %u (fd = %u) to peer ID %u, maximum number of vectors reached
ivshmem_flat_add_vector_failure Failed to add vector %u (fd = %u) to peer ID %u, maximum number of vectors reached
%d@%zu.%06zu:ivshmem_flat_add_vector_success Successful addition of vector %u (fd = %u) to peer ID %u
ivshmem_flat_add_vector_success Successful addition of vector %u (fd = %u) to peer ID %u
%d@%zu.%06zu:ivshmem_flat_irq_handler Caught interrupt request: vector %d
ivshmem_flat_irq_handler Caught interrupt request: vector %d
%d@%zu.%06zu:ivshmem_flat_write_mmr Write access at offset %lu
ivshmem_flat_write_mmr Write access at offset %lu
%d@%zu.%06zu:ivshmem_flat_interrupt_peer Interrupting peer ID %u, vector %u...
ivshmem_flat_interrupt_peer Interrupting peer ID %u, vector %u...
%d@%zu.%06zu:ivshmem_flat_interrupt_invalid_peer Can't interrupt non-existing peer %u
ivshmem_flat_interrupt_invalid_peer Can't interrupt non-existing peer %u
%d@%zu.%06zu:ivshmem_flat_read_write_mmr_invalid No ivshmem register mapped at offset %lu
ivshmem_flat_read_write_mmr_invalid No ivshmem register mapped at offset %lu
/home/virus/AMD/AMD/include/hw/misc/ivshmem-flat.h
%d@%zu.%06zu:ivshmem_flat_read_mmr Read access at offset %lu
ivshmem_flat_read_mmr Read access at offset %lu
%d@%zu.%06zu:ivshmem_flat_read_mmr_doorbell DOORBELL register is write-only!
ivshmem_flat_read_mmr_doorbell DOORBELL register is write-only!
ivshmem server socket not specified or incorret. Can't create device.
%d@%zu.%06zu:ivshmem_flat_proto_ver_own_id Protocol Version = 0x%lx, Own Peer ID = %u
ivshmem_flat_proto_ver_own_id Protocol Version = 0x%lx, Own Peer ID = %u
Could not receive valid shmem fd. Can't create device!
Could not determine shmem fd size. Can't create device!
%d@%zu.%06zu:ivshmem_flat_shmem_size Shmem fd (%d) total size is %lu byte(s)
ivshmem_flat_shmem_size Shmem fd (%d) total size is %lu byte(s)
Can't map shmem fd: shmem size different from device size!
%d@%zu.%06zu:i2c_echo_send %s: send 0x%02x
i2c_echo_send %s: send 0x%02x
%d@%zu.%06zu:i2c_echo_recv %s: recv 0x%02x
i2c_echo_recv %s: recv 0x%02x
%d@%zu.%06zu:i2c_echo_event %s: %s
%d@%zu.%06zu:xen_netdev_create vif%u
realization of net device %lu failed: 
vif%u: FIXME: extra info flag
%d@%zu.%06zu:xen_netdev_tx vif%u ref %u off %u len %u flags 0x%x%s%s%s%s
xen_netdev_tx vif%u ref %u off %u len %u flags 0x%x%s%s%s%s
vif%u: tx gref dereference failed (%d)
%d@%zu.%06zu:xen_netdev_rx vif%u idx %d status %d flags 0x%x
xen_netdev_rx vif%u idx %d status %d flags 0x%x
vif%u: packet too big (%lu > %ld)
vif%u: rx gref dereference failed (%d)
%d@%zu.%06zu:xen_netdev_destroy vif%u
/local/domain/%u/device/vif/%u
cannot find device index for netdev device
%d@%zu.%06zu:xen_netdev_disconnect vif%u
%d@%zu.%06zu:xen_netdev_unrealize vif%u
%d@%zu.%06zu:xen_netdev_realize vif%u info '%s' peer '%s'
xen_netdev_realize vif%u info '%s' peer '%s'
%d@%zu.%06zu:xen_netdev_frontend_changed vif%s state %d
xen_netdev_frontend_changed vif%s state %d
frontend doesn't support rx-copy
%d@%zu.%06zu:xen_netdev_connect vif%u tx %u rx %u port %u
xen_netdev_connect vif%u tx %u rx %u port %u
%d@%zu.%06zu:ne2000_ioport_read io read addr=0x%02lx val=0x%02lx
ne2000_ioport_read io read addr=0x%02lx val=0x%02lx
%d@%zu.%06zu:ne2000_read read addr=0x%lx val=0x%lx
ne2000_read read addr=0x%lx val=0x%lx
%d@%zu.%06zu:ne2000_write write addr=0x%lx val=0x%lx
ne2000_write write addr=0x%lx val=0x%lx
%d@%zu.%06zu:ne2000_ioport_write io write addr=0x%02lx val=0x%02lx
ne2000_ioport_write io write addr=0x%02lx val=0x%02lx
!((uintptr_t)&s->mem[addr] & 3)
!((uintptr_t)&s->mem[addr] & 1)
eepro100: feature is missing in this emulation: not writable
eepro100: feature is missing in this emulation: not implemented
eepro100: feature is missing in this emulation: CmdTx: NC = 0
eepro100: feature is missing in this emulation: undefined command
eepro100: feature is missing in this emulation: Undefined SU command
eepro100: feature is missing in this emulation: CU static resume
eepro100: feature is missing in this emulation: Undefined CU command
eepro100: feature is missing in this emulation: Receive CRC Transfer
eepro100: feature is missing in this emulation: unknown port selection
eepro100: feature is missing in this emulation: unknown byte write
eepro100: feature is missing in this emulation: unknown word write
eepro100: feature is missing in this emulation: unknown longword write
eepro100: feature is missing in this emulation: unknown byte read
eepro100: feature is missing in this emulation: unknown word read
eepro100: feature is missing in this emulation: unknown longword read
statistics.tx_single_collisions
statistics.tx_multiple_collisions
statistics.tx_total_collisions
statistics.rx_alignment_errors
statistics.rx_short_frame_errors
%d@%zu.%06zu:pcnet_aprom_writeb opaque=%p addr=0x%08x val=0x%02x
pcnet_aprom_writeb opaque=%p addr=0x%08x val=0x%02x
%d@%zu.%06zu:pcnet_ioport_write opaque=%p addr=0x%lx data=0x%lx size=%d
pcnet_ioport_write opaque=%p addr=0x%lx data=0x%lx size=%d
%d@%zu.%06zu:pcnet_ioport_read opaque=%p addr=0x%lx size=%d
pcnet_ioport_read opaque=%p addr=0x%lx size=%d
%d@%zu.%06zu:pcnet_aprom_readb opaque=%p addr=0x%08x val=0x%02x
pcnet_aprom_readb opaque=%p addr=0x%08x val=0x%02x
%d@%zu.%06zu:pcnet_user_int s=%p
%d@%zu.%06zu:pcnet_isr_change s=%p INTA=%d<=%d
pcnet_isr_change s=%p INTA=%d<=%d
%d@%zu.%06zu:pcnet_s_reset s=%p
%d@%zu.%06zu:pcnet_init s=%p init_addr=0x%lx
pcnet_init s=%p init_addr=0x%lx
%d@%zu.%06zu:pcnet_rlen_tlen s=%p rlen=%d tlen=%d
pcnet_rlen_tlen s=%p rlen=%d tlen=%d
%d@%zu.%06zu:pcnet_ss32_rdra_tdra s=%p ss32=%d rdra=0x%08x[%d] tdra=0x%08x[%d]
pcnet_ss32_rdra_tdra s=%p ss32=%d rdra=0x%08x[%d] tdra=0x%08x[%d]
%d@%zu.%06zu:e1000_receiver_overrun Receiver overrun: dropped packet of %zu bytes, RDH=%u, RDT=%u
e1000_receiver_overrun Receiver overrun: dropped packet of %zu bytes, RDH=%u, RDT=%u
%d@%zu.%06zu:e1000x_rx_can_recv_disabled link_up: %d, rx_enabled %d, pci_master %d
e1000x_rx_can_recv_disabled link_up: %d, rx_enabled %d, pci_master %d
%d@%zu.%06zu:e1000x_vlan_is_vlan_pkt Is VLAN packet: %d, ETH proto: 0x%X, VET: 0x%X
e1000x_vlan_is_vlan_pkt Is VLAN packet: %d, ETH proto: 0x%X, VET: 0x%X
%d@%zu.%06zu:e1000x_rx_flt_vlan_mismatch VID mismatch: 0x%X
e1000x_rx_flt_vlan_mismatch VID mismatch: 0x%X
%d@%zu.%06zu:e1000x_rx_flt_vlan_match VID match: 0x%X
e1000x_rx_flt_vlan_match VID match: 0x%X
%d@%zu.%06zu:e1000x_rx_flt_ucast_match unicast match[%d]: %02x:%02x:%02x:%02x:%02x:%02x
e1000x_rx_flt_ucast_match unicast match[%d]: %02x:%02x:%02x:%02x:%02x:%02x
%d@%zu.%06zu:e1000x_rx_flt_ucast_mismatch unicast mismatch: %02x:%02x:%02x:%02x:%02x:%02x
e1000x_rx_flt_ucast_mismatch unicast mismatch: %02x:%02x:%02x:%02x:%02x:%02x
%d@%zu.%06zu:e1000x_rx_flt_inexact_mismatch inexact mismatch: %02x:%02x:%02x:%02x:%02x:%02x MO %d MTA[%d] 0x%x
e1000x_rx_flt_inexact_mismatch inexact mismatch: %02x:%02x:%02x:%02x:%02x:%02x MO %d MTA[%d] 0x%x
%d@%zu.%06zu:e1000x_rx_link_down Received packet dropped because the link is down STATUS = %u
e1000x_rx_link_down Received packet dropped because the link is down STATUS = %u
%d@%zu.%06zu:e1000x_rx_disabled Received packet dropped because receive is disabled RCTL = %u
e1000x_rx_disabled Received packet dropped because receive is disabled RCTL = %u
%d@%zu.%06zu:e1000x_rx_oversized Received packet dropped because it was oversized (%zu bytes)
e1000x_rx_oversized Received packet dropped because it was oversized (%zu bytes)
%d@%zu.%06zu:e1000x_link_negotiation_start Start link auto negotiation
e1000x_link_negotiation_start Start link auto negotiation
%d@%zu.%06zu:e1000x_mac_indicate Indicating MAC to guest: %02x:%02x:%02x:%02x:%02x:%02x
e1000x_mac_indicate Indicating MAC to guest: %02x:%02x:%02x:%02x:%02x:%02x
%d@%zu.%06zu:e1000x_link_negotiation_done Auto negotiation is completed
e1000x_link_negotiation_done Auto negotiation is completed
fragment_offset % IP_FRAG_UNIT_SIZE == 0
(frag_off_units & ~IP_OFFMASK) == 0
%d@%zu.%06zu:net_rx_pkt_parsed RX packet parsed: ip4: %d, ip6: %d, l4 protocol: %d, l3 offset: %zu, l4 offset: %zu, l5 offset: %zu
net_rx_pkt_parsed RX packet parsed: ip4: %d, ip6: %d, l4 protocol: %d, l3 offset: %zu, l4 offset: %zu, l5 offset: %zu
%d@%zu.%06zu:net_rx_pkt_rss_add_chunk Add RSS chunk %p, %zu bytes, RSS input offset %zu bytes
net_rx_pkt_rss_add_chunk Add RSS chunk %p, %zu bytes, RSS input offset %zu bytes
%d@%zu.%06zu:net_rx_pkt_l4_csum_calc_entry Starting L4 checksum calculation
net_rx_pkt_l4_csum_calc_entry Starting L4 checksum calculation
%d@%zu.%06zu:net_rx_pkt_l4_csum_calc_ip4_udp IP4/UDP packet
net_rx_pkt_l4_csum_calc_ip4_udp IP4/UDP packet
%d@%zu.%06zu:net_rx_pkt_l4_csum_calc_ip4_tcp IP4/TCP packet
net_rx_pkt_l4_csum_calc_ip4_tcp IP4/TCP packet
%d@%zu.%06zu:net_rx_pkt_l4_csum_calc_ph_csum Pseudo-header: checksum counter %u, length %u
net_rx_pkt_l4_csum_calc_ph_csum Pseudo-header: checksum counter %u, length %u
%d@%zu.%06zu:net_rx_pkt_l4_csum_calc_ip6_udp IP6/UDP packet
net_rx_pkt_l4_csum_calc_ip6_udp IP6/UDP packet
%d@%zu.%06zu:net_rx_pkt_l4_csum_calc_ip6_tcp IP6/TCP packet
net_rx_pkt_l4_csum_calc_ip6_tcp IP6/TCP packet
%d@%zu.%06zu:net_rx_pkt_l4_csum_calc_csum L4 Checksum: L4 header offset: %zu, length: %u, counter: 0x%X, final checksum: 0x%X
net_rx_pkt_l4_csum_calc_csum L4 Checksum: L4 header offset: %zu, length: %u, counter: 0x%X, final checksum: 0x%X
%d@%zu.%06zu:net_rx_pkt_rss_ip4 Calculating IPv4 RSS  hash
net_rx_pkt_rss_ip4 Calculating IPv4 RSS  hash
pkt->l4hdr_info.proto == ETH_L4_HDR_PROTO_TCP
%d@%zu.%06zu:net_rx_pkt_rss_ip4_tcp Calculating IPv4/TCP RSS  hash
net_rx_pkt_rss_ip4_tcp Calculating IPv4/TCP RSS  hash
%d@%zu.%06zu:net_rx_pkt_rss_ip6_tcp Calculating IPv6/TCP RSS  hash
net_rx_pkt_rss_ip6_tcp Calculating IPv6/TCP RSS  hash
%d@%zu.%06zu:net_rx_pkt_rss_ip6 Calculating IPv6 RSS  hash
net_rx_pkt_rss_ip6 Calculating IPv6 RSS  hash
%d@%zu.%06zu:net_rx_pkt_rss_ip6_ex Calculating IPv6/EX RSS  hash
net_rx_pkt_rss_ip6_ex Calculating IPv6/EX RSS  hash
%d@%zu.%06zu:net_rx_pkt_rss_ip6_ex_tcp Calculating IPv6/EX/TCP RSS  hash
net_rx_pkt_rss_ip6_ex_tcp Calculating IPv6/EX/TCP RSS  hash
pkt->l4hdr_info.proto == ETH_L4_HDR_PROTO_UDP
%d@%zu.%06zu:net_rx_pkt_rss_ip4_udp Calculating IPv4/UDP RSS  hash
net_rx_pkt_rss_ip4_udp Calculating IPv4/UDP RSS  hash
%d@%zu.%06zu:net_rx_pkt_rss_ip6_udp Calculating IPv6/UDP RSS  hash
net_rx_pkt_rss_ip6_udp Calculating IPv6/UDP RSS  hash
%d@%zu.%06zu:net_rx_pkt_rss_ip6_ex_udp Calculating IPv6/EX/UDP RSS  hash
net_rx_pkt_rss_ip6_ex_udp Calculating IPv6/EX/UDP RSS  hash
%d@%zu.%06zu:net_rx_pkt_rss_hash RSS hash for %zu bytes: 0x%X
net_rx_pkt_rss_hash RSS hash for %zu bytes: 0x%X
%d@%zu.%06zu:net_rx_pkt_l3_csum_validate_entry Starting L3 checksum validation
net_rx_pkt_l3_csum_validate_entry Starting L3 checksum validation
%d@%zu.%06zu:net_rx_pkt_l3_csum_validate_not_ip4 Not an IP4 packet
net_rx_pkt_l3_csum_validate_not_ip4 Not an IP4 packet
%d@%zu.%06zu:net_rx_pkt_l3_csum_validate_csum L3 Checksum: L3 header offset: %zu, length: %u, counter: 0x%X, final checksum: 0x%X, valid: %d
net_rx_pkt_l3_csum_validate_csum L3 Checksum: L3 header offset: %zu, length: %u, counter: 0x%X, final checksum: 0x%X, valid: %d
%d@%zu.%06zu:net_rx_pkt_l4_csum_validate_entry Starting L4 checksum validation
net_rx_pkt_l4_csum_validate_entry Starting L4 checksum validation
%d@%zu.%06zu:net_rx_pkt_l4_csum_validate_ip4_fragment IP4 fragment
net_rx_pkt_l4_csum_validate_ip4_fragment IP4 fragment
%d@%zu.%06zu:net_rx_pkt_l4_csum_validate_udp_with_no_checksum UDP packet without checksum
net_rx_pkt_l4_csum_validate_udp_with_no_checksum UDP packet without checksum
%d@%zu.%06zu:net_rx_pkt_l4_csum_validate_not_xxp Not a TCP/UDP packet
net_rx_pkt_l4_csum_validate_not_xxp Not a TCP/UDP packet
%d@%zu.%06zu:net_rx_pkt_l4_csum_validate_csum Checksum valid: %d
net_rx_pkt_l4_csum_validate_csum Checksum valid: %d
%d@%zu.%06zu:net_rx_pkt_l4_csum_fix_entry Starting L4 checksum correction
net_rx_pkt_l4_csum_fix_entry Starting L4 checksum correction
%d@%zu.%06zu:net_rx_pkt_l4_csum_fix_tcp TCP packet, L4 cso: %u
net_rx_pkt_l4_csum_fix_tcp TCP packet, L4 cso: %u
%d@%zu.%06zu:net_rx_pkt_l4_csum_fix_udp_with_no_checksum UDP packet without checksum
net_rx_pkt_l4_csum_fix_udp_with_no_checksum UDP packet without checksum
%d@%zu.%06zu:net_rx_pkt_l4_csum_fix_udp UDP packet, L4 cso: %u
net_rx_pkt_l4_csum_fix_udp UDP packet, L4 cso: %u
%d@%zu.%06zu:net_rx_pkt_l4_csum_fix_not_xxp Not an IP4 packet
net_rx_pkt_l4_csum_fix_not_xxp Not an IP4 packet
%d@%zu.%06zu:net_rx_pkt_l4_csum_fix_ip4_fragment IP4 fragment
net_rx_pkt_l4_csum_fix_ip4_fragment IP4 fragment
%d@%zu.%06zu:net_rx_pkt_l4_csum_fix_csum L4 Checksum: Offset: %u, value 0x%X
net_rx_pkt_l4_csum_fix_csum L4 Checksum: Offset: %u, value 0x%X
%d@%zu.%06zu:e1000e_cb_pre_save E1000E pre save entry
e1000e_cb_pre_save E1000E pre save entry
Do not use virtio headers, perform SW offloads emulation instead
PCI device Subsystem Vendor ID
%d@%zu.%06zu:e1000e_cb_post_load E1000E post load entry
e1000e_cb_post_load E1000E post load entry
ERROR: Cannot migrate while device properties (subsys/subsys_ven) differ
%d@%zu.%06zu:e1000e_wrn_io_addr_undefined IO undefined register 0x%lx
e1000e_wrn_io_addr_undefined IO undefined register 0x%lx
%d@%zu.%06zu:e1000e_wrn_io_addr_flash IO flash access (0x%lx) not implemented
e1000e_wrn_io_addr_flash IO flash access (0x%lx) not implemented
%d@%zu.%06zu:e1000e_wrn_io_addr_unknown IO unknown register 0x%lx
e1000e_wrn_io_addr_unknown IO unknown register 0x%lx
%d@%zu.%06zu:e1000e_io_read_addr IOADDR read 0x%lx
e1000e_io_read_addr IOADDR read 0x%lx
%d@%zu.%06zu:e1000e_io_read_data IODATA read 0x%lx, value: 0x%lx
e1000e_io_read_data IODATA read 0x%lx, value: 0x%lx
%d@%zu.%06zu:e1000e_wrn_io_read_unknown IO read unknown address 0x%lx
e1000e_wrn_io_read_unknown IO read unknown address 0x%lx
%d@%zu.%06zu:e1000e_io_write_addr IOADDR write 0x%lx
e1000e_io_write_addr IOADDR write 0x%lx
%d@%zu.%06zu:e1000e_io_write_data IODATA write 0x%lx, value: 0x%lx
e1000e_io_write_data IODATA write 0x%lx, value: 0x%lx
%d@%zu.%06zu:e1000e_wrn_io_write_unknown IO write unknown address 0x%lx
e1000e_wrn_io_write_unknown IO write unknown address 0x%lx
%d@%zu.%06zu:e1000e_cb_qdev_reset_hold E1000E qdev reset hold
e1000e_cb_qdev_reset_hold E1000E qdev reset hold
%d@%zu.%06zu:e1000e_cb_pci_uninit E1000E PCI unit entry
e1000e_cb_pci_uninit E1000E PCI unit entry
%d@%zu.%06zu:e1000e_cb_pci_realize E1000E PCI realize entry
e1000e_cb_pci_realize E1000E PCI realize entry
%d@%zu.%06zu:e1000e_msix_init_fail Failed to initialize MSI-X, error %d
e1000e_msix_init_fail Failed to initialize MSI-X, error %d
Failed to initialize PCIe capability
%d@%zu.%06zu:e1000e_msi_init_fail Failed to initialize MSI, error %d
e1000e_msi_init_fail Failed to initialize MSI, error %d
Failed to initialize PM capability
Failed to initialize AER capability
%d@%zu.%06zu:e1000e_mac_set_permanent Set permanent MAC: %02x:%02x:%02x:%02x:%02x:%02x
e1000e_mac_set_permanent Set permanent MAC: %02x:%02x:%02x:%02x:%02x:%02x
%d@%zu.%06zu:e1000e_cfg_support_virtio Virtio header supported: %d
e1000e_cfg_support_virtio Virtio header supported: %d
%d@%zu.%06zu:e1000e_irq_read_ims Current IMS: 0x%x
e1000e_irq_read_ims Current IMS: 0x%x
%d@%zu.%06zu:e1000e_irq_read_ics Current ICS: 0x%x
e1000e_irq_read_ics Current ICS: 0x%x
%d@%zu.%06zu:e1000e_link_status Link up: %d, Duplex: %d, Speed: %d, ASDV: %d
e1000e_link_status Link up: %d, Duplex: %d, Speed: %d, ASDV: %d
%d@%zu.%06zu:e1000e_link_read_params Get link params: Autodetect: %d, Speed: %d, Force speed: %d, Force duplex: %d, RX flow control %d, TX flow control %d
e1000e_link_read_params Get link params: Autodetect: %d, Speed: %d, Force speed: %d, Force duplex: %d, RX flow control %d, TX flow control %d
%d@%zu.%06zu:e1000e_rx_set_rfctl Setting RFCTL = 0x%X
e1000e_rx_set_rfctl Setting RFCTL = 0x%X
%d@%zu.%06zu:e1000e_wrn_iscsi_filtering_not_supported WARNING: Guest requested iSCSI filtering  which is not supported
e1000e_wrn_iscsi_filtering_not_supported WARNING: Guest requested iSCSI filtering  which is not supported
%d@%zu.%06zu:e1000e_wrn_nfsw_filtering_not_supported WARNING: Guest requested NFS write filtering  which is not supported
e1000e_wrn_nfsw_filtering_not_supported WARNING: Guest requested NFS write filtering  which is not supported
%d@%zu.%06zu:e1000e_wrn_nfsr_filtering_not_supported WARNING: Guest requested NFS read filtering  which is not supported
e1000e_wrn_nfsr_filtering_not_supported WARNING: Guest requested NFS read filtering  which is not supported
%d@%zu.%06zu:e1000e_irq_eitr_set EITR[%u] = %u
e1000e_irq_eitr_set EITR[%u] = %u
%d@%zu.%06zu:e1000e_irq_itr_set ITR = %u
%d@%zu.%06zu:e1000e_vlan_vet Setting VLAN ethernet type 0x%X
e1000e_vlan_vet Setting VLAN ethernet type 0x%X
%d@%zu.%06zu:e1000e_link_set_ext_params Set extended link params: ASD check: %d, Speed select bypass: %d
e1000e_link_set_ext_params Set extended link params: ASD check: %d, Speed select bypass: %d
%d@%zu.%06zu:e1000e_irq_msix_notify_postponed_vec Sending MSI-X postponed by EITR[%d]
e1000e_irq_msix_notify_postponed_vec Sending MSI-X postponed by EITR[%d]
%d@%zu.%06zu:e1000e_mac_set_sw Set SW MAC: %02x:%02x:%02x:%02x:%02x:%02x
e1000e_mac_set_sw Set SW MAC: %02x:%02x:%02x:%02x:%02x:%02x
%d@%zu.%06zu:e1000e_rx_set_cso RX CSO state set to %d
e1000e_rx_set_cso RX CSO state set to %d
e1000e: PSRCTL.BSIZE0 cannot be zero
e1000e: PSRCTL.BSIZE1 cannot be zero
data_len <= core->rxbuf_sizes[0] - bastate->written[0]
%d@%zu.%06zu:e1000e_ring_free_space ring #%d: LEN: %u, DH: %u, DT: %u
e1000e_ring_free_space ring #%d: LEN: %u, DH: %u, DT: %u
%d@%zu.%06zu:e1000e_rx_has_buffers ring #%d: free descr: %u, packet size %zu, descr buffer size %u
e1000e_rx_has_buffers ring #%d: free descr: %u, packet size %zu, descr buffer size %u
%d@%zu.%06zu:e1000e_rx_desc_buff_write buffer #%u, addr: 0x%lx, offset: %u, from: %p, length: %u
e1000e_rx_desc_buff_write buffer #%u, addr: 0x%lx, offset: %u, from: %p, length: %u
bastate->cur_idx < MAX_PS_BUFFERS
%d@%zu.%06zu:e1000e_link_autoneg_flowctl Auto-negotiated flow control state is %d
e1000e_link_autoneg_flowctl Auto-negotiated flow control state is %d
%d@%zu.%06zu:e1000e_core_ctrl_write Write CTRL register 0x%lx, value: 0x%X
e1000e_core_ctrl_write Write CTRL register 0x%lx, value: 0x%X
%d@%zu.%06zu:e1000e_link_set_params Set link params: Autodetect: %d, Speed: %d, Force speed: %d, Force duplex: %d, RX flow control %d, TX flow control %d
e1000e_link_set_params Set link params: Autodetect: %d, Speed: %d, Force speed: %d, Force duplex: %d, RX flow control %d, TX flow control %d
%d@%zu.%06zu:e1000e_core_ctrl_sw_reset Doing SW reset
e1000e_core_ctrl_sw_reset Doing SW reset
%d@%zu.%06zu:e1000e_core_ctrl_phy_reset Doing PHY reset
e1000e_core_ctrl_phy_reset Doing PHY reset
%d@%zu.%06zu:e1000e_irq_msix_pending_clearing Clearing MSI-X pending bit for cause 0x%x, IVAR config 0x%x, vector %u
e1000e_irq_msix_pending_clearing Clearing MSI-X pending bit for cause 0x%x, IVAR config 0x%x, vector %u
%d@%zu.%06zu:e1000e_wrn_msix_vec_wrong Invalid configuration for cause 0x%x: 0x%x
e1000e_wrn_msix_vec_wrong Invalid configuration for cause 0x%x: 0x%x
%d@%zu.%06zu:e1000e_wrn_msix_invalid Invalid entry for cause 0x%x: 0x%x
e1000e_wrn_msix_invalid Invalid entry for cause 0x%x: 0x%x
%d@%zu.%06zu:e1000e_irq_msi_notify_postponed Sending MSI postponed by ITR
e1000e_irq_msi_notify_postponed Sending MSI postponed by ITR
%d@%zu.%06zu:e1000e_irq_legacy_notify_postponed Raising legacy IRQ postponed by ITR
e1000e_irq_legacy_notify_postponed Raising legacy IRQ postponed by ITR
%d@%zu.%06zu:e1000e_irq_legacy_notify IRQ line state: %d
e1000e_irq_legacy_notify IRQ line state: %d
%d@%zu.%06zu:e1000e_rx_metadata_protocols protocols: ip4: %d, ip6: %d, l4hdr: %d
e1000e_rx_metadata_protocols protocols: ip4: %d, ip6: %d, l4hdr: %d
%d@%zu.%06zu:e1000e_rx_metadata_vlan VLAN tag is 0x%X
e1000e_rx_metadata_vlan VLAN tag is 0x%X
%d@%zu.%06zu:e1000e_rx_metadata_rss RSS data: rss: 0x%X, mrq: 0x%X
e1000e_rx_metadata_rss RSS data: rss: 0x%X, mrq: 0x%X
%d@%zu.%06zu:e1000e_rx_metadata_ip_id the IPv4 ID is 0x%X
e1000e_rx_metadata_ip_id the IPv4 ID is 0x%X
%d@%zu.%06zu:e1000e_rx_metadata_ack the packet is TCP ACK
e1000e_rx_metadata_ack the packet is TCP ACK
%d@%zu.%06zu:e1000e_rx_metadata_ipv6_filtering_disabled IPv6 RX filtering disabled by RFCTL
e1000e_rx_metadata_ipv6_filtering_disabled IPv6 RX filtering disabled by RFCTL
%d@%zu.%06zu:e1000e_rx_metadata_pkt_type the packet type is %u
e1000e_rx_metadata_pkt_type the packet type is %u
%d@%zu.%06zu:e1000e_rx_metadata_ipv6_sum_disabled IPv6 RX checksummimg disabled by RFCTL
e1000e_rx_metadata_ipv6_sum_disabled IPv6 RX checksummimg disabled by RFCTL
%d@%zu.%06zu:e1000e_rx_metadata_virthdr_no_csum_info virt-header does not contain checksum info
e1000e_rx_metadata_virthdr_no_csum_info virt-header does not contain checksum info
%d@%zu.%06zu:e1000e_rx_metadata_l3_csum_validation_failed Cannot validate L3 checksum
e1000e_rx_metadata_l3_csum_validation_failed Cannot validate L3 checksum
%d@%zu.%06zu:e1000e_rx_metadata_l3_cso_disabled IP4 CSO is disabled
e1000e_rx_metadata_l3_cso_disabled IP4 CSO is disabled
%d@%zu.%06zu:e1000e_rx_metadata_l4_cso_disabled TCP/UDP CSO is disabled
e1000e_rx_metadata_l4_cso_disabled TCP/UDP CSO is disabled
%d@%zu.%06zu:e1000e_rx_metadata_l4_csum_validation_failed Cannot validate L4 checksum
e1000e_rx_metadata_l4_csum_validation_failed Cannot validate L4 checksum
%d@%zu.%06zu:e1000e_rx_metadata_status_flags status_flags is 0x%X
e1000e_rx_metadata_status_flags status_flags is 0x%X
%d@%zu.%06zu:e1000e_irq_clear Clearing interrupt register 0x%x: 0x%x --> 0x%x
e1000e_irq_clear Clearing interrupt register 0x%x: 0x%x --> 0x%x
%d@%zu.%06zu:e1000e_irq_pending_interrupts ICR PENDING: 0x%x (ICR: 0x%x, IMS: 0x%x)
e1000e_irq_pending_interrupts ICR PENDING: 0x%x (ICR: 0x%x, IMS: 0x%x)
%d@%zu.%06zu:e1000e_irq_icr_clear_zero_ims Clearing ICR on read due to zero IMS
e1000e_irq_icr_clear_zero_ims Clearing ICR on read due to zero IMS
%d@%zu.%06zu:e1000e_irq_icr_clear_nonmsix_icr_read Clearing ICR on read due to non MSI-X int
e1000e_irq_icr_clear_nonmsix_icr_read Clearing ICR on read due to non MSI-X int
%d@%zu.%06zu:e1000e_irq_icr_clear_iame Clearing ICR on read due to IAME
e1000e_irq_icr_clear_iame Clearing ICR on read due to IAME
%d@%zu.%06zu:e1000e_irq_icr_process_iame Clearing IMS bits due to IAME
e1000e_irq_icr_process_iame Clearing IMS bits due to IAME
%d@%zu.%06zu:e1000e_irq_icr_clear_icr_bit_ims Clearing ICR on read due corresponding IMS bit: 0x%x & 0x%x
e1000e_irq_icr_clear_icr_bit_ims Clearing ICR on read due corresponding IMS bit: 0x%x & 0x%x
%d@%zu.%06zu:e1000e_irq_ims_clear_set_imc Clearing IMS bits due to IMC write 0x%x
e1000e_irq_ims_clear_set_imc Clearing IMS bits due to IMC write 0x%x
%d@%zu.%06zu:e1000e_irq_postponed_by_xitr Interrupt postponed by [E]ITR register 0x%x
e1000e_irq_postponed_by_xitr Interrupt postponed by [E]ITR register 0x%x
%d@%zu.%06zu:e1000e_irq_rearm_timer Mitigation timer armed for register 0x%X, delay %ld ns
e1000e_irq_rearm_timer Mitigation timer armed for register 0x%X, delay %ld ns
%d@%zu.%06zu:e1000e_irq_msix_notify_vec MSI-X notify vector 0x%x
e1000e_irq_msix_notify_vec MSI-X notify vector 0x%x
%d@%zu.%06zu:e1000e_irq_iam_clear_eiame Clearing IMS due to EIAME, IAM: 0x%X, cause: 0x%X
e1000e_irq_iam_clear_eiame Clearing IMS due to EIAME, IAM: 0x%X, cause: 0x%X
%d@%zu.%06zu:e1000e_irq_icr_clear_eiac Clearing ICR bits due to EIAC, ICR: 0x%X, EIAC: 0x%X
e1000e_irq_icr_clear_eiac Clearing ICR bits due to EIAC, ICR: 0x%X, EIAC: 0x%X
%d@%zu.%06zu:e1000e_irq_set Setting interrupt register 0x%x: 0x%x --> 0x%x
e1000e_irq_set Setting interrupt register 0x%x: 0x%x --> 0x%x
%d@%zu.%06zu:e1000e_irq_add_msi_other ICR_OTHER bit added: 0x%x
e1000e_irq_add_msi_other ICR_OTHER bit added: 0x%x
%d@%zu.%06zu:e1000e_irq_fix_icr_asserted ICR_ASSERTED bit fixed: 0x%x
e1000e_irq_fix_icr_asserted ICR_ASSERTED bit fixed: 0x%x
%d@%zu.%06zu:e1000e_irq_msi_notify MSI notify 0x%x
e1000e_irq_msi_notify MSI notify 0x%x
%d@%zu.%06zu:e1000e_irq_fire_all_timers Firing all delay/throttling timers on all interrupts enable (0x%X written to IMS)
e1000e_irq_fire_all_timers Firing all delay/throttling timers on all interrupts enable (0x%X written to IMS)
%d@%zu.%06zu:e1000e_irq_write_ics Adding ICR bits 0x%x
e1000e_irq_write_ics Adding ICR bits 0x%x
%d@%zu.%06zu:e1000e_irq_throttling_timer Mitigation timer shot for register 0x%X
e1000e_irq_throttling_timer Mitigation timer shot for register 0x%X
%d@%zu.%06zu:e1000e_irq_fire_delayed_interrupts Firing delayed interrupts
e1000e_irq_fire_delayed_interrupts Firing delayed interrupts
%d@%zu.%06zu:e1000e_irq_tidv_fpd_running FPD written while TIDV was running
e1000e_irq_tidv_fpd_running FPD written while TIDV was running
%d@%zu.%06zu:e1000e_irq_tidv_fpd_not_running FPD written while TIDV was not running
e1000e_irq_tidv_fpd_not_running FPD written while TIDV was not running
%d@%zu.%06zu:e1000e_irq_rdtr_fpd_running FPD written while RDTR was running
e1000e_irq_rdtr_fpd_running FPD written while RDTR was running
%d@%zu.%06zu:e1000e_irq_rdtr_fpd_not_running FPD written while RDTR was not running
e1000e_irq_rdtr_fpd_not_running FPD written while RDTR was not running
%d@%zu.%06zu:e1000e_core_mdic_read_unhandled MDIC READ: PHY[%u][%u] UNHANDLED
e1000e_core_mdic_read_unhandled MDIC READ: PHY[%u][%u] UNHANDLED
%d@%zu.%06zu:e1000e_core_mdic_read MDIC READ: PHY[%u][%u] = 0x%x
e1000e_core_mdic_read MDIC READ: PHY[%u][%u] = 0x%x
%d@%zu.%06zu:e1000e_core_mdic_write_unhandled MDIC WRITE: PHY[%u][%u] UNHANDLED
e1000e_core_mdic_write_unhandled MDIC WRITE: PHY[%u][%u] UNHANDLED
%d@%zu.%06zu:e1000e_core_mdic_write MDIC WRITE: PHY[%u][%u] = 0x%x
e1000e_core_mdic_write MDIC WRITE: PHY[%u][%u] = 0x%x
%d@%zu.%06zu:e1000e_tx_disabled TX Disabled
e1000e_tx_disabled TX Disabled
%d@%zu.%06zu:e1000e_tx_descr %p : %x %x
%d@%zu.%06zu:e1000e_wrn_no_snap_support WARNING: Guest requested TX SNAP header update which is not supported
e1000e_wrn_no_snap_support WARNING: Guest requested TX SNAP header update which is not supported
%d@%zu.%06zu:e1000e_wrn_no_ts_support WARNING: Guest requested TX timestamping which is not supported
e1000e_wrn_no_ts_support WARNING: Guest requested TX timestamping which is not supported
%d@%zu.%06zu:e1000e_rx_receive_iov Received vector of %d fragments
e1000e_rx_receive_iov Received vector of %d fragments
%d@%zu.%06zu:e1000e_rx_flt_dropped Received packet dropped by RX filter
e1000e_rx_flt_dropped Received packet dropped by RX filter
%d@%zu.%06zu:e1000e_rx_rss_started Starting RSS processing
e1000e_rx_rss_started Starting RSS processing
%d@%zu.%06zu:e1000e_rx_rss_disabled RSS is disabled
e1000e_rx_rss_disabled RSS is disabled
%d@%zu.%06zu:e1000e_rx_rss_ip4 RSS IPv4: L4 header protocol %d, mrqc 0x%X, tcpipv4 enabled %d, ipv4 enabled %d
e1000e_rx_rss_ip4 RSS IPv4: L4 header protocol %d, mrqc 0x%X, tcpipv4 enabled %d, ipv4 enabled %d
%d@%zu.%06zu:e1000e_rx_rss_ip6_rfctl RSS IPv6: rfctl 0x%X
e1000e_rx_rss_ip6_rfctl RSS IPv6: rfctl 0x%X
%d@%zu.%06zu:e1000e_rx_rss_ip6 RSS IPv6: ex_dis: %d, new_ex_dis: %d, L4 header protocol %d, has_ext_headers %d, ex_dst_valid %d, ex_src_valid %d, mrqc 0x%X, tcpipv6ex enabled %d, ipv6ex enabled %d, ipv6 enabled %d
e1000e_rx_rss_ip6 RSS IPv6: ex_dis: %d, new_ex_dis: %d, L4 header protocol %d, has_ext_headers %d, ex_dst_valid %d, ex_src_valid %d, mrqc 0x%X, tcpipv6ex enabled %d, ipv6ex enabled %d, ipv6 enabled %d
e1000e_rx_rss_type RSS type is %u
%d@%zu.%06zu:e1000e_rx_descr Next RX descriptor: ring #%d, PA: 0x%lx, length: %u
e1000e_rx_descr Next RX descriptor: ring #%d, PA: 0x%lx, length: %u
%d@%zu.%06zu:e1000e_rx_desc_ps_read buffers: [0x%lx, 0x%lx, 0x%lx, 0x%lx]
e1000e_rx_desc_ps_read buffers: [0x%lx, 0x%lx, 0x%lx, 0x%lx]
%d@%zu.%06zu:e1000e_rx_null_descriptor Null RX descriptor!!
e1000e_rx_null_descriptor Null RX descriptor!!
%d@%zu.%06zu:e1000e_rx_desc_ps_write bytes written: [%u, %u, %u, %u]
e1000e_rx_desc_ps_write bytes written: [%u, %u, %u, %u]
%d@%zu.%06zu:e1000e_rx_written_to_guest Received packet written to guest (queue %d)
e1000e_rx_written_to_guest Received packet written to guest (queue %d)
%d@%zu.%06zu:e1000e_rx_not_written_to_guest Received packet NOT written to guest (queue %d)
e1000e_rx_not_written_to_guest Received packet NOT written to guest (queue %d)
%d@%zu.%06zu:e1000e_rx_interrupt_set Receive interrupt set (ICR causes %u)
e1000e_rx_interrupt_set Receive interrupt set (ICR causes %u)
%d@%zu.%06zu:e1000e_rx_interrupt_delayed Receive interrupt delayed (ICR causes %u)
e1000e_rx_interrupt_delayed Receive interrupt delayed (ICR causes %u)
%d@%zu.%06zu:e1000e_rx_rss_type RSS type is %u
%d@%zu.%06zu:e1000e_rx_start_recv 
%d@%zu.%06zu:e1000e_rx_set_rdt Setting RDT[%d] = %u
e1000e_rx_set_rdt Setting RDT[%d] = %u
%d@%zu.%06zu:e1000e_rx_set_rctl RCTL = 0x%x
e1000e_rx_set_rctl RCTL = 0x%x
%d@%zu.%06zu:e1000e_rx_desc_buff_sizes buffer sizes: [%u, %u, %u, %u]
e1000e_rx_desc_buff_sizes buffer sizes: [%u, %u, %u, %u]
%d@%zu.%06zu:e1000e_rx_desc_len RX descriptor length: %u
e1000e_rx_desc_len RX descriptor length: %u
%d@%zu.%06zu:e1000e_rx_can_recv Can receive
e1000e_rx_can_recv Can receive
%d@%zu.%06zu:e1000e_rx_can_recv_rings_full Cannot receive: all rings are full
e1000e_rx_can_recv_rings_full Cannot receive: all rings are full
%d@%zu.%06zu:e1000e_link_status_changed New link status: %d
e1000e_link_status_changed New link status: %d
%d@%zu.%06zu:e1000e_wrn_regs_write_trivial WARNING: Writing to register at offset: 0x%05x. It is not fully implemented.
e1000e_wrn_regs_write_trivial WARNING: Writing to register at offset: 0x%05x. It is not fully implemented.
%d@%zu.%06zu:e1000e_core_write Write to register 0x%lx, %d byte(s), value: 0x%lx
e1000e_core_write Write to register 0x%lx, %d byte(s), value: 0x%lx
%d@%zu.%06zu:e1000e_wrn_regs_write_ro WARNING: Write to RO register 0x%lx, %d byte(s), value: 0x%lx
e1000e_wrn_regs_write_ro WARNING: Write to RO register 0x%lx, %d byte(s), value: 0x%lx
%d@%zu.%06zu:e1000e_wrn_regs_write_unknown WARNING: Write to unknown register 0x%lx, %d byte(s), value: 0x%lx
e1000e_wrn_regs_write_unknown WARNING: Write to unknown register 0x%lx, %d byte(s), value: 0x%lx
%d@%zu.%06zu:e1000e_wrn_regs_read_trivial WARNING: Reading register at offset: 0x%05x. It is not fully implemented.
e1000e_wrn_regs_read_trivial WARNING: Reading register at offset: 0x%05x. It is not fully implemented.
%d@%zu.%06zu:e1000e_core_read Read from register 0x%lx, %d byte(s), value: 0x%lx
e1000e_core_read Read from register 0x%lx, %d byte(s), value: 0x%lx
%d@%zu.%06zu:e1000e_wrn_regs_read_unknown WARNING: Read from unknown register 0x%lx, %d byte(s)
e1000e_wrn_regs_read_unknown WARNING: Read from unknown register 0x%lx, %d byte(s)
Intel 82576 Gigabit Ethernet Controller
%d@%zu.%06zu:igb_write_config CONFIG write 0x%x, value: 0x%x, len: %d
igb_write_config CONFIG write 0x%x, value: 0x%x, len: %d
pcie_endpoint_cap_init(pci_dev, 0xa0) > 0
%d@%zu.%06zu:igbvf_wrn_io_addr_unknown IO unknown register 0x%lx
igbvf_wrn_io_addr_unknown IO unknown register 0x%lx
%d@%zu.%06zu:igbvf_write_config CONFIG write 0x%x, value: 0x%x, len: %d
igbvf_write_config CONFIG write 0x%x, value: 0x%x, len: %d
%d@%zu.%06zu:igb_irq_eitr_set EITR[%u] = 0x%x
igb_irq_eitr_set EITR[%u] = 0x%x
%d@%zu.%06zu:igb_irq_write_eiam Update EIAM: 0x%x MSI-X: %d
igb_irq_write_eiam Update EIAM: 0x%x MSI-X: %d
igb: Tried to use vector unavailable for PF
%d@%zu.%06zu:igb_irq_write_eiac Update EIAC: 0x%x
igb_irq_write_eiac Update EIAC: 0x%x
%d@%zu.%06zu:igb_link_set_ext_params Set extended link params: ASD check: %d, Speed select bypass: %d, PF reset done: %d
igb_link_set_ext_params Set extended link params: ASD check: %d, Speed select bypass: %d, PF reset done: %d
pdma_st->bastate.cur_idx < IGB_MAX_PS_BUFFERS
%d@%zu.%06zu:igb_rx_desc_buff_write buffer %u, addr: 0x%lx, offset: %u, from: %p, length: %u
igb_rx_desc_buff_write buffer %u, addr: 0x%lx, offset: %u, from: %p, length: %u
%d@%zu.%06zu:igb_set_vfmailbox VFMailbox[%d]: 0x%x
igb_set_vfmailbox VFMailbox[%d]: 0x%x
%d@%zu.%06zu:igb_irq_write_eims Update EIMS: 0x%x MSI-X: %d
igb_irq_write_eims Update EIMS: 0x%x MSI-X: %d
%d@%zu.%06zu:igb_irq_write_eics Update EICS: 0x%x MSI-X: %d
igb_irq_write_eics Update EICS: 0x%x MSI-X: %d
%d@%zu.%06zu:igb_core_mdic_read_unhandled MDIC READ: PHY[%u] UNHANDLED
igb_core_mdic_read_unhandled MDIC READ: PHY[%u] UNHANDLED
%d@%zu.%06zu:igb_core_mdic_read MDIC READ: PHY[%u] = 0x%x
igb_core_mdic_read MDIC READ: PHY[%u] = 0x%x
%d@%zu.%06zu:igb_core_mdic_write_unhandled MDIC WRITE: PHY[%u] UNHANDLED
igb_core_mdic_write_unhandled MDIC WRITE: PHY[%u] UNHANDLED
%d@%zu.%06zu:igb_core_mdic_write MDIC WRITE: PHY[%u] = 0x%x
igb_core_mdic_write MDIC WRITE: PHY[%u] = 0x%x
%d@%zu.%06zu:igb_set_pfmailbox PFMailbox[%d]: 0x%x
igb_set_pfmailbox PFMailbox[%d]: 0x%x
%d@%zu.%06zu:igb_irq_icr_clear_gpie_nsicr Clearing ICR on read due to GPIE.NSICR enabled
igb_irq_icr_clear_gpie_nsicr Clearing ICR on read due to GPIE.NSICR enabled
%d@%zu.%06zu:igb_irq_write_eicr Update EICR: 0x%x MSI-X: %d
igb_irq_write_eicr Update EICR: 0x%x MSI-X: %d
%d@%zu.%06zu:igb_irq_write_eimc Update EIMC: 0x%x MSI-X: %d
igb_irq_write_eimc Update EIMC: 0x%x MSI-X: %d
%d@%zu.%06zu:igb_rx_metadata_rss RSS data: rss: 0x%X, rss_pkt_type: 0x%X
igb_rx_metadata_rss RSS data: rss: 0x%X, rss_pkt_type: 0x%X
%d@%zu.%06zu:igb_wrn_rx_desc_modes_not_supp Not supported descriptor type: %d
igb_wrn_rx_desc_modes_not_supp Not supported descriptor type: %d
data_len <= pdma_st->rx_desc_header_buf_size - pdma_st->bastate.written[0]
igb: RCTL.DTYP must be zero for compatibility
%d@%zu.%06zu:igb_core_vf_reset VF%d
%d@%zu.%06zu:tulip_rx_state RX %s
%d@%zu.%06zu:tulip_tx_state TX %s
%d@%zu.%06zu:tulip_irq mask 0x%08x ie 0x%08x %s
tulip_irq mask 0x%08x ie 0x%08x %s
%d@%zu.%06zu:tulip_mii_read phy 0x%x, reg 0x%x data 0x%04x
tulip_mii_read phy 0x%x, reg 0x%x data 0x%04x
%d@%zu.%06zu:tulip_mii_write phy 0x%x reg 0x%x data 0x%04x
tulip_mii_write phy 0x%x reg 0x%x data 0x%04x
%s: read access at unknown address 0x%lx
%d@%zu.%06zu:tulip_reg_read addr 0x%02lx (%s) size %d value 0x%08lx
tulip_reg_read addr 0x%02lx (%s) size %d value 0x%08lx
%d@%zu.%06zu:tulip_setup_frame 
%d@%zu.%06zu:tulip_setup_filter %d: %02x:%02x:%02x:%02x:%02x:%02x
tulip_setup_filter %d: %02x:%02x:%02x:%02x:%02x:%02x
%d@%zu.%06zu:tulip_receive buf %p size %zu
tulip_receive buf %p size %zu
%d@%zu.%06zu:tulip_descriptor %s 0x%08x: status 0x%08x control 0x%03x len1 %4d len2 %4d buf1 0x%08x buf2 0x%08x
tulip_descriptor %s 0x%08x: status 0x%08x control 0x%03x len1 %4d len2 %4d buf1 0x%08x buf2 0x%08x
%s: descriptor overflow (ofs: %u, len:%d, size:%zu)
%d@%zu.%06zu:tulip_reg_write addr 0x%02lx (%s) size %d value 0x%08lx
tulip_reg_write addr 0x%02lx (%s) size %d value 0x%08lx
%s: write to CSR at unknown address 0x%lx
vmxnet3: Bad TX queues number: %d
vmxnet3: Bad RX queues number: %d
VMWare Paravirtualized Ethernet v3
[%s][WR][%s]: Failed to initialize MSI-X, error %d
[%s][WR][%s]: Failed to initialize MSI-X, configuration is inconsistent.
[%s][ER][%s]: Failed to allocate multicast list of %d elements
!s->msix_used || !msix_enabled(d)
vmxnet3: Illegal TX queue %d/%d
[%s][WR][%s]: BAR0 unknown write [%lx] = %lx, size %d
[%s][WR][%s]: Received request for unknown command: %x
d->btype == VMXNET3_RXD_BTYPE_BODY
[%s][ER][%s]: Device configuration received from driver is invalid
vmxnet3_verify_intx(s, s->event_int_idx)
vmxnet3_verify_intx(s, s->txq_descr[i].intr_idx)
vmxnet3_verify_intx(s, s->rxq_descr[i].intr_idx)
%s: write to read-only register VMXNET3_REG_ICR
temp_shared_guest_driver_memory
Feature bits not defined for this type: %d
vhost-net requires net backend to be setup
vhost-net requires tap backend
vhost lacks feature mask 0x%lx for backend
vhost_ops->backend_type == VHOST_BACKEND_TYPE_USER
vhost_ops->vhost_migration_done
/home/virus/AMD/AMD/include/hw/virtio/virtio-net.h
/home/virus/AMD/AMD/include/hw/virtio/virtio-bus.h
vhost %d VQ %d notifier cleanup failed: %d
vhost guest notifier cleanup failed: %d
binding does not support guest notifiers
vhost %d binding does not support host notifiers
vhost %d VQ %d notifier binding failed: %d
Error enabling host notifiers: %d
Error binding guest notifier: %d
Error when restarting the queue.
rocker %s: L3 not implemented (cksum off: %u)
rocker %s: TSO not implemented (MSS: %u)
rocker %s: TSO not implemented (hdr length: %u)
invalid argument requested world %s does not exist
name too long; please shorten to at most %d chars
../hw/net/rocker/rocker_of_dpa.c
rocker %s doesn't have OF-DPA world
            ena/    speed/ auto
      port  link    duplex neg?
prio tbl hits key(mask) --> actions
../hw/net/can/can_kvaser_pci.c
../hw/net/can/can_pcm3680_pci.c
../hw/net/can/can_mioe3680_pci.c
filter_control_filter_status.u32
%d@%zu.%06zu:pci_nvme_err_insuff_active_res max_active=%u zone limit exceeded
pci_nvme_err_insuff_active_res max_active=%u zone limit exceeded
%d@%zu.%06zu:pci_nvme_err_insuff_open_res max_open=%u zone limit exceeded
pci_nvme_err_insuff_open_res max_open=%u zone limit exceeded
%d@%zu.%06zu:pci_nvme_enqueue_req_completion cid %u cqid %u dw0 0x%x dw1 0x%x status 0x%x
pci_nvme_enqueue_req_completion cid %u cqid %u dw0 0x%x dw1 0x%x status 0x%x
%d@%zu.%06zu:pci_nvme_err_req_status cid %u nsid %u status 0x%x opc 0x%x
pci_nvme_err_req_status cid %u nsid %u status 0x%x opc 0x%x
%d@%zu.%06zu:pci_nvme_process_aers queued %d
pci_nvme_process_aers queued %d
%d@%zu.%06zu:pci_nvme_no_outstanding_aers ignoring event; no outstanding AERs
pci_nvme_no_outstanding_aers ignoring event; no outstanding AERs
%d@%zu.%06zu:pci_nvme_aer_masked type 0x%x mask 0x%x
pci_nvme_aer_masked type 0x%x mask 0x%x
%d@%zu.%06zu:pci_nvme_aer_post_cqe type 0x%x info 0x%x lid 0x%x
pci_nvme_aer_post_cqe type 0x%x info 0x%x lid 0x%x
%d@%zu.%06zu:pci_nvme_enqueue_event type 0x%x info 0x%x lid 0x%x
pci_nvme_enqueue_event type 0x%x info 0x%x lid 0x%x
%d@%zu.%06zu:pci_nvme_enqueue_event_noqueue queued %d
pci_nvme_enqueue_event_noqueue queued %d
%d@%zu.%06zu:pci_nvme_flush_ns nsid 0x%x
%d@%zu.%06zu:pci_nvme_block_status offset %ld bytes %ld pnum %ld ret 0x%x zeroed %d
pci_nvme_block_status offset %ld bytes %ld pnum %ld ret 0x%x zeroed %d
%d@%zu.%06zu:pci_nvme_format_set nsid %u lbaf %u mset %u pi %u pil %u
pci_nvme_format_set nsid %u lbaf %u mset %u pi %u pil %u
ns->nr_active_zones <= ns->params.max_active_zones
nsid && nsid <= NVME_MAX_NAMESPACES
table_size > 0 && table_size <= pci_dev->msix_entries_nr
ns->nr_active_zones >= ns->nr_open_zones
%d@%zu.%06zu:pci_nvme_zns_zone_reset zslba 0x%lx
pci_nvme_zns_zone_reset zslba 0x%lx
%d@%zu.%06zu:pci_nvme_getfeat_timestamp get feature timestamp = 0x%lx
pci_nvme_getfeat_timestamp get feature timestamp = 0x%lx
unsupported smart critical warning bits: 0x%x
%d@%zu.%06zu:pci_nvme_create_sq create submission queue, addr=0x%lx, sqid=%u, cqid=%u, qsize=%u, qflags=%u
pci_nvme_create_sq create submission queue, addr=0x%lx, sqid=%u, cqid=%u, qsize=%u, qflags=%u
%d@%zu.%06zu:pci_nvme_err_invalid_create_sq_cqid failed creating submission queue, invalid cqid=%u
pci_nvme_err_invalid_create_sq_cqid failed creating submission queue, invalid cqid=%u
%d@%zu.%06zu:pci_nvme_err_invalid_create_sq_sqid failed creating submission queue, invalid sqid=%u
pci_nvme_err_invalid_create_sq_sqid failed creating submission queue, invalid sqid=%u
%d@%zu.%06zu:pci_nvme_err_invalid_create_sq_size failed creating submission queue, invalid qsize=%u
pci_nvme_err_invalid_create_sq_size failed creating submission queue, invalid qsize=%u
%d@%zu.%06zu:pci_nvme_err_invalid_create_sq_addr failed creating submission queue, addr=0x%lx
pci_nvme_err_invalid_create_sq_addr failed creating submission queue, addr=0x%lx
%d@%zu.%06zu:pci_nvme_err_invalid_create_sq_qflags failed creating submission queue, qflags=%u
pci_nvme_err_invalid_create_sq_qflags failed creating submission queue, qflags=%u
ns->nr_open_zones <= ns->params.max_open_zones
%d@%zu.%06zu:pci_nvme_update_cq_head cqid %u new_head %u
pci_nvme_update_cq_head cqid %u new_head %u
%d@%zu.%06zu:pci_nvme_update_sq_tail sqid %u new_tail %u
pci_nvme_update_sq_tail sqid %u new_tail %u
%d@%zu.%06zu:pci_nvme_err_zone_is_offline zslba 0x%lx
pci_nvme_err_zone_is_offline zslba 0x%lx
%d@%zu.%06zu:pci_nvme_err_zone_is_full zslba 0x%lx
pci_nvme_err_zone_is_full zslba 0x%lx
%d@%zu.%06zu:pci_nvme_err_zone_is_read_only zslba 0x%lx
pci_nvme_err_zone_is_read_only zslba 0x%lx
%d@%zu.%06zu:pci_nvme_err_zone_invalid_write lba 0x%lx wp 0x%lx
pci_nvme_err_zone_invalid_write lba 0x%lx wp 0x%lx
%d@%zu.%06zu:pci_nvme_err_write_not_at_wp writing at slba=%lu, zone=%lu, but wp=%lu
pci_nvme_err_write_not_at_wp writing at slba=%lu, zone=%lu, but wp=%lu
%d@%zu.%06zu:pci_nvme_err_zone_boundary lba 0x%lx nlb %u zcap 0x%lx
pci_nvme_err_zone_boundary lba 0x%lx nlb %u zcap 0x%lx
%d@%zu.%06zu:pci_nvme_update_cq_eventidx cqid %u new_eventidx %u
pci_nvme_update_cq_eventidx cqid %u new_eventidx %u
%d@%zu.%06zu:pci_nvme_err_addr_write addr 0x%lx
pci_nvme_err_addr_write addr 0x%lx
%d@%zu.%06zu:pci_nvme_err_cfs controller fatal status
pci_nvme_err_cfs controller fatal status
%d@%zu.%06zu:pci_nvme_irq_msix raising MSI-X IRQ vector %u
pci_nvme_irq_msix raising MSI-X IRQ vector %u
%d@%zu.%06zu:pci_nvme_irq_pin pulsing IRQ pin
pci_nvme_irq_pin pulsing IRQ pin
%d@%zu.%06zu:pci_nvme_irq_masked IRQ is masked
pci_nvme_irq_masked IRQ is masked
%d@%zu.%06zu:pci_nvme_del_sq deleting submission queue sqid=%u
pci_nvme_del_sq deleting submission queue sqid=%u
%d@%zu.%06zu:pci_nvme_err_invalid_del_sq invalid submission queue deletion, sid=%u
pci_nvme_err_invalid_del_sq invalid submission queue deletion, sid=%u
%d@%zu.%06zu:pci_nvme_dsm_deallocate slba %lu nlb %u
pci_nvme_dsm_deallocate slba %lu nlb %u
%d@%zu.%06zu:pci_nvme_dsm_single_range_limit_exceeded nlb %u dmrsl %u
pci_nvme_dsm_single_range_limit_exceeded nlb %u dmrsl %u
%d@%zu.%06zu:pci_nvme_err_invalid_lba_range Invalid LBA start=%lu len=%lu limit=%lu
pci_nvme_err_invalid_lba_range Invalid LBA start=%lu len=%lu limit=%lu
%d@%zu.%06zu:pci_nvme_err_invalid_dma PRP/SGL is too small for transfer size
pci_nvme_err_invalid_dma PRP/SGL is too small for transfer size
%d@%zu.%06zu:pci_nvme_pci_reset PCI Function Level Reset
pci_nvme_pci_reset PCI Function Level Reset
num_queues is deprecated; please use max_ioqpairs instead
subsystem support is unavailable with legacy namespace ('drive' property)
max_ioqpairs must be between 1 and %d
msix_qsize must be between 1 and %d
mqes property cannot be less than 1
not enough BARs available to enable PMR
pmr backend size needs to be power of 2 in size
zoned.zasl (Zone Append Size Limit) must be less than or equal to mdts (Maximum Data Transfer Size)
subsystem is required for the use of SR-IOV
CMB is not supported with SR-IOV
PMR is not supported with SR-IOV
both sriov_vq_flexible and sriov_vi_flexible must be set for the use of SR-IOV
sriov_vq_flexible must be greater than or equal to %d (sriov_max_vfs * 2)
(max_ioqpairs - sriov_vq_flexible) must be greater than or equal to 2
sriov_vi_flexible must be greater than or equal to %d (sriov_max_vfs)
(msix_qsize - sriov_vi_flexible) must be greater than or equal to 1
sriov_max_vq_per_vf must meet: (sriov_max_vq_per_vf - 1) %% %d == 0 and sriov_max_vq_per_vf >= 2
%d@%zu.%06zu:pci_nvme_misc_cb cid %u
%d@%zu.%06zu:pci_nvme_err_aio cid %u err '%s' status 0x%x
pci_nvme_err_aio cid %u err '%s' status 0x%x
%d@%zu.%06zu:pci_nvme_err_invalid_opc invalid opcode 0x%x
pci_nvme_err_invalid_opc invalid opcode 0x%x
%d@%zu.%06zu:pci_nvme_mmio_read addr 0x%lx size %d
pci_nvme_mmio_read addr 0x%lx size %d
%d@%zu.%06zu:pci_nvme_ub_mmiord_misaligned32 MMIO read not 32-bit aligned, offset=0x%lx
pci_nvme_ub_mmiord_misaligned32 MMIO read not 32-bit aligned, offset=0x%lx
pci_nvme_ub_mmiord_misaligned32 in %s: MMIO read not 32-bit aligned, offset=0x%lx
%d@%zu.%06zu:pci_nvme_ub_mmiord_toosmall MMIO read smaller than 32-bits, offset=0x%lx
pci_nvme_ub_mmiord_toosmall MMIO read smaller than 32-bits, offset=0x%lx
pci_nvme_ub_mmiord_toosmall in %s: MMIO read smaller than 32-bits, offset=0x%lx
%d@%zu.%06zu:pci_nvme_ub_mmiord_invalid_ofs MMIO read beyond last register, offset=0x%lx, returning 0
pci_nvme_ub_mmiord_invalid_ofs MMIO read beyond last register, offset=0x%lx, returning 0
pci_nvme_ub_mmiord_invalid_ofs in %s: MMIO read beyond last register, offset=0x%lx, returning 0
%d@%zu.%06zu:pci_nvme_err_ignored_mmio_vf_offline addr 0x%lx size %d
pci_nvme_err_ignored_mmio_vf_offline addr 0x%lx size %d
%d@%zu.%06zu:pci_nvme_rw_complete_cb cid %u blk '%s'
pci_nvme_rw_complete_cb cid %u blk '%s'
%d@%zu.%06zu:pci_nvme_zoned_zrwa_implicit_flush zslba 0x%lx nlb %u
pci_nvme_zoned_zrwa_implicit_flush zslba 0x%lx nlb %u
%d@%zu.%06zu:pci_nvme_verify_cb cid %u prinfo 0x%x apptag 0x%x appmask 0x%x reftag 0x%x
pci_nvme_verify_cb cid %u prinfo 0x%x apptag 0x%x appmask 0x%x reftag 0x%x
%d@%zu.%06zu:pci_nvme_verify_mdata_in_cb cid %u blk '%s'
pci_nvme_verify_mdata_in_cb cid %u blk '%s'
%d@%zu.%06zu:pci_nvme_map_addr addr 0x%lx len %lu
pci_nvme_map_addr addr 0x%lx len %lu
%d@%zu.%06zu:pci_nvme_map_addr_cmb addr 0x%lx len %lu
pci_nvme_map_addr_cmb addr 0x%lx len %lu
%d@%zu.%06zu:pci_nvme_ub_too_many_mappings too many prp/sgl mappings
pci_nvme_ub_too_many_mappings too many prp/sgl mappings
pci_nvme_ub_too_many_mappings in %s: number of mappings exceed 1024
%d@%zu.%06zu:pci_nvme_err_invalid_sgl_excess_length residual %u
pci_nvme_err_invalid_sgl_excess_length residual %u
%d@%zu.%06zu:pci_nvme_map_prp trans_len %lu len %u prp1 0x%lx prp2 0x%lx num_prps %d
pci_nvme_map_prp trans_len %lu len %u prp1 0x%lx prp2 0x%lx num_prps %d
%d@%zu.%06zu:pci_nvme_err_addr_read addr 0x%lx
pci_nvme_err_addr_read addr 0x%lx
%d@%zu.%06zu:pci_nvme_err_invalid_prplist_ent PRP list entry is not page aligned: 0x%lx
pci_nvme_err_invalid_prplist_ent PRP list entry is not page aligned: 0x%lx
%d@%zu.%06zu:pci_nvme_err_invalid_prp2_align PRP2 is not page aligned: 0x%lx
pci_nvme_err_invalid_prp2_align PRP2 is not page aligned: 0x%lx
%d@%zu.%06zu:pci_nvme_mmio_write addr 0x%lx data 0x%lx size %d
pci_nvme_mmio_write addr 0x%lx data 0x%lx size %d
%d@%zu.%06zu:pci_nvme_ub_mmiowr_misaligned32 MMIO write not 32-bit aligned, offset=0x%lx
pci_nvme_ub_mmiowr_misaligned32 MMIO write not 32-bit aligned, offset=0x%lx
pci_nvme_ub_mmiowr_misaligned32 in %s: MMIO write not 32-bit aligned, offset=0x%lx
%d@%zu.%06zu:pci_nvme_ub_mmiowr_toosmall MMIO write smaller than 32 bits, offset=0x%lx, size=%u
pci_nvme_ub_mmiowr_toosmall MMIO write smaller than 32 bits, offset=0x%lx, size=%u
pci_nvme_ub_mmiowr_toosmall in %s: MMIO write smaller than 32-bits, offset=0x%lx, size=%u
%d@%zu.%06zu:pci_nvme_ub_mmiowr_intmask_with_msix undefined access to interrupt mask set when MSI-X is enabled
pci_nvme_ub_mmiowr_intmask_with_msix undefined access to interrupt mask set when MSI-X is enabled
pci_nvme_ub_mmiowr_intmask_with_msix in %s: undefined access to interrupt mask set when MSI-X is enabled
%d@%zu.%06zu:pci_nvme_mmio_intm_set wrote MMIO, interrupt mask set, data=0x%lx, new_mask=0x%lx
pci_nvme_mmio_intm_set wrote MMIO, interrupt mask set, data=0x%lx, new_mask=0x%lx
pci_nvme_ub_mmiowr_intmask_with_msix in %s: undefined access to interrupt mask clr when MSI-X is enabled
%d@%zu.%06zu:pci_nvme_mmio_intm_clr wrote MMIO, interrupt mask clr, data=0x%lx, new_mask=0x%lx
pci_nvme_mmio_intm_clr wrote MMIO, interrupt mask clr, data=0x%lx, new_mask=0x%lx
%d@%zu.%06zu:pci_nvme_mmio_cfg wrote MMIO, config controller config=0x%lx
pci_nvme_mmio_cfg wrote MMIO, config controller config=0x%lx
%d@%zu.%06zu:pci_nvme_mmio_shutdown_set shutdown bit set
pci_nvme_mmio_shutdown_set shutdown bit set
%d@%zu.%06zu:pci_nvme_mmio_shutdown_cleared shutdown bit cleared
pci_nvme_mmio_shutdown_cleared shutdown bit cleared
%d@%zu.%06zu:pci_nvme_err_startfail_virt_state nvme_start_ctrl failed due to ctrl state: vi=%u vq=%u
pci_nvme_err_startfail_virt_state nvme_start_ctrl failed due to ctrl state: vi=%u vq=%u
%d@%zu.%06zu:pci_nvme_err_startfail_cq nvme_start_ctrl failed because there are non-admin completion queues
pci_nvme_err_startfail_cq nvme_start_ctrl failed because there are non-admin completion queues
%d@%zu.%06zu:pci_nvme_err_startfail_sq nvme_start_ctrl failed because there are non-admin submission queues
pci_nvme_err_startfail_sq nvme_start_ctrl failed because there are non-admin submission queues
%d@%zu.%06zu:pci_nvme_err_startfail_asq_misaligned nvme_start_ctrl failed because the admin submission queue address is misaligned: 0x%lx
pci_nvme_err_startfail_asq_misaligned nvme_start_ctrl failed because the admin submission queue address is misaligned: 0x%lx
%d@%zu.%06zu:pci_nvme_err_startfail_acq_misaligned nvme_start_ctrl failed because the admin completion queue address is misaligned: 0x%lx
pci_nvme_err_startfail_acq_misaligned nvme_start_ctrl failed because the admin completion queue address is misaligned: 0x%lx
%d@%zu.%06zu:pci_nvme_err_startfail_css nvme_start_ctrl failed because invalid command set selected:%u
pci_nvme_err_startfail_css nvme_start_ctrl failed because invalid command set selected:%u
%d@%zu.%06zu:pci_nvme_err_startfail_page_too_small nvme_start_ctrl failed because the page size is too small: log2size=%u, min=%u
pci_nvme_err_startfail_page_too_small nvme_start_ctrl failed because the page size is too small: log2size=%u, min=%u
%d@%zu.%06zu:pci_nvme_err_startfail_page_too_large nvme_start_ctrl failed because the page size is too large: log2size=%u, max=%u
pci_nvme_err_startfail_page_too_large nvme_start_ctrl failed because the page size is too large: log2size=%u, max=%u
%d@%zu.%06zu:pci_nvme_err_startfail_asqent_sz_zero nvme_start_ctrl failed because the admin submission queue size is zero
pci_nvme_err_startfail_asqent_sz_zero nvme_start_ctrl failed because the admin submission queue size is zero
%d@%zu.%06zu:pci_nvme_err_startfail_acqent_sz_zero nvme_start_ctrl failed because the admin completion queue size is zero
pci_nvme_err_startfail_acqent_sz_zero nvme_start_ctrl failed because the admin completion queue size is zero
%d@%zu.%06zu:pci_nvme_setfeat_timestamp set feature timestamp = 0x%lx
pci_nvme_setfeat_timestamp set feature timestamp = 0x%lx
%d@%zu.%06zu:pci_nvme_err_startfail setting controller enable bit failed
pci_nvme_err_startfail setting controller enable bit failed
%d@%zu.%06zu:pci_nvme_mmio_start_success setting controller enable bit succeeded
pci_nvme_mmio_start_success setting controller enable bit succeeded
%d@%zu.%06zu:pci_nvme_mmio_stopped cleared controller enable bit
pci_nvme_mmio_stopped cleared controller enable bit
%d@%zu.%06zu:pci_nvme_ub_mmiowr_ssreset_w1c_unsupported attempted to W1C CSTS.NSSRO but CAP.NSSRS is zero (not supported)
pci_nvme_ub_mmiowr_ssreset_w1c_unsupported attempted to W1C CSTS.NSSRO but CAP.NSSRS is zero (not supported)
pci_nvme_ub_mmiowr_ssreset_w1c_unsupported in %s: attempted to W1C CSTS.NSSRO but CAP.NSSRS is zero (not supported)
%d@%zu.%06zu:pci_nvme_ub_mmiowr_ro_csts attempted to set a read only bit of controller status
pci_nvme_ub_mmiowr_ro_csts attempted to set a read only bit of controller status
pci_nvme_ub_mmiowr_ro_csts in %s: attempted to set a read only bit of controller status
%d@%zu.%06zu:pci_nvme_ub_mmiowr_ssreset_unsupported attempted NVM subsystem reset but CAP.NSSRS is zero (not supported)
pci_nvme_ub_mmiowr_ssreset_unsupported attempted NVM subsystem reset but CAP.NSSRS is zero (not supported)
%d@%zu.%06zu:pci_nvme_mmio_aqattr wrote MMIO, admin queue attributes=0x%lx
pci_nvme_mmio_aqattr wrote MMIO, admin queue attributes=0x%lx
%d@%zu.%06zu:pci_nvme_mmio_asqaddr wrote MMIO, admin submission queue address=0x%lx
pci_nvme_mmio_asqaddr wrote MMIO, admin submission queue address=0x%lx
%d@%zu.%06zu:pci_nvme_mmio_asqaddr_hi wrote MMIO, admin submission queue high half=0x%lx, new_address=0x%lx
pci_nvme_mmio_asqaddr_hi wrote MMIO, admin submission queue high half=0x%lx, new_address=0x%lx
%d@%zu.%06zu:pci_nvme_mmio_acqaddr wrote MMIO, admin completion queue address=0x%lx
pci_nvme_mmio_acqaddr wrote MMIO, admin completion queue address=0x%lx
%d@%zu.%06zu:pci_nvme_mmio_acqaddr_hi wrote MMIO, admin completion queue high half=0x%lx, new_address=0x%lx
pci_nvme_mmio_acqaddr_hi wrote MMIO, admin completion queue high half=0x%lx, new_address=0x%lx
%d@%zu.%06zu:pci_nvme_ub_mmiowr_cmbloc_reserved invalid write to reserved CMBLOC when CMBSZ is zero, ignored
pci_nvme_ub_mmiowr_cmbloc_reserved invalid write to reserved CMBLOC when CMBSZ is zero, ignored
pci_nvme_ub_mmiowr_cmbloc_reserved in %s: invalid write to reserved CMBLOC when CMBSZ is zero, ignored
%d@%zu.%06zu:pci_nvme_ub_mmiowr_cmbsz_readonly invalid write to read only CMBSZ, ignored
pci_nvme_ub_mmiowr_cmbsz_readonly invalid write to read only CMBSZ, ignored
pci_nvme_ub_mmiowr_cmbsz_readonly in %s: invalid write to read only CMBSZ, ignored
%d@%zu.%06zu:pci_nvme_ub_mmiowr_pmrcap_readonly invalid write to read only PMRCAP, ignored
pci_nvme_ub_mmiowr_pmrcap_readonly invalid write to read only PMRCAP, ignored
pci_nvme_ub_mmiowr_pmrcap_readonly in %s: invalid write to PMRCAP register, ignored
%d@%zu.%06zu:pci_nvme_ub_mmiowr_pmrsts_readonly invalid write to read only PMRSTS, ignored
pci_nvme_ub_mmiowr_pmrsts_readonly invalid write to read only PMRSTS, ignored
pci_nvme_ub_mmiowr_pmrsts_readonly in %s: invalid write to PMRSTS register, ignored
%d@%zu.%06zu:pci_nvme_ub_mmiowr_pmrebs_readonly invalid write to read only PMREBS, ignored
pci_nvme_ub_mmiowr_pmrebs_readonly invalid write to read only PMREBS, ignored
pci_nvme_ub_mmiowr_pmrebs_readonly in %s: invalid write to PMREBS register, ignored
%d@%zu.%06zu:pci_nvme_ub_mmiowr_pmrswtp_readonly invalid write to read only PMRSWTP, ignored
pci_nvme_ub_mmiowr_pmrswtp_readonly invalid write to read only PMRSWTP, ignored
pci_nvme_ub_mmiowr_pmrswtp_readonly in %s: invalid write to PMRSWTP register, ignored
%d@%zu.%06zu:pci_nvme_ub_mmiowr_invalid invalid MMIO write, offset=0x%lx, data=0x%lx
pci_nvme_ub_mmiowr_invalid invalid MMIO write, offset=0x%lx, data=0x%lx
pci_nvme_ub_mmiowr_invalid in %s: invalid MMIO write, offset=0x%lx, data=%lx
%d@%zu.%06zu:pci_nvme_ub_db_wr_misaligned doorbell write not 32-bit aligned, offset=0x%lx, ignoring
pci_nvme_ub_db_wr_misaligned doorbell write not 32-bit aligned, offset=0x%lx, ignoring
pci_nvme_ub_db_wr_misaligned in %s: doorbell write not 32-bit aligned, offset=0x%lx, ignoring
%d@%zu.%06zu:pci_nvme_ub_db_wr_invalid_cq completion queue doorbell write for nonexistent queue, cqid=%u, ignoring
pci_nvme_ub_db_wr_invalid_cq completion queue doorbell write for nonexistent queue, cqid=%u, ignoring
pci_nvme_ub_db_wr_invalid_cq in %s: completion queue doorbell write for nonexistent queue, sqid=%u, ignoring
%d@%zu.%06zu:pci_nvme_ub_db_wr_invalid_cqhead completion queue doorbell write value beyond queue size, cqid=%u, new_head=%u, ignoring
pci_nvme_ub_db_wr_invalid_cqhead completion queue doorbell write value beyond queue size, cqid=%u, new_head=%u, ignoring
pci_nvme_ub_db_wr_invalid_cqhead in %s: completion queue doorbell write value beyond queue size, sqid=%u, new_head=%u, ignoring
%d@%zu.%06zu:pci_nvme_mmio_doorbell_cq cqid %u new_head %u
pci_nvme_mmio_doorbell_cq cqid %u new_head %u
%d@%zu.%06zu:pci_nvme_ub_db_wr_invalid_sq submission queue doorbell write for nonexistent queue, sqid=%u, ignoring
pci_nvme_ub_db_wr_invalid_sq submission queue doorbell write for nonexistent queue, sqid=%u, ignoring
pci_nvme_ub_db_wr_invalid_sq in %s: submission queue doorbell write for nonexistent queue, sqid=%u, ignoring
%d@%zu.%06zu:pci_nvme_ub_db_wr_invalid_sqtail submission queue doorbell write value beyond queue size, sqid=%u, new_head=%u, ignoring
pci_nvme_ub_db_wr_invalid_sqtail submission queue doorbell write value beyond queue size, sqid=%u, new_head=%u, ignoring
pci_nvme_ub_db_wr_invalid_sqtail in %s: submission queue doorbell write value beyond queue size, sqid=%u, new_tail=%u, ignoring
%d@%zu.%06zu:pci_nvme_mmio_doorbell_sq sqid %u new_tail %u
pci_nvme_mmio_doorbell_sq sqid %u new_tail %u
%d@%zu.%06zu:pci_nvme_map_sgl type 0x%x len %lu
pci_nvme_map_sgl type 0x%x len %lu
%d@%zu.%06zu:pci_nvme_identify_cmd_set identify i/o command set
pci_nvme_identify_cmd_set identify i/o command set
%d@%zu.%06zu:pci_nvme_identify_sec_ctrl_list identify secondary controller list cntlid=%u numcntl=%u
pci_nvme_identify_sec_ctrl_list identify secondary controller list cntlid=%u numcntl=%u
%d@%zu.%06zu:pci_nvme_err_invalid_log_page_offset must be <= %lu, got %lu
pci_nvme_err_invalid_log_page_offset must be <= %lu, got %lu
%d@%zu.%06zu:pci_nvme_identify_nslist nsid %u
pci_nvme_identify_nslist nsid %u
%d@%zu.%06zu:pci_nvme_identify_ctrl_csi identify controller, csi=0x%x
pci_nvme_identify_ctrl_csi identify controller, csi=0x%x
%d@%zu.%06zu:pci_nvme_identify_ns_ind nsid %u
pci_nvme_identify_ns_ind nsid %u
%d@%zu.%06zu:pci_nvme_identify_ctrl_list cns 0x%x cntid %u
pci_nvme_identify_ctrl_list cns 0x%x cntid %u
%d@%zu.%06zu:pci_nvme_identify_nslist_csi nsid=%u, csi=0x%x
pci_nvme_identify_nslist_csi nsid=%u, csi=0x%x
%d@%zu.%06zu:pci_nvme_identify_ns_descr_list nsid %u
pci_nvme_identify_ns_descr_list nsid %u
%d@%zu.%06zu:pci_nvme_identify_ns nsid %u
%d@%zu.%06zu:pci_nvme_identify_ns_csi nsid=%u, csi=0x%x
pci_nvme_identify_ns_csi nsid=%u, csi=0x%x
%d@%zu.%06zu:pci_nvme_copy_source_range slba 0x%lx nlb %u
pci_nvme_copy_source_range slba 0x%lx nlb %u
%d@%zu.%06zu:pci_nvme_copy_out slba 0x%lx nlb %u
pci_nvme_copy_out slba 0x%lx nlb %u
%d@%zu.%06zu:pci_nvme_rw_cb cid %u blk '%s'
pci_nvme_rw_cb cid %u blk '%s'
%d@%zu.%06zu:pci_nvme_write cid %u opname '%s' nsid %u nlb %u count %lu lba 0x%lx
pci_nvme_write cid %u opname '%s' nsid %u nlb %u count %lu lba 0x%lx
%d@%zu.%06zu:pci_nvme_err_mdts len %zu
%d@%zu.%06zu:pci_nvme_err_append_not_at_start appending at slba=%lu, but zone=%lu
pci_nvme_err_append_not_at_start appending at slba=%lu, but zone=%lu
%d@%zu.%06zu:pci_nvme_err_zasl len %zu
%d@%zu.%06zu:pci_nvme_ns_attachment cid %u, sel=0x%x
pci_nvme_ns_attachment cid %u, sel=0x%x
%d@%zu.%06zu:pci_nvme_read cid %u nsid %u nlb %u count %lu lba 0x%lx
pci_nvme_read cid %u nsid %u nlb %u count %lu lba 0x%lx
%d@%zu.%06zu:pci_nvme_err_zone_read_not_ok slba=%lu, nlb=%u, status=0x%x
pci_nvme_err_zone_read_not_ok slba=%lu, nlb=%u, status=0x%x
%d@%zu.%06zu:pci_nvme_compare cid %u nsid %u slba 0x%lx nlb %u
pci_nvme_compare cid %u nsid %u slba 0x%lx nlb %u
%d@%zu.%06zu:pci_nvme_dsm nr %u attr 0x%x
%d@%zu.%06zu:pci_nvme_verify cid %u nsid %u slba 0x%lx nlb %u
pci_nvme_verify cid %u nsid %u slba 0x%lx nlb %u
%d@%zu.%06zu:pci_nvme_copy cid %u nsid %u nr %u format 0x%x
pci_nvme_copy cid %u nsid %u nr %u format 0x%x
%d@%zu.%06zu:pci_nvme_err_copy_invalid_format format 0x%x
pci_nvme_err_copy_invalid_format format 0x%x
%d@%zu.%06zu:pci_nvme_io_cmd cid %u nsid 0x%x sqid %u opc 0x%x opname '%s'
pci_nvme_io_cmd cid %u nsid 0x%x sqid %u opc 0x%x opname '%s'
%d@%zu.%06zu:pci_nvme_err_unaligned_zone_cmd unaligned zone op 0x%x, got slba=%lu, zslba=%lu
pci_nvme_err_unaligned_zone_cmd unaligned zone op 0x%x, got slba=%lu, zslba=%lu
%d@%zu.%06zu:pci_nvme_open_zone open zone, slba=%lu, idx=%u, all=%i
pci_nvme_open_zone open zone, slba=%lu, idx=%u, all=%i
%d@%zu.%06zu:pci_nvme_close_zone close zone, slba=%lu, idx=%u, all=%i
pci_nvme_close_zone close zone, slba=%lu, idx=%u, all=%i
%d@%zu.%06zu:pci_nvme_finish_zone finish zone, slba=%lu, idx=%u, all=%i
pci_nvme_finish_zone finish zone, slba=%lu, idx=%u, all=%i
%d@%zu.%06zu:pci_nvme_reset_zone reset zone, slba=%lu, idx=%u, all=%i
pci_nvme_reset_zone reset zone, slba=%lu, idx=%u, all=%i
%d@%zu.%06zu:pci_nvme_offline_zone offline zone, slba=%lu, idx=%u, all=%i
pci_nvme_offline_zone offline zone, slba=%lu, idx=%u, all=%i
%d@%zu.%06zu:pci_nvme_set_descriptor_extension set zone descriptor extension, slba=%lu, idx=%u
pci_nvme_set_descriptor_extension set zone descriptor extension, slba=%lu, idx=%u
%d@%zu.%06zu:pci_nvme_err_zd_extension_map_error can't map descriptor extension for zone_idx=%u
pci_nvme_err_zd_extension_map_error can't map descriptor extension for zone_idx=%u
%d@%zu.%06zu:pci_nvme_zd_extension_set set descriptor extension for zone_idx=%u
pci_nvme_zd_extension_set set descriptor extension for zone_idx=%u
%d@%zu.%06zu:pci_nvme_err_invalid_mgmt_action action=0x%x
pci_nvme_err_invalid_mgmt_action action=0x%x
%d@%zu.%06zu:pci_nvme_err_invalid_zone_state_transition action=0x%x, slba=%lu, attrs=0x%x
pci_nvme_err_invalid_zone_state_transition action=0x%x, slba=%lu, attrs=0x%x
%d@%zu.%06zu:pci_nvme_get_log cid %u lid 0x%x lsp 0x%x rae 0x%x len %u off %lu
pci_nvme_get_log cid %u lid 0x%x lsp 0x%x rae 0x%x len %u off %lu
%d@%zu.%06zu:pci_nvme_err_invalid_log_page cid %u lid 0x%x
pci_nvme_err_invalid_log_page cid %u lid 0x%x
%d@%zu.%06zu:pci_nvme_admin_cmd cid %u sqid %u opc 0x%x opname '%s'
pci_nvme_admin_cmd cid %u sqid %u opc 0x%x opname '%s'
%d@%zu.%06zu:pci_nvme_err_invalid_admin_opc invalid admin opcode 0x%x
pci_nvme_err_invalid_admin_opc invalid admin opcode 0x%x
%d@%zu.%06zu:pci_nvme_err_invalid_del_cq_cqid failed deleting completion queue, cqid=%u
pci_nvme_err_invalid_del_cq_cqid failed deleting completion queue, cqid=%u
%d@%zu.%06zu:pci_nvme_err_invalid_del_cq_notempty failed deleting completion queue, it is not empty, cqid=%u
pci_nvme_err_invalid_del_cq_notempty failed deleting completion queue, it is not empty, cqid=%u
%d@%zu.%06zu:pci_nvme_del_cq deleted completion queue, cqid=%u
pci_nvme_del_cq deleted completion queue, cqid=%u
%d@%zu.%06zu:pci_nvme_create_cq create completion queue, addr=0x%lx, cqid=%u, vector=%u, qsize=%u, qflags=%u, ien=%d
pci_nvme_create_cq create completion queue, addr=0x%lx, cqid=%u, vector=%u, qsize=%u, qflags=%u, ien=%d
%d@%zu.%06zu:pci_nvme_err_invalid_create_cq_entry_size iosqes %u iocqes %u
pci_nvme_err_invalid_create_cq_entry_size iosqes %u iocqes %u
%d@%zu.%06zu:pci_nvme_err_invalid_create_cq_cqid failed creating completion queue, cqid=%u
pci_nvme_err_invalid_create_cq_cqid failed creating completion queue, cqid=%u
%d@%zu.%06zu:pci_nvme_err_invalid_create_cq_size failed creating completion queue, size=%u
pci_nvme_err_invalid_create_cq_size failed creating completion queue, size=%u
%d@%zu.%06zu:pci_nvme_err_invalid_create_cq_addr failed creating completion queue, addr=0x%lx
pci_nvme_err_invalid_create_cq_addr failed creating completion queue, addr=0x%lx
%d@%zu.%06zu:pci_nvme_err_invalid_create_cq_vector failed creating completion queue, vector=%u
pci_nvme_err_invalid_create_cq_vector failed creating completion queue, vector=%u
%d@%zu.%06zu:pci_nvme_err_invalid_create_cq_qflags failed creating completion queue, qflags=%u
pci_nvme_err_invalid_create_cq_qflags failed creating completion queue, qflags=%u
%d@%zu.%06zu:pci_nvme_identify cid %u cns 0x%x ctrlid %u csi 0x%x
pci_nvme_identify cid %u cns 0x%x ctrlid %u csi 0x%x
%d@%zu.%06zu:pci_nvme_identify_pri_ctrl_cap identify primary controller capabilities cntlid=%u
pci_nvme_identify_pri_ctrl_cap identify primary controller capabilities cntlid=%u
%d@%zu.%06zu:pci_nvme_identify_ctrl identify controller
pci_nvme_identify_ctrl identify controller
%d@%zu.%06zu:pci_nvme_err_invalid_identify_cns identify, invalid cns=0x%x
pci_nvme_err_invalid_identify_cns identify, invalid cns=0x%x
%d@%zu.%06zu:pci_nvme_setfeat cid %u nsid 0x%x fid 0x%x save 0x%x cdw11 0x%x
pci_nvme_setfeat cid %u nsid 0x%x fid 0x%x save 0x%x cdw11 0x%x
%d@%zu.%06zu:pci_nvme_setfeat_numq requested cq_count=%d sq_count=%d, responding with cq_count=%d sq_count=%d
pci_nvme_setfeat_numq requested cq_count=%d sq_count=%d, responding with cq_count=%d sq_count=%d
%d@%zu.%06zu:pci_nvme_err_invalid_iocsci unsupported command set combination index %u
pci_nvme_err_invalid_iocsci unsupported command set combination index %u
%d@%zu.%06zu:pci_nvme_getfeat cid %u nsid 0x%x fid 0x%x sel 0x%x cdw11 0x%x
pci_nvme_getfeat cid %u nsid 0x%x fid 0x%x sel 0x%x cdw11 0x%x
%d@%zu.%06zu:pci_nvme_getfeat_vwcache get feature volatile write cache, result=%s
pci_nvme_getfeat_vwcache get feature volatile write cache, result=%s
%d@%zu.%06zu:pci_nvme_getfeat_numq get feature number of queues, result=%d
pci_nvme_getfeat_numq get feature number of queues, result=%d
%d@%zu.%06zu:pci_nvme_aer cid %u
%d@%zu.%06zu:pci_nvme_aer_aerl_exceeded aerl exceeded
pci_nvme_aer_aerl_exceeded aerl exceeded
%d@%zu.%06zu:pci_nvme_virt_mngmt cid %u, act=0x%x, ctrlid=%u %s nr=%u
pci_nvme_virt_mngmt cid %u, act=0x%x, ctrlid=%u %s nr=%u
%d@%zu.%06zu:pci_nvme_dbbuf_config dbs_addr=0x%lx eis_addr=0x%lx
pci_nvme_dbbuf_config dbs_addr=0x%lx eis_addr=0x%lx
%d@%zu.%06zu:pci_nvme_update_sq_eventidx sqid %u new_eventidx %u
pci_nvme_update_sq_eventidx sqid %u new_eventidx %u
%d@%zu.%06zu:pci_nvme_compare_data_cb cid %u
pci_nvme_compare_data_cb cid %u
%d@%zu.%06zu:pci_nvme_compare_mdata_cb cid %u
pci_nvme_compare_mdata_cb cid %u
%d@%zu.%06zu:pci_nvme_dif_rw_cb cid %u blk '%s'
pci_nvme_dif_rw_cb cid %u blk '%s'
%d@%zu.%06zu:pci_nvme_dif_rw_mdata_in_cb cid %u blk '%s'
pci_nvme_dif_rw_mdata_in_cb cid %u blk '%s'
%d@%zu.%06zu:pci_nvme_dif_rw_mdata_out_cb cid %u blk '%s'
pci_nvme_dif_rw_mdata_out_cb cid %u blk '%s'
%d@%zu.%06zu:pci_nvme_dif_pract_generate_dif_crc16 len %zu lba_size %zu chksum_len %zu apptag 0x%x reftag 0x%x
pci_nvme_dif_pract_generate_dif_crc16 len %zu lba_size %zu chksum_len %zu apptag 0x%x reftag 0x%x
%d@%zu.%06zu:pci_nvme_dif_pract_generate_dif_crc64 len %zu lba_size %zu chksum_len %zu apptag 0x%x reftag 0x%lx
pci_nvme_dif_pract_generate_dif_crc64 len %zu lba_size %zu chksum_len %zu apptag 0x%x reftag 0x%lx
%d@%zu.%06zu:pci_nvme_dif_check prinfo 0x%x chksum_len %u
pci_nvme_dif_check prinfo 0x%x chksum_len %u
%d@%zu.%06zu:pci_nvme_dif_prchk_disabled_crc16 apptag 0x%x reftag 0x%x
pci_nvme_dif_prchk_disabled_crc16 apptag 0x%x reftag 0x%x
%d@%zu.%06zu:pci_nvme_dif_prchk_guard_crc16 guard 0x%x crc 0x%x
pci_nvme_dif_prchk_guard_crc16 guard 0x%x crc 0x%x
%d@%zu.%06zu:pci_nvme_dif_prchk_apptag apptag 0x%x elbat 0x%x elbatm 0x%x
pci_nvme_dif_prchk_apptag apptag 0x%x elbat 0x%x elbatm 0x%x
%d@%zu.%06zu:pci_nvme_dif_prchk_reftag_crc16 reftag 0x%x elbrt 0x%x
pci_nvme_dif_prchk_reftag_crc16 reftag 0x%x elbrt 0x%x
%d@%zu.%06zu:pci_nvme_dif_prchk_disabled_crc64 apptag 0x%x reftag 0x%lx
pci_nvme_dif_prchk_disabled_crc64 apptag 0x%x reftag 0x%lx
%d@%zu.%06zu:pci_nvme_dif_prchk_guard_crc64 guard 0x%lx crc 0x%lx
pci_nvme_dif_prchk_guard_crc64 guard 0x%lx crc 0x%lx
%d@%zu.%06zu:pci_nvme_dif_prchk_reftag_crc64 reftag 0x%lx elbrt 0x%lx
pci_nvme_dif_prchk_reftag_crc64 reftag 0x%lx elbrt 0x%lx
%d@%zu.%06zu:pci_nvme_dif_rw_check_cb cid %u prinfo 0x%x apptag 0x%x appmask 0x%x reftag 0x%x
pci_nvme_dif_rw_check_cb cid %u prinfo 0x%x apptag 0x%x appmask 0x%x reftag 0x%x
%d@%zu.%06zu:pci_nvme_dif_rw pract 0x%x prinfo 0x%x
pci_nvme_dif_rw pract 0x%x prinfo 0x%x
%d@%zu.%06zu:pci_nvme_clear_ns_close zone state=%u, slba=%lu transitioned to Closed state
pci_nvme_clear_ns_close zone state=%u, slba=%lu transitioned to Closed state
%d@%zu.%06zu:pci_nvme_clear_ns_reset zone state=%u, slba=%lu transitioned to Empty state
pci_nvme_clear_ns_reset zone state=%u, slba=%lu transitioned to Empty state
at least %u bytes of metadata required to enable protection information
invalid namespace id (must be between 0 and %d)
cannot be a zoned- in an FDP configuration
max_open_zones (%u) exceeds max_active_zones (%u)
zone descriptor extension size must be a multiple of 64B
zone descriptor extension size is too large
zone random write area size (zoned.zrwas %lu) must be a multiple of the logical block size (logical_block_size %u)
zone random write area size (zoned.zrwas %lu) must be a multiple of the zone random write area flush granularity (zoned.zrwafg, %lu)
number of zone random write area resources (zoned.numzrwa, %d) must be less than or equal to maximum active resources (zoned.max_active_zones, %d)
zone capacity %luB exceeds zone size %luB
zone size %luB too small, must be at least %zuB
zone capacity %luB too small, must be at least %zuB
insufficient drive capacity, must be at least the size of one zone (%luB)
the zone size (%lu blocks) is not a multiple of the calculated deallocation granularity (%d blocks); DULBE support disabled
no unused reclaim unit handles left
lba format index of controller assigned reclaim unit handle does not match namespace lba format index
cannot parse reclaim unit handle identifier
invalid reclaim unit handle identifier range
duplicate reclaim unit handle identifier: %u
invalid reclaim unit handle identifier
lba format index of host assignedreclaim unit handle does not match namespace lba format index
reclaim unit handle is controller assigned
namespace id '%d' already allocated
subsys->ctrls[cntlid] == SUBSYS_SLOT_RSVD
fdp.nruh must be non-zero and less than %u
cannot derive a valid rgif (nruh %u nrg %u)
no more free controller ids for secondary controllers
%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx
NGUID or "auto" for random value
key < fw_cfg_max_entry(s) && len < UINT32_MAX
s->entries[arch][key].data == NULL
"file_slots" must be at least 0x%x
"file_slots" must not exceed 0x%x
uint32_as_uint16 is only used for backward compatibility.
This functions shouldn't be called.
start >= 0 && length > 0 && length <= 64 - start
%d@%zu.%06zu:fw_cfg_select %p key 0x%04x '%s', ret: %d
fw_cfg_select %p key 0x%04x '%s', ret: %d
%d@%zu.%06zu:fw_cfg_read %p = 0x%lx
size > 0 && size <= sizeof(value)
%d@%zu.%06zu:fw_cfg_add_bytes key 0x%04x '%s', %zu bytes
fw_cfg_add_bytes key 0x%04x '%s', %zu bytes
%d@%zu.%06zu:fw_cfg_add_string key 0x%04x '%s', value '%s'
fw_cfg_add_string key 0x%04x '%s', value '%s'
%d@%zu.%06zu:fw_cfg_add_i16 key 0x%04x '%s', value 0x%x
fw_cfg_add_i16 key 0x%04x '%s', value 0x%x
%d@%zu.%06zu:fw_cfg_add_i32 key 0x%04x '%s', value 0x%x
fw_cfg_add_i32 key 0x%04x '%s', value 0x%x
%d@%zu.%06zu:fw_cfg_add_i64 key 0x%04x '%s', value 0x%lx
fw_cfg_add_i64 key 0x%04x '%s', value 0x%lx
Unknown firmware file in legacy mode: %s
duplicate fw_cfg file name: %s
%d@%zu.%06zu:fw_cfg_add_file %p #%d: %s (%zd bytes)
fw_cfg_add_file %p #%d: %s (%zd bytes)
splash-time is invalid,it should be a value between 0 and 65535
failed to read splash file '%s': %s
splash file '%s' format not recognized; must be JPEG or 24 bit BMP
reboot timeout is invalid,it should be a value between -1 and 65535
Object ID '%s' is not a '%s' subclass
uint16_from_uint8 is used only for backwards compatibility.
Never should be used to write a new state.
!"Unsupported EEPROM size, fallback to 64 words!"
x-do-not-expose-native-hotplug-cap
/home/virus/AMD/AMD/include/hw/pci/pcie_host.h
MSI is not supported by interrupt controller
!(nr_vectors & (nr_vectors - 1))
nr_vectors <= PCI_MSI_VECTORS_MAX
msi: vector %d not allocated. max vector is %d
addr + size <= dev->msix_entries_nr * PCI_MSIX_ENTRY_SIZE
PCI [%s:%02x:%02x.%x] attempt to write to MSI-X PBA at 0x%lx, ignoring.
%d@%zu.%06zu:msix_write_config dev %s enabled %d masked %d
msix_write_config dev %s enabled %d masked %d
MSI-X is not supported by interrupt controller
The number of MSI-X vectors is invalid
table & pba overlap, or they don't fit in BARs, or don't align
use_notifier && release_notifier
dev->msix_vector_use_notifier && dev->msix_vector_release_notifier
irq state %d: must be 0 or 1.
address + len <= pci_config_size(d)
Maximum buffer size allocated for bounce buffers used for mapped access to indirect DMA memory
size == pci_config_size(container_of(pv, PCIDevice, config))
%d@%zu.%06zu:pci_route_irq IRQ %d @%s -> IRQ %d @%s
pci_route_irq IRQ %d @%s -> IRQ %d @%s
0 <= irq_num && irq_num < PCI_NUM_PINS
Invalid PCI requester ID cache type: %d
0 <= devfn && devfn < PCI_DEVFN_MAX
hdr_type != PCI_HEADER_TYPE_BRIDGE || region_num < 2
memory_region_size(mem) == QEMU_PCI_VGA_MEM_SIZE
memory_region_size(io_lo) == QEMU_PCI_VGA_IO_LO_SIZE
memory_region_size(io_hi) == QEMU_PCI_VGA_IO_HI_SIZE
%d@%zu.%06zu:pci_update_mappings_del %s %02x:%02x.%x %d,0x%lx+0x%lx
pci_update_mappings_del %s %02x:%02x.%x %d,0x%lx+0x%lx
%d@%zu.%06zu:pci_update_mappings_add %s %02x:%02x.%x %d,0x%lx+0x%lx
pci_update_mappings_add %s %02x:%02x.%x %d,0x%lx+0x%lx
%s: Bad config data: i=0x%x read: %x device: %x cmask: %x wmask: %x w1cmask:%x
addr + l <= pci_config_size(d)
%d@%zu.%06zu:pci_pm_bad_transition %s %02x:%02x.%x REJECTED PM transition D%d->D%d
pci_pm_bad_transition %s %02x:%02x.%x REJECTED PM transition D%d->D%d
%d@%zu.%06zu:pci_pm_transition %s %02x:%02x.%x PM transition D%d->D%d
pci_pm_transition %s %02x:%02x.%x PM transition D%d->D%d
0 <= intx && intx < PCI_NUM_PINS
PCI: Bug - unimplemented PCI INTx routing (%s)
Invalid PCI device address %s for device %s
No support for non-zero PCI domains
pdev->config[PCI_STATUS] & PCI_STATUS_CAP_LIST
%s:%02x:%02x.%x Attempt to add PCI capability %x at offset %x overlaps existing capability %x at offset %x
acpi-index should be less or equal to %u
a PCI device with acpi-index = %u already exist
ROM size %u is not a power of two
PCI: Only PCI/PCIe bridges can be plugged into %s
PCI: no slot/function available for %s, all in use or reserved
PCI: slot %d function %d not available for %s, reserved
PCI: slot %d function %d not available for %s, in use by %s,id=%s
PCI: slot %d function 0 already occupied by %s, new func %s cannot be exposed to guest.
PCI: single function device can't be populated in function %x.%x
PCI: %x.0 indicates single function, but %x.%x is already populated.
PCI: slot %d is not valid for %s, parent device only allows plugging into slot 0.
failover primary device must be on PCIExpress bus
failover primary device is not an Ethernet device
failover: primary device must be in its own PCI slot
Hot-plugged device without ROM bar can't have an option ROM
romfile "%s" too large (size cannot exceed 2 GiB)
romfile "%s" (%u bytes) is too large for ROM size %u
QLIST_EMPTY(&s->sec_bus.child)
PCI resource reserve cap: PREF32 and PREF64 conflict
PCI resource reserve cap: mem-reserve must be less than 4G
PCI resource reserve cap: pref32-reserve  must be less than 4G
%d@%zu.%06zu:pci_cfg_write %s %02x:%02x.%x @0x%x <- 0x%x
pci_cfg_write %s %02x:%02x.%x @0x%x <- 0x%x
%d@%zu.%06zu:pci_cfg_read %s %02x:%02x.%x @0x%x -> 0x%x
pci_cfg_read %s %02x:%02x.%x @0x%x -> 0x%x
      PCI subsystem %04lx:%04lx
      IO range [0x%04lx, 0x%04lx]
      memory range [0x%08lx, 0x%08lx]
      prefetchable memory range [0x%08lx, 0x%08lx]
%d bit%s memory at 0x%08lx [0x%08lx]
%*sclass %s, addr %02x:%02x.%x, pci id %04x:%04x (sub %04x:%04x)
%*sbar %d: %s at 0x%lx [0x%lx]
device '%s' is not a PCIe device
invalid error status value '%s'
-c is only valid with numeric error status
OK id: %s root bus: %s, bus: %x devfn: %x.%x
%d@%zu.%06zu:sriov_register_vfs %s %02x:%x: creating %d vf devs
sriov_register_vfs %s %02x:%x: creating %d vf devs
%d@%zu.%06zu:sriov_unregister_vfs %s %02x:%x: Unregistering vf devs
sriov_unregister_vfs %s %02x:%x: Unregistering vf devs
%s: PCI region size must be a power of two - type=0x%x, size=0x%lx
%d@%zu.%06zu:sriov_config_write %s %02x:%x: sriov offset 0x%x val 0x%x len %d
sriov_config_write %s %02x:%x: sriov offset 0x%x val 0x%x len %d
%d@%zu.%06zu:shpc_slot_command %s[%d] > %s: pic: %s->%s, aic: %s->%s, state: %s->%s
shpc_slot_command %s[%d] > %s: pic: %s->%s, aic: %s->%s, state: %s->%s
Unsupported PCI slot %d for standard hotplug controller. Valid slots are between %d and %d.
Hot-unplug failed: guest is busy (power indicator blinking)
Bridge chassis not specified. Each bridge is required to be assigned a unique chassis id > 0.
next <= PCIE_CONFIG_SPACE_SIZE - 8
Hot-plug failed: unsupported by the port device '%s'
slot is electromechanically locked
Hot-unplug failed: unsupported by the port device '%s'
port_type == PCI_EXP_TYPE_DOWNSTREAM || port_type == PCI_EXP_TYPE_ROOT_PORT
%d@%zu.%06zu:pcie_cap_slot_write_config %s > %s: pds: %s, pic: %s->%s, aic: %s->%s, power: %s->%s
pcie_cap_slot_write_config %s > %s: pds: %s, pic: %s->%s, aic: %s->%s, power: %s->%s
offset >= PCI_CONFIG_SPACE_SIZE
offset < (uint16_t)(offset + size)
(uint16_t)(offset + size) <= PCIE_CONFIG_SPACE_SIZE
!(next & (PCI_EXT_CAP_ALIGN - 1))
is_downstream || (dev->cap_present & QEMU_PCI_CAP_MULTIFUNCTION) || PCI_FUNC(dev->devfn)
!(err->status & (err->status - 1))
!(err->flags & PCIE_AER_ERR_TLP_PREFIX_PRESENT)
Invalid aer_log_max %d. The max number of aer log is %d
doe_cap->protocol_num < PCI_DOE_PROTOCOL_NUM_MAX
../hw/pci-bridge/pci_bridge_dev.c
!local_err || bridge_dev->msi == ON_OFF_AUTO_AUTO
standard hotplug controller has been disabled for this %s
Standard PCI Bridge (multiseat)
Intel IOH device id 3420 PCIE Root Port
parent_obj.parent_obj.parent_obj
parent_obj.parent_obj.parent_obj.exp.aer_log
Can't add Root Port capability, error %d
Can't add chassis slot, error %d
../hw/pci-bridge/pcie_root_port.c
../hw/pci-bridge/gen_pcie_root_port.c
parent_obj.parent_obj.parent_obj.parent_obj
../hw/pci-bridge/pcie_pci_bridge.c
ACPI Unique ID used to distinguish this PCI Host Bridge / ACPI00016
../hw/pci-bridge/pci_expander_bridge.c
PXB devices can be attached only to root bus
pxb-cxl devices cannot reside on a PCI bus
pxb-pcie devices cannot reside on a PCI bus
pxb devices cannot reside on a PCIe bus
Insufficient space for pxb cxl host register space
../hw/pci-bridge/xio3130_upstream.c
TI X3130 Upstream Port of PCI Express Switch
parent_obj.parent_obj.exp.aer_log
../hw/pci-bridge/xio3130_downstream.c
TI X3130 Downstream Port of PCI Express Switch
xio3130-express-downstream-port
../hw/pci-bridge/cxl_root_port.c
SBR mask control is not supported
Alt Memory & ID space is not supported
../hw/pci-bridge/cxl_upstream.c
../hw/pci-bridge/cxl_downstream.c
0 <= idx && idx < PAM_REGIONS_COUNT
/home/virus/AMD/AMD/include/hw/pci-host/gpex.h
E5C937D0-3553-4D7A-9117-EA4D19C3434D
/home/virus/AMD/AMD/include/hw/pci-host/q35.h
invalid extended-tseg-mbytes value: %u
Q35: Reserved PCIEXBAR LENGTH
i440fx doesn't support emulated iommu
/home/virus/AMD/AMD/include/hw/pci-host/i440fx.h
/home/virus/AMD/AMD/include/hw/pci-host/remote.h
/home/virus/AMD/AMD/include/hw/rtc/mc146818rtc.h
lost_clock >= 0 && lost_clock <= period
(s->cmos_data[RTC_REG_A] & REG_A_UIP) == 0
(s->cmos_data[RTC_REG_A] & 0x60) != 0x60
Maximum value for "irq" is: %u
mc146818rtc/irq_reinject_on_ack_count
scsi_device_for_each_req_async_bh
/home/virus/AMD/AMD/include/hw/scsi/scsi.h
req->status == -1 && req->host_status == -1
%d@%zu.%06zu:scsi_req_alloc target %d lun %d tag %d
scsi_req_alloc target %d lun %d tag %d
%d@%zu.%06zu:scsi_req_build_sense target %d lun %d tag %d key 0x%02x asc 0x%02x ascq 0x%02x
scsi_req_build_sense target %d lun %d tag %d key 0x%02x asc 0x%02x ascq 0x%02x
%d@%zu.%06zu:scsi_req_parse_bad target %d lun %d tag %d command %d
scsi_req_parse_bad target %d lun %d tag %d command %d
%d@%zu.%06zu:scsi_req_parsed target %d lun %d tag %d command %d dir %d length %d
scsi_req_parsed target %d lun %d tag %d command %d dir %d length %d
%d@%zu.%06zu:scsi_req_parsed_lba target %d lun %d tag %d command %d lba %lu
scsi_req_parsed_lba target %d lun %d tag %d command %d lba %lu
%d@%zu.%06zu:scsi_inquiry target %d lun %d tag %d page 0x%02x/0x%02x
scsi_inquiry target %d lun %d tag %d page 0x%02x/0x%02x
%d@%zu.%06zu:scsi_test_unit_ready target %d lun %d tag %d
scsi_test_unit_ready target %d lun %d tag %d
%d@%zu.%06zu:scsi_report_luns target %d lun %d tag %d
scsi_report_luns target %d lun %d tag %d
%d@%zu.%06zu:scsi_request_sense target %d lun %d tag %d
scsi_request_sense target %d lun %d tag %d
%d@%zu.%06zu:scsi_req_dequeue target %d lun %d tag %d
scsi_req_dequeue target %d lun %d tag %d
%d@%zu.%06zu:scsi_req_continue_canceled target %d lun %d tag %d
scsi_req_continue_canceled target %d lun %d tag %d
%d@%zu.%06zu:scsi_req_continue target %d lun %d tag %d
scsi_req_continue target %d lun %d tag %d
%d@%zu.%06zu:scsi_req_data_canceled target %d lun %d tag %d len %d
scsi_req_data_canceled target %d lun %d tag %d len %d
%d@%zu.%06zu:scsi_req_data target %d lun %d tag %d len %d
scsi_req_data target %d lun %d tag %d len %d
req->cmd.mode != SCSI_XFER_NONE
req->sense_len <= sizeof(req->sense)
req->ops != &reqops_unit_attention
%d@%zu.%06zu:scsi_req_cancel target %d lun %d tag %d
scsi_req_cancel target %d lun %d tag %d
%d@%zu.%06zu:scsi_device_set_ua target %d lun %d key 0x%02x asc 0x%02x ascq 0x%02x
scsi_device_set_ua target %d lun %d key 0x%02x asc 0x%02x ascq 0x%02x
qemu_get_current_aio_context() == qemu_get_aio_context()
%d@%zu.%06zu:scsi_bus_drained_begin bus %p sdev %p
scsi_bus_drained_begin bus %p sdev %p
%d@%zu.%06zu:scsi_bus_drained_end bus %p sdev %p
scsi_bus_drained_end bus %p sdev %p
offset % s->qdev.blocksize == 0
iov->size % s->qdev.blocksize == 0
io_header->iovec_count == iov->niov
%d@%zu.%06zu:scsi_disk_aio_sgio_command disk aio sgio: tag=0x%x cmd=0x%x (sector %ld, count %d) timeout=%u
scsi_disk_aio_sgio_command disk aio sgio: tag=0x%x cmd=0x%x (sector %ld, count %d) timeout=%u
%d@%zu.%06zu:scsi_disk_check_condition Command complete tag=0x%x sense=%d/%d/%d
scsi_disk_check_condition Command complete tag=0x%x sense=%d/%d/%d
%d@%zu.%06zu:scsi_disk_dma_command_READ Read (sector %ld, count %u)
scsi_disk_dma_command_READ Read (sector %ld, count %u)
%d@%zu.%06zu:scsi_disk_dma_command_WRITE Write %s(sector %ld, count %u)
scsi_disk_dma_command_WRITE Write %s(sector %ld, count %u)
HBA does not support iothreads
The serial number can't be longer than %d characters
The serial number can't be longer than %d characters when it is also used as the default for device_id
'loadparm' is only valid for boot devices
%d@%zu.%06zu:scsi_disk_emulate_read_data Read buf_len=%d
scsi_disk_emulate_read_data Read buf_len=%d
rotation_rate is specified for scsi-block but is not implemented. This option is deprecated and will be removed in a future version
cannot get SG_IO version number
scsi generic interface too old
%d@%zu.%06zu:scsi_disk_emulate_write_data Write buf_len=%d
scsi_disk_emulate_write_data Write buf_len=%d
%d@%zu.%06zu:scsi_disk_mode_select_set_blocksize set block size to %d
scsi_disk_mode_select_set_blocksize set block size to %d
%d@%zu.%06zu:scsi_disk_mode_select_page_truncated page %d expected length %d but received length %d
scsi_disk_mode_select_page_truncated page %d expected length %d but received length %d
%d@%zu.%06zu:scsi_disk_new_request Command: lun=%d tag=0x%x data=%s
scsi_disk_new_request Command: lun=%d tag=0x%x data=%s
blk_is_available(s->qdev.conf.blk)
%d@%zu.%06zu:scsi_disk_emulate_vpd_page_00 Inquiry EVPD[Supported pages] buffer size %zd
scsi_disk_emulate_vpd_page_00 Inquiry EVPD[Supported pages] buffer size %zd
%d@%zu.%06zu:scsi_disk_emulate_vpd_page_80_not_supported Inquiry (EVPD[Serial number] not supported
scsi_disk_emulate_vpd_page_80_not_supported Inquiry (EVPD[Serial number] not supported
%d@%zu.%06zu:scsi_disk_emulate_vpd_page_80 Inquiry EVPD[Serial number] buffer size %zd
scsi_disk_emulate_vpd_page_80 Inquiry EVPD[Serial number] buffer size %zd
%d@%zu.%06zu:scsi_disk_emulate_vpd_page_83 Inquiry EVPD[Device identification] buffer size %zd
scsi_disk_emulate_vpd_page_83 Inquiry EVPD[Device identification] buffer size %zd
%d@%zu.%06zu:scsi_disk_emulate_vpd_page_b0_not_supported Inquiry (EVPD[Block limits] not supported for CDROM
scsi_disk_emulate_vpd_page_b0_not_supported Inquiry (EVPD[Block limits] not supported for CDROM
%d@%zu.%06zu:scsi_disk_emulate_mode_sense Mode Sense(%d) (page %d, xfer %zd, page_control %d)
scsi_disk_emulate_mode_sense Mode Sense(%d) (page %d, xfer %zd, page_control %d)
%d@%zu.%06zu:scsi_disk_emulate_read_toc Read TOC (track %d format %d msf %d)
scsi_disk_emulate_read_toc Read TOC (track %d format %d msf %d)
%d@%zu.%06zu:scsi_disk_emulate_command_SAI_16 SAI READ CAPACITY(16)
scsi_disk_emulate_command_SAI_16 SAI READ CAPACITY(16)
%d@%zu.%06zu:scsi_disk_emulate_command_SAI_unsupported Unsupported Service Action In
scsi_disk_emulate_command_SAI_unsupported Unsupported Service Action In
%d@%zu.%06zu:scsi_disk_emulate_command_SEEK_10 Seek(10) (sector %ld)
scsi_disk_emulate_command_SEEK_10 Seek(10) (sector %ld)
%d@%zu.%06zu:scsi_disk_emulate_command_MODE_SELECT Mode Select(6) (len %zd)
scsi_disk_emulate_command_MODE_SELECT Mode Select(6) (len %zd)
%d@%zu.%06zu:scsi_disk_emulate_command_MODE_SELECT_10 Mode Select(10) (len %zd)
scsi_disk_emulate_command_MODE_SELECT_10 Mode Select(10) (len %zd)
%d@%zu.%06zu:scsi_disk_emulate_command_UNMAP Unmap (len %zd)
scsi_disk_emulate_command_UNMAP Unmap (len %zd)
%d@%zu.%06zu:scsi_disk_emulate_command_VERIFY Verify (bytchk %d)
scsi_disk_emulate_command_VERIFY Verify (bytchk %d)
%d@%zu.%06zu:scsi_disk_emulate_command_WRITE_SAME WRITE SAME %d (len %zd)
scsi_disk_emulate_command_WRITE_SAME WRITE SAME %d (len %zd)
%d@%zu.%06zu:scsi_disk_emulate_command_FORMAT_UNIT Format Unit (len %zu)
scsi_disk_emulate_command_FORMAT_UNIT Format Unit (len %zu)
%d@%zu.%06zu:scsi_disk_emulate_command_UNKNOWN Unknown SCSI command (0x%2.2x=%s)
scsi_disk_emulate_command_UNKNOWN Unknown SCSI command (0x%2.2x=%s)
r->iov.iov_len == req->cmd.xfer
r->req.ctx == qemu_get_current_aio_context()
%d@%zu.%06zu:scsi_disk_read_complete Data ready tag=0x%x len=%zd
scsi_disk_read_complete Data ready tag=0x%x len=%zd
%d@%zu.%06zu:scsi_disk_write_complete_noio Write complete tag=0x%x more=%zd
scsi_disk_write_complete_noio Write complete tag=0x%x more=%zd
%d@%zu.%06zu:scsi_disk_write_data_invalid Data transfer direction invalid
scsi_disk_write_data_invalid Data transfer direction invalid
%d@%zu.%06zu:scsi_disk_read_data_count Read sector_count=%d
scsi_disk_read_data_count Read sector_count=%d
%d@%zu.%06zu:scsi_disk_read_data_invalid Data transfer direction invalid
scsi_disk_read_data_invalid Data transfer direction invalid
quirk_mode_page_vendor_specific_apple
%d@%zu.%06zu:scsi_generic_aio_sgio_command generic aio sgio: tag=0x%x cmd=0x%x timeout=%u
scsi_generic_aio_sgio_command generic aio sgio: tag=0x%x cmd=0x%x timeout=%u
%d@%zu.%06zu:scsi_generic_command_complete_noio Command complete %p tag=0x%x status=%d
scsi_generic_command_complete_noio Command complete %p tag=0x%x status=%d
%d@%zu.%06zu:scsi_generic_write_complete scsi_write_complete() ret = %d
scsi_generic_write_complete scsi_write_complete() ret = %d
%d@%zu.%06zu:scsi_generic_write_complete_blocksize block size %d
scsi_generic_write_complete_blocksize block size %d
%d@%zu.%06zu:scsi_generic_send_command Command: data=%s
scsi_generic_send_command Command: data=%s
pass through generic scsi device (/dev/sg*)
%d@%zu.%06zu:scsi_generic_write_data scsi_write_data tag=0x%x
scsi_generic_write_data scsi_write_data tag=0x%x
%d@%zu.%06zu:scsi_generic_read_data scsi_read_data tag=0x%x
scsi_generic_read_data scsi_read_data tag=0x%x
%d@%zu.%06zu:scsi_generic_read_complete Data ready tag=0x%x len=%d
scsi_generic_read_complete Data ready tag=0x%x len=%d
%d@%zu.%06zu:scsi_generic_ioctl_sgio_command generic ioctl sgio: cmd=0x%x timeout=%u
scsi_generic_ioctl_sgio_command generic ioctl sgio: cmd=0x%x timeout=%u
%d@%zu.%06zu:scsi_generic_ioctl_sgio_done generic ioctl sgio: cmd=0x%x ret=%d status=0x%x host_status=0x%x
scsi_generic_ioctl_sgio_done generic ioctl sgio: cmd=0x%x ret=%d status=0x%x host_status=0x%x
Device doesn't support drive option werror
Device doesn't support drive option rerror
%d@%zu.%06zu:scsi_generic_realize_type device type %d
scsi_generic_realize_type device type %d
%d@%zu.%06zu:scsi_generic_realize_blocksize block size %d
scsi_generic_realize_blocksize block size %d
%d@%zu.%06zu:esp_raise_irq Raise IRQ
/home/virus/AMD/AMD/include/hw/scsi/esp.h
%d@%zu.%06zu:esp_raise_drq Raise DREQ
%d@%zu.%06zu:esp_lower_drq Lower DREQ
%d@%zu.%06zu:esp_error_fifo_overrun FIFO overrun
esp_error_fifo_overrun FIFO overrun
%d@%zu.%06zu:esp_dma_enable Raise enable
%d@%zu.%06zu:esp_command_complete SCSI Command complete
esp_command_complete SCSI Command complete
%d@%zu.%06zu:esp_command_complete_unexpected SCSI command completed unexpectedly
esp_command_complete_unexpected SCSI command completed unexpectedly
%d@%zu.%06zu:esp_command_complete_fail Command failed
esp_command_complete_fail Command failed
%d@%zu.%06zu:esp_set_phase setting bus phase to %s
esp_set_phase setting bus phase to %s
%d@%zu.%06zu:esp_do_identify 0x%x
%d@%zu.%06zu:esp_do_command_phase busid 0x%x
esp_do_command_phase busid 0x%x
%d@%zu.%06zu:esp_handle_ti_cmd command len %d
esp_handle_ti_cmd command len %d
%d@%zu.%06zu:esp_do_dma command len %d + %d
esp_do_dma command len %d + %d
%d@%zu.%06zu:esp_transfer_data transfer %d/%d
esp_transfer_data transfer %d/%d
%d@%zu.%06zu:esp_handle_ti Transfer Information len %d
esp_handle_ti Transfer Information len %d
%d@%zu.%06zu:esp_pdma_write pDMA write %u bytes
esp_pdma_write pDMA write %u bytes
%d@%zu.%06zu:esp_pdma_read pDMA read %u bytes
esp_pdma_read pDMA read %u bytes
%d@%zu.%06zu:esp_dma_disable Lower enable
%d@%zu.%06zu:esp_lower_irq Lower IRQ
%d@%zu.%06zu:esp_mem_readb reg[%d]: 0x%2.2x
esp_mem_readb reg[%d]: 0x%2.2x
%d@%zu.%06zu:esp_mem_writeb reg[%d]: 0x%2.2x -> 0x%2.2x
esp_mem_writeb reg[%d]: 0x%2.2x -> 0x%2.2x
%d@%zu.%06zu:esp_mem_writeb_cmd_nop NOP (0x%2.2x)
esp_mem_writeb_cmd_nop NOP (0x%2.2x)
%d@%zu.%06zu:esp_mem_writeb_cmd_flush Flush FIFO (0x%2.2x)
esp_mem_writeb_cmd_flush Flush FIFO (0x%2.2x)
%d@%zu.%06zu:esp_mem_writeb_cmd_reset Chip reset (0x%2.2x)
esp_mem_writeb_cmd_reset Chip reset (0x%2.2x)
%d@%zu.%06zu:esp_mem_writeb_cmd_bus_reset Bus reset (0x%2.2x)
esp_mem_writeb_cmd_bus_reset Bus reset (0x%2.2x)
%d@%zu.%06zu:esp_mem_writeb_cmd_ti Transfer Information (0x%2.2x)
esp_mem_writeb_cmd_ti Transfer Information (0x%2.2x)
%d@%zu.%06zu:esp_mem_writeb_cmd_iccs Initiator Command Complete Sequence (0x%2.2x)
esp_mem_writeb_cmd_iccs Initiator Command Complete Sequence (0x%2.2x)
%d@%zu.%06zu:esp_write_response Transfer status (status=%d)
esp_write_response Transfer status (status=%d)
%d@%zu.%06zu:esp_mem_writeb_cmd_msgacc Message Accepted (0x%2.2x)
esp_mem_writeb_cmd_msgacc Message Accepted (0x%2.2x)
%d@%zu.%06zu:esp_mem_writeb_cmd_pad Transfer padding (0x%2.2x)
esp_mem_writeb_cmd_pad Transfer padding (0x%2.2x)
%d@%zu.%06zu:esp_mem_writeb_cmd_satn Set ATN (0x%2.2x)
esp_mem_writeb_cmd_satn Set ATN (0x%2.2x)
%d@%zu.%06zu:esp_mem_writeb_cmd_rstatn Reset ATN (0x%2.2x)
esp_mem_writeb_cmd_rstatn Reset ATN (0x%2.2x)
%d@%zu.%06zu:esp_mem_writeb_cmd_sel Select without ATN (0x%2.2x)
esp_mem_writeb_cmd_sel Select without ATN (0x%2.2x)
%d@%zu.%06zu:esp_mem_writeb_cmd_selatn Select with ATN (0x%2.2x)
esp_mem_writeb_cmd_selatn Select with ATN (0x%2.2x)
%d@%zu.%06zu:esp_mem_writeb_cmd_selatns Select with ATN & stop (0x%2.2x)
esp_mem_writeb_cmd_selatns Select with ATN & stop (0x%2.2x)
%d@%zu.%06zu:esp_mem_writeb_cmd_ensel Enable selection (0x%2.2x)
esp_mem_writeb_cmd_ensel Enable selection (0x%2.2x)
%d@%zu.%06zu:esp_mem_writeb_cmd_dissel Disable selection (0x%2.2x)
esp_mem_writeb_cmd_dissel Disable selection (0x%2.2x)
%d@%zu.%06zu:esp_error_unhandled_command unhandled command (0x%2.2x)
esp_error_unhandled_command unhandled command (0x%2.2x)
%d@%zu.%06zu:esp_error_invalid_write invalid write of 0x%02x at [0x%x]
esp_error_invalid_write invalid write of 0x%02x at [0x%x]
AMD Am53c974 PCscsi-PCI SCSI adapter
am53c974: MDL transfer not implemented
%d@%zu.%06zu:esp_pci_dma_read reg[%d]: 0x%8.8x
esp_pci_dma_read reg[%d]: 0x%8.8x
%d@%zu.%06zu:esp_pci_sbac_read sbac: 0x%8.8x
esp_pci_sbac_read sbac: 0x%8.8x
%d@%zu.%06zu:esp_pci_error_invalid_read read access outside bounds (reg 0x%x)
esp_pci_error_invalid_read read access outside bounds (reg 0x%x)
%d@%zu.%06zu:esp_pci_dma_write reg[%d]: 0x%8.8x -> 0x%8.8x
esp_pci_dma_write reg[%d]: 0x%8.8x -> 0x%8.8x
%d@%zu.%06zu:esp_pci_dma_idle IDLE (0x%.8x)
esp_pci_dma_idle IDLE (0x%.8x)
%d@%zu.%06zu:esp_pci_dma_blast BLAST (0x%.8x)
esp_pci_dma_blast BLAST (0x%.8x)
am53c974: cmd BLAST not implemented
%d@%zu.%06zu:esp_pci_dma_abort ABORT (0x%.8x)
esp_pci_dma_abort ABORT (0x%.8x)
%d@%zu.%06zu:esp_pci_dma_start START (0x%.8x)
esp_pci_dma_start START (0x%.8x)
%d@%zu.%06zu:esp_pci_error_invalid_write_dma invalid write of 0x%02x at [0x%x]
esp_pci_error_invalid_write_dma invalid write of 0x%02x at [0x%x]
%d@%zu.%06zu:esp_pci_sbac_write sbac: 0x%8.8x -> 0x%8.8x
esp_pci_sbac_write sbac: 0x%8.8x -> 0x%8.8x
%d@%zu.%06zu:esp_pci_error_invalid_write write access outside bounds (reg 0x%x)
esp_pci_error_invalid_write write access outside bounds (reg 0x%x)
%d@%zu.%06zu:esp_pci_error_invalid_dma_direction invalid DMA transfer direction
esp_pci_error_invalid_dma_direction invalid DMA transfer direction
%d@%zu.%06zu:lsi_scripts_timer_start SCRIPTS timer started
lsi_scripts_timer_start SCRIPTS timer started
%d@%zu.%06zu:lsi_add_msg_byte_error MSG IN data too long
lsi_add_msg_byte_error MSG IN data too long
%d@%zu.%06zu:lsi_add_msg_byte MSG IN 0x%02x
lsi_add_msg_byte MSG IN 0x%02x
%d@%zu.%06zu:lsi_update_irq Update IRQ level %d dstat 0x%02x sist 0x%02x0x%02x
lsi_update_irq Update IRQ level %d dstat 0x%02x sist 0x%02x0x%02x
%d@%zu.%06zu:lsi_update_irq_disconnected Handled IRQs & disconnected, looking for pending processes
lsi_update_irq_disconnected Handled IRQs & disconnected, looking for pending processes
%d@%zu.%06zu:lsi_script_scsi_interrupt SCSI Interrupt 0x%02x0x%02x prev 0x%02x0x%02x
lsi_script_scsi_interrupt SCSI Interrupt 0x%02x0x%02x prev 0x%02x0x%02x
%d@%zu.%06zu:lsi_reselect Reselected target %d
lsi_reselect Reselected target %d
%d@%zu.%06zu:lsi_bad_selection Selected absent target %u
lsi_bad_selection Selected absent target %u
lsi_scsi: invalid read from reg %s %x
%d@%zu.%06zu:lsi_reg_read Read reg %s 0x%x = 0x%02x
lsi_reg_read Read reg %s 0x%x = 0x%02x
%d@%zu.%06zu:lsi_script_dma_interrupt DMA Interrupt 0x%x prev 0x%x
lsi_script_dma_interrupt DMA Interrupt 0x%x prev 0x%x
%d@%zu.%06zu:lsi_memcpy memcpy dest 0x%x src 0x%x count %d
lsi_memcpy memcpy dest 0x%x src 0x%x count %d
%d@%zu.%06zu:lsi_execute_script SCRIPTS dsp=0x%x opcode 0x%x arg 0x%x
lsi_execute_script SCRIPTS dsp=0x%x opcode 0x%x arg 0x%x
%d@%zu.%06zu:lsi_execute_script_blockmove_delayed Delayed select timeout
lsi_execute_script_blockmove_delayed Delayed select timeout
lsi_scsi: Illegal selector specified (0x%x > 0x15) for 64-bit DMA block move
%d@%zu.%06zu:lsi_execute_script_blockmove_badphase Wrong phase got %s expected %s
lsi_execute_script_blockmove_badphase Wrong phase got %s expected %s
%d@%zu.%06zu:lsi_do_command Send command len=%d
lsi_do_command Send command len=%d
%d@%zu.%06zu:lsi_queue_command Queueing tag=0x%x
lsi_queue_command Queueing tag=0x%x
%d@%zu.%06zu:lsi_do_status Get status len=%d status=%d
lsi_do_status Get status len=%d status=%d
%d@%zu.%06zu:lsi_do_status_error Bad Status move
lsi_do_status_error Bad Status move
%d@%zu.%06zu:lsi_do_msgout MSG out len=%d
%d@%zu.%06zu:lsi_do_msgout_disconnect MSG: Disconnect
lsi_do_msgout_disconnect MSG: Disconnect
%d@%zu.%06zu:lsi_do_msgout_noop MSG: No Operation
lsi_do_msgout_noop MSG: No Operation
%d@%zu.%06zu:lsi_do_msgout_extended Extended message 0x%x (len %d)
lsi_do_msgout_extended Extended message 0x%x (len %d)
%d@%zu.%06zu:lsi_do_msgout_ignored %s (ignored)
lsi_do_msgout_ignored %s (ignored)
%d@%zu.%06zu:lsi_do_msgout_simplequeue SIMPLE queue tag=0x%x
lsi_do_msgout_simplequeue SIMPLE queue tag=0x%x
lsi_scsi: HEAD queue not implemented
lsi_scsi: ORDERED queue not implemented
%d@%zu.%06zu:lsi_do_msgout_abort MSG: ABORT TAG tag=0x%x
lsi_do_msgout_abort MSG: ABORT TAG tag=0x%x
%d@%zu.%06zu:lsi_do_msgout_clearqueue MSG: CLEAR QUEUE tag=0x%x
lsi_do_msgout_clearqueue MSG: CLEAR QUEUE tag=0x%x
%d@%zu.%06zu:lsi_do_msgout_busdevicereset MSG: BUS DEVICE RESET tag=0x%x
lsi_do_msgout_busdevicereset MSG: BUS DEVICE RESET tag=0x%x
%d@%zu.%06zu:lsi_do_msgout_select Select LUN %d
lsi_do_msgout_select Select LUN %d
%d@%zu.%06zu:lsi_do_msgin Message in len=%d %d
lsi_do_msgin Message in len=%d %d
len > 0 && len <= LSI_MAX_MSGIN_LEN
lsi_scsi: Unimplemented phase %s
%d@%zu.%06zu:lsi_execute_script_io_alreadyreselected Already reselected, jumping to alternative address
lsi_execute_script_io_alreadyreselected Already reselected, jumping to alternative address
%d@%zu.%06zu:lsi_execute_script_io_selected Selected target %d%s
lsi_execute_script_io_selected Selected target %d%s
%d@%zu.%06zu:lsi_execute_script_io_disconnect Wait Disconnect
lsi_execute_script_io_disconnect Wait Disconnect
%d@%zu.%06zu:lsi_wait_reselect Wait Reselect
lsi_wait_reselect Wait Reselect
%d@%zu.%06zu:lsi_execute_script_io_set Set%s%s%s%s
lsi_execute_script_io_set Set%s%s%s%s
lsi_scsi: Target mode not implemented
%d@%zu.%06zu:lsi_execute_script_io_clear Clear%s%s%s%s
lsi_execute_script_io_clear Clear%s%s%s%s
%d@%zu.%06zu:lsi_execute_script_io_opcode %s reg 0x%x %s data8=0x%02x sfbr=0x%02x%s
lsi_execute_script_io_opcode %s reg 0x%x %s data8=0x%02x sfbr=0x%02x%s
%d@%zu.%06zu:lsi_execute_script_tc_nop NOP
lsi_execute_script_tc_nop NOP
%d@%zu.%06zu:lsi_execute_script_tc_delayedselect_timeout Delayed select timeout
lsi_execute_script_tc_delayedselect_timeout Delayed select timeout
%d@%zu.%06zu:lsi_execute_script_tc_compc Compare carry %d
lsi_execute_script_tc_compc Compare carry %d
%d@%zu.%06zu:lsi_execute_script_tc_compp Compare phase %s %c= %s
lsi_execute_script_tc_compp Compare phase %s %c= %s
%d@%zu.%06zu:lsi_execute_script_tc_compd Compare data 0x%x & 0x%x %c= 0x%x
lsi_execute_script_tc_compd Compare data 0x%x & 0x%x %c= 0x%x
%d@%zu.%06zu:lsi_execute_script_tc_jump Jump to 0x%x
lsi_execute_script_tc_jump Jump to 0x%x
%d@%zu.%06zu:lsi_execute_script_tc_call Call 0x%x
lsi_execute_script_tc_call Call 0x%x
%d@%zu.%06zu:lsi_execute_script_tc_return Return to 0x%x
lsi_execute_script_tc_return Return to 0x%x
%d@%zu.%06zu:lsi_execute_script_tc_interrupt Interrupt 0x%x
lsi_execute_script_tc_interrupt Interrupt 0x%x
%d@%zu.%06zu:lsi_execute_script_tc_illegal Illegal transfer control
lsi_execute_script_tc_illegal Illegal transfer control
%d@%zu.%06zu:lsi_execute_script_tc_cc_failed Control condition failed
lsi_execute_script_tc_cc_failed Control condition failed
%d@%zu.%06zu:lsi_execute_script_mm_load Load reg 0x%x size %d addr 0x%x = 0x%08x
lsi_execute_script_mm_load Load reg 0x%x size %d addr 0x%x = 0x%08x
%d@%zu.%06zu:lsi_execute_script_mm_store Store reg 0x%x size %d addr 0x%x
lsi_execute_script_mm_store Store reg 0x%x size %d addr 0x%x
%d@%zu.%06zu:lsi_execute_script_stop SCRIPTS execution stopped
lsi_execute_script_stop SCRIPTS execution stopped
%d@%zu.%06zu:lsi_reg_write Write reg %s 0x%x = 0x%02x
lsi_reg_write Write reg %s 0x%x = 0x%02x
lsi_scsi: Start sequence not implemented
lsi_scsi: Immediate Arbritration not implemented
lsi_scsi: Destination ID does not match SSID
%d@%zu.%06zu:lsi_awoken Woken by SIGP
lsi_scsi: Unimplemented CTEST4-FBL 0x%x
lsi_scsi: CTEST5 DMA increment not implemented
lsi_scsi: General purpose timer not implemented
lsi_scsi: Low level mode not implemented
lsi_scsi: SCSI FIFO test mode not implemented
lsi_scsi: invalid write to reg %s %x (0x%02x)
%d@%zu.%06zu:lsi_do_dma_unavailable DMA no data available
lsi_do_dma_unavailable DMA no data available
%d@%zu.%06zu:lsi_do_dma DMA addr=0x%lx len=%d
lsi_do_dma DMA addr=0x%lx len=%d
%d@%zu.%06zu:lsi_scripts_timer_triggered SCRIPTS timer triggered
lsi_scripts_timer_triggered SCRIPTS timer triggered
%d@%zu.%06zu:lsi_command_complete Command complete status=%d
lsi_command_complete Command complete status=%d
%d@%zu.%06zu:lsi_bad_phase_jump Data phase mismatch jump to 0x%X
lsi_bad_phase_jump Data phase mismatch jump to 0x%X
%d@%zu.%06zu:lsi_bad_phase_interrupt Phase mismatch interrupt
lsi_bad_phase_interrupt Phase mismatch interrupt
%d@%zu.%06zu:lsi_queue_req_error Multiple IO pending for request %p
lsi_queue_req_error Multiple IO pending for request %p
%d@%zu.%06zu:lsi_queue_req Queueing IO tag=0x%x
lsi_queue_req Queueing IO tag=0x%x
%d@%zu.%06zu:lsi_transfer_data Data ready tag=0x%x len=%d
lsi_transfer_data Data ready tag=0x%x len=%d
%d@%zu.%06zu:megasas_iov_write_overflow scmd %d: %d/%d bytes
megasas_iov_write_overflow scmd %d: %d/%d bytes
%d@%zu.%06zu:megasas_iov_read_overflow scmd %d: %d/%d bytes
megasas_iov_read_overflow scmd %d: %d/%d bytes
%d@%zu.%06zu:megasas_iov_write_underflow scmd %d: %d/%d bytes
megasas_iov_write_underflow scmd %d: %d/%d bytes
%d@%zu.%06zu:megasas_iov_read_underflow scmd %d: %d/%d bytes
megasas_iov_read_underflow scmd %d: %d/%d bytes
%d@%zu.%06zu:megasas_io_complete scmd %d: %d bytes
megasas_io_complete scmd %d: %d bytes
%d@%zu.%06zu:megasas_dcmd_reset_ld scmd %d: dev %d
megasas_dcmd_reset_ld scmd %d: dev %d
%d@%zu.%06zu:megasas_dcmd_set_fw_time scmd %d: Set FW time 0x%lx
megasas_dcmd_set_fw_time scmd %d: Set FW time 0x%lx
%d@%zu.%06zu:megasas_finish_dcmd scmd %d: MFI DCMD wrote %d bytes
megasas_finish_dcmd scmd %d: MFI DCMD wrote %d bytes
%d@%zu.%06zu:megasas_init Using %d sges, %d cmds, %s mode
megasas_init Using %d sges, %d cmds, %s mode
%d@%zu.%06zu:megasas_reset firmware state 0x%x
megasas_reset firmware state 0x%x
%d@%zu.%06zu:megasas_dcmd_dummy scmd %d: xfer len %ld
megasas_dcmd_dummy scmd %d: xfer len %ld
%d@%zu.%06zu:megasas_dcmd_invalid_xfer_len scmd %d: xfer len %ld, max %ld
megasas_dcmd_invalid_xfer_len scmd %d: xfer len %ld, max %ld
%d@%zu.%06zu:megasas_iovec_sgl_overflow scmd %d: iovec count %d limit %d
megasas_iovec_sgl_overflow scmd %d: iovec count %d limit %d
%d@%zu.%06zu:megasas_iovec_sgl_underflow scmd %d: iovec count %d
megasas_iovec_sgl_underflow scmd %d: iovec count %d
%d@%zu.%06zu:megasas_iovec_sgl_invalid scmd %d: element %d pa 0x%lx len %u
megasas_iovec_sgl_invalid scmd %d: element %d pa 0x%lx len %u
%d@%zu.%06zu:megasas_iovec_overflow scmd %d: len %d limit %d
megasas_iovec_overflow scmd %d: len %d limit %d
%d@%zu.%06zu:megasas_iovec_underflow scmd %d: len %d limit %d
megasas_iovec_underflow scmd %d: len %d limit %d
%d@%zu.%06zu:megasas_qf_complete context 0x%lx head 0x%x tail 0x%x busy %u
megasas_qf_complete context 0x%lx head 0x%x tail 0x%x busy %u
%d@%zu.%06zu:megasas_qf_complete_noirq context 0x%lx 
megasas_qf_complete_noirq context 0x%lx 
%d@%zu.%06zu:megasas_qf_update head 0x%x tail 0x%x busy %u
megasas_qf_update head 0x%x tail 0x%x busy %u
%d@%zu.%06zu:megasas_msix_raise vector %d
%d@%zu.%06zu:megasas_msi_raise vector %d
%d@%zu.%06zu:megasas_irq_raise INTx
%d@%zu.%06zu:megasas_dcmd_req_alloc_failed scmd %d: %s
megasas_dcmd_req_alloc_failed scmd %d: %s
%d@%zu.%06zu:megasas_dcmd_internal_submit scmd %d: %s to dev %d
megasas_dcmd_internal_submit scmd %d: %s to dev %d
%d@%zu.%06zu:megasas_dcmd_ld_get_info scmd %d: dev %d
megasas_dcmd_ld_get_info scmd %d: dev %d
%d@%zu.%06zu:megasas_command_complete scmd %d: status 0x%x, residual %d
megasas_command_complete scmd %d: status 0x%x, residual %d
%d@%zu.%06zu:megasas_dcmd_internal_finish scmd %d: cmd 0x%x lun %d
megasas_dcmd_internal_finish scmd %d: cmd 0x%x lun %d
%d@%zu.%06zu:megasas_dcmd_internal_invalid scmd %d: DCMD 0x%x
megasas_dcmd_internal_invalid scmd %d: DCMD 0x%x
%d@%zu.%06zu:megasas_scsi_complete scmd %d: status 0x%x, len %u/%u
megasas_scsi_complete scmd %d: status 0x%x, len %u/%u
%d@%zu.%06zu:megasas_dcmd_pd_get_info scmd %d: dev %d
megasas_dcmd_pd_get_info scmd %d: dev %d
%d@%zu.%06zu:megasas_dcmd_unsupported scmd %d: set properties len %ld
megasas_dcmd_unsupported scmd %d: set properties len %ld
%d@%zu.%06zu:megasas_dcmd_ld_get_list scmd %d: DCMD LD get list: found %d / %d LDs
megasas_dcmd_ld_get_list scmd %d: DCMD LD get list: found %d / %d LDs
%d@%zu.%06zu:megasas_dcmd_pd_get_list scmd %d: DCMD PD get list: %d / %d PDs, size %d
megasas_dcmd_pd_get_list scmd %d: DCMD PD get list: %d / %d PDs, size %d
%d@%zu.%06zu:megasas_dcmd_pd_list_query scmd %d: query flags 0x%x
megasas_dcmd_pd_list_query scmd %d: query flags 0x%x
%d@%zu.%06zu:megasas_mmio_readl reg %s: 0x%x
megasas_mmio_readl reg %s: 0x%x
%d@%zu.%06zu:megasas_mmio_invalid_readl addr 0x%lx
megasas_mmio_invalid_readl addr 0x%lx
%d@%zu.%06zu:megasas_dcmd_ld_list_query scmd %d: query flags 0x%x
megasas_dcmd_ld_list_query scmd %d: query flags 0x%x
%d@%zu.%06zu:megasas_mmio_writel reg %s: 0x%x
megasas_mmio_writel reg %s: 0x%x
%d@%zu.%06zu:megasas_irq_lower INTx
%d@%zu.%06zu:megasas_intr_disabled Interrupts disabled
megasas_intr_disabled Interrupts disabled
%d@%zu.%06zu:megasas_msix_enabled vector %d
megasas_msix_enabled vector %d
%d@%zu.%06zu:megasas_msi_enabled vector %d
megasas_msi_enabled vector %d
%d@%zu.%06zu:megasas_intr_enabled Interrupts enabled
megasas_intr_enabled Interrupts enabled
%d@%zu.%06zu:megasas_qf_mapped skip mapped frame 0x%x
megasas_qf_mapped skip mapped frame 0x%x
%d@%zu.%06zu:megasas_qf_busy all frames busy for frame 0x%lx
megasas_qf_busy all frames busy for frame 0x%lx
%d@%zu.%06zu:megasas_qf_new frame 0x%x addr 0x%lx
megasas_qf_new frame 0x%x addr 0x%lx
%d@%zu.%06zu:megasas_qf_map_failed scmd %d: frame %lu
megasas_qf_map_failed scmd %d: frame %lu
%d@%zu.%06zu:megasas_qf_enqueue frame 0x%x count %d context 0x%lx head 0x%x tail 0x%x busy %u
megasas_qf_enqueue frame 0x%x count %d context 0x%lx head 0x%x tail 0x%x busy %u
%d@%zu.%06zu:megasas_frame_busy frame 0x%lx busy
megasas_frame_busy frame 0x%lx busy
%d@%zu.%06zu:megasas_initq_mapped queue already mapped at 0x%lx
megasas_initq_mapped queue already mapped at 0x%lx
%d@%zu.%06zu:megasas_init_firmware pa 0x%lx 
megasas_init_firmware pa 0x%lx 
%d@%zu.%06zu:megasas_initq_map_failed scmd %d: failed to map queue
megasas_initq_map_failed scmd %d: failed to map queue
%d@%zu.%06zu:megasas_initq_mismatch queue size %d max fw cmds %d
megasas_initq_mismatch queue size %d max fw cmds %d
%d@%zu.%06zu:megasas_init_queue queue at 0x%lx len %d head 0x%x tail 0x%x flags 0x%x
megasas_init_queue queue at 0x%lx len %d head 0x%x tail 0x%x flags 0x%x
%d@%zu.%06zu:megasas_handle_dcmd scmd %d: MFI DCMD opcode 0x%x
megasas_handle_dcmd scmd %d: MFI DCMD opcode 0x%x
%d@%zu.%06zu:megasas_dcmd_zero_sge scmd %d: zero DCMD sge count
megasas_dcmd_zero_sge scmd %d: zero DCMD sge count
%d@%zu.%06zu:megasas_dcmd_invalid_sge scmd %d: DCMD sge count %d
megasas_dcmd_invalid_sge scmd %d: DCMD sge count %d
%d@%zu.%06zu:megasas_dcmd_unhandled scmd %d: opcode 0x%x, len %d
megasas_dcmd_unhandled scmd %d: opcode 0x%x, len %d
%d@%zu.%06zu:megasas_dcmd_enter scmd %d: DCMD %s len %d
megasas_dcmd_enter scmd %d: DCMD %s len %d
%d@%zu.%06zu:megasas_abort_no_cmd scmd %d: no active command for frame context 0x%lx
megasas_abort_no_cmd scmd %d: no active command for frame context 0x%lx
%d@%zu.%06zu:megasas_abort_invalid_context scmd %d: invalid frame context 0x%lx for abort frame 0x%x
megasas_abort_invalid_context scmd %d: invalid frame context 0x%lx for abort frame 0x%x
%d@%zu.%06zu:megasas_abort_frame scmd %d: frame 0x%x
megasas_abort_frame scmd %d: frame 0x%x
%d@%zu.%06zu:megasas_scsi_target_not_present %s dev %x/%x/%x
megasas_scsi_target_not_present %s dev %x/%x/%x
%d@%zu.%06zu:megasas_handle_scsi %s dev %x/%x/%x sdev %p xfer %lu
megasas_handle_scsi %s dev %x/%x/%x sdev %p xfer %lu
%d@%zu.%06zu:megasas_scsi_invalid_cdb_len %s dev %x/%x/%x invalid cdb len %d
megasas_scsi_invalid_cdb_len %s dev %x/%x/%x invalid cdb len %d
%d@%zu.%06zu:megasas_scsi_req_alloc_failed %s dev %x/%x
megasas_scsi_req_alloc_failed %s dev %x/%x
%d@%zu.%06zu:megasas_scsi_write_start scmd %d: transfer %d bytes of data
megasas_scsi_write_start scmd %d: transfer %d bytes of data
%d@%zu.%06zu:megasas_scsi_read_start scmd %d: transfer %d bytes of data
megasas_scsi_read_start scmd %d: transfer %d bytes of data
%d@%zu.%06zu:megasas_scsi_nodata scmd %d: no data to be transferred
megasas_scsi_nodata scmd %d: no data to be transferred
%d@%zu.%06zu:megasas_handle_io scmd %d: %s dev %x/%x lba 0x%lx count %lu
megasas_handle_io scmd %d: %s dev %x/%x lba 0x%lx count %lu
%d@%zu.%06zu:megasas_io_target_not_present scmd %d: %s dev 1/%x/%x LUN not present
megasas_io_target_not_present scmd %d: %s dev 1/%x/%x LUN not present
%d@%zu.%06zu:megasas_io_write_start scmd %d: start LBA 0x%lx %lu blocks (%lu bytes)
megasas_io_write_start scmd %d: start LBA 0x%lx %lu blocks (%lu bytes)
%d@%zu.%06zu:megasas_io_read_start scmd %d: start LBA 0x%lx %lu blocks (%lu bytes)
megasas_io_read_start scmd %d: start LBA 0x%lx %lu blocks (%lu bytes)
%d@%zu.%06zu:megasas_unhandled_frame_cmd scmd %d: MFI cmd 0x%x
megasas_unhandled_frame_cmd scmd %d: MFI cmd 0x%x
%d@%zu.%06zu:megasas_mmio_invalid_writel addr 0x%x: 0x%x
megasas_mmio_invalid_writel addr 0x%x: 0x%x
%d@%zu.%06zu:mptsas_irq_msi dev %p 
%d@%zu.%06zu:mptsas_irq_intx dev %p level %d
mptsas_irq_intx dev %p level %d
%d@%zu.%06zu:mptsas_diag_write dev %p addr 0x%08x value 0x%08x
mptsas_diag_write dev %p addr 0x%08x value 0x%08x
s->intr_status & MPI_HIS_DOORBELL_INTERRUPT
s->doorbell_reply_idx <= s->doorbell_reply_size
%d@%zu.%06zu:mptsas_mmio_unhandled_read dev %p addr 0x%08x
mptsas_mmio_unhandled_read dev %p addr 0x%08x
%d@%zu.%06zu:mptsas_mmio_read dev %p addr 0x%08x value 0x%x
mptsas_mmio_read dev %p addr 0x%08x value 0x%x
%d@%zu.%06zu:mptsas_diag_read dev %p addr 0x%08x value 0x%08x
mptsas_diag_read dev %p addr 0x%08x value 0x%08x
%d@%zu.%06zu:mptsas_reset dev %p 
!err || s->msi == ON_OFF_AUTO_AUTO
%d@%zu.%06zu:mptsas_command_complete dev %p context 0x%08x status 0x%x resid %d
mptsas_command_complete dev %p context 0x%08x status 0x%x resid %d
%d@%zu.%06zu:mptsas_process_message dev %p cmd %d context 0x%08x
mptsas_process_message dev %p cmd %d context 0x%08x
%d@%zu.%06zu:mptsas_unhandled_cmd dev %p context 0x%08x: Unhandled cmd 0x%x
mptsas_unhandled_cmd dev %p context 0x%08x: Unhandled cmd 0x%x
%d@%zu.%06zu:mptsas_mmio_write dev %p addr 0x%08x value 0x%x
mptsas_mmio_write dev %p addr 0x%08x value 0x%x
%d@%zu.%06zu:mptsas_unhandled_doorbell_cmd dev %p value 0x%08x
mptsas_unhandled_doorbell_cmd dev %p value 0x%08x
%d@%zu.%06zu:mptsas_mmio_unhandled_write dev %p addr 0x%08x value 0x%x
mptsas_mmio_unhandled_write dev %p addr 0x%08x value 0x%x
size <= MPTSAS_MAX_REQUEST_SIZE
%d@%zu.%06zu:mptsas_process_scsi_io_request dev %p dev %d:%d:%d length %lu
mptsas_process_scsi_io_request dev %p dev %d:%d:%d length %lu
%d@%zu.%06zu:mptsas_sgl_overflow dev %p context 0x%08x: %lu/%lu
mptsas_sgl_overflow dev %p context 0x%08x: %lu/%lu
%d@%zu.%06zu:mptsas_scsi_overflow dev %p context 0x%08x: %lu/%lu
mptsas_scsi_overflow dev %p context 0x%08x: %lu/%lu
b*bbb*wb*b*w*w*w*wb*b*b*b*s12*s12*s12*s12*s12*s12*s12*s12
ret / 4 < 256 && (ret % 4) == 0
b*bbb*l*b*b*b*b*b*b*b*b*b*b*w*l*l*l*l*b*b*w*w*w*w*w*l*l*l
b*bbb*l*b*b*b*b*b*b*w*s56*l*l*l*l*l*l*b*b*w*b*b*w*l*l
b*bbbllbbw*b*b*w*b*b*w*b*b*w*l
b*bbb*wb*b*w*wb*b*w*s16*s16*s16*s16*s16*s16*s16*s16
%d@%zu.%06zu:mptsas_config_sas_device dev %p address %d (port %d, handles: phy %d dev %d) page %d
mptsas_config_sas_device dev %p address %d (port %d, handles: phy %d dev %d) page %d
%d@%zu.%06zu:mptsas_config_sas_phy dev %p address %d (port %d, handles: phy %d dev %d) page %d
mptsas_config_sas_phy dev %p address %d (port %d, handles: phy %d dev %d) page %d
%d@%zu.%06zu:pvscsi_get_sg_list get SG list: depth: %u, size: %zu
pvscsi_get_sg_list get SG list: depth: %u, size: %zu
%d@%zu.%06zu:pvscsi_on_cmd_noimpl unimplemented command %s ignored
pvscsi_on_cmd_noimpl unimplemented command %s ignored
%d@%zu.%06zu:pvscsi_on_cmd_unknown_data data for unknown command 0x:0x%x
pvscsi_on_cmd_unknown_data data for unknown command 0x:0x%x
%d@%zu.%06zu:pvscsi_on_cmd_abort command PVSCSI_CMD_ABORT_CMD for ctx 0x%lx, target %u
pvscsi_on_cmd_abort command PVSCSI_CMD_ABORT_CMD for ctx 0x%lx, target %u
%d@%zu.%06zu:pvscsi_complete_request completion: ctx: 0x%lx, len: 0x%lx, sense key: %u
pvscsi_complete_request completion: ctx: 0x%lx, len: 0x%lx, sense key: %u
%d@%zu.%06zu:pvscsi_command_complete_not_found can't find request for tag 0x%x
pvscsi_command_complete_not_found can't find request for tag 0x%x
%d@%zu.%06zu:pvscsi_command_complete_data_run not all data required for command transferred
pvscsi_command_complete_data_run not all data required for command transferred
%d@%zu.%06zu:pvscsi_command_complete_sense_len sense information length is %d bytes
pvscsi_command_complete_sense_len sense information length is %d bytes
%d@%zu.%06zu:pvscsi_update_irq_level interrupt level set to %d (MASK: 0x%lx, STATUS: 0x%lx)
pvscsi_update_irq_level interrupt level set to %d (MASK: 0x%lx, STATUS: 0x%lx)
%d@%zu.%06zu:pvscsi_update_irq_msi sending MSI notification
pvscsi_update_irq_msi sending MSI notification
%d@%zu.%06zu:pvscsi_msg_ring_put got message descriptor 0x%lx
pvscsi_msg_ring_put got message descriptor 0x%lx
%d@%zu.%06zu:pvscsi_ring_flush_msg new production counter of message ring is 0x%lx
pvscsi_ring_flush_msg new production counter of message ring is 0x%lx
%d@%zu.%06zu:pvscsi_state starting %s ...
%d@%zu.%06zu:pvscsi_init_msi_fail failed to initialize MSI, error %d
pvscsi_init_msi_fail failed to initialize MSI, error %d
pvscsi_process_completion_queue
%d@%zu.%06zu:pvscsi_on_cmd_reset_dev PVSCSI_CMD_RESET_DEVICE[target %u lun %d (dev 0x%p)]
pvscsi_on_cmd_reset_dev PVSCSI_CMD_RESET_DEVICE[target %u lun %d (dev 0x%p)]
%d@%zu.%06zu:pvscsi_on_cmd_arrived command %s arrived
pvscsi_on_cmd_arrived command %s arrived
%d@%zu.%06zu:pvscsi_tx_rings_ppn %s page: 0x%lx
pvscsi_tx_rings_ppn %s page: 0x%lx
%d@%zu.%06zu:pvscsi_tx_rings_num_pages Number of %s pages: %u
pvscsi_tx_rings_num_pages Number of %s pages: %u
%d@%zu.%06zu:pvscsi_ring_init_data TX/RX rings logarithms set to %d/%d
pvscsi_ring_init_data TX/RX rings logarithms set to %d/%d
%d@%zu.%06zu:pvscsi_cmp_ring_put got completion descriptor 0x%lx
pvscsi_cmp_ring_put got completion descriptor 0x%lx
%d@%zu.%06zu:pvscsi_ring_flush_cmp new production counter of completion ring is 0x%lx
pvscsi_ring_flush_cmp new production counter of completion ring is 0x%lx
QTAILQ_EMPTY(&s->pending_queue)
%d@%zu.%06zu:pvscsi_ring_init_msg MSG ring logarithm set to %d
pvscsi_ring_init_msg MSG ring logarithm set to %d
QTAILQ_EMPTY(&s->completion_queue)
%d@%zu.%06zu:pvscsi_io_read %s read: 0x%lx
pvscsi_io_read %s read: 0x%lx
PVSCSI_REG_OFFSET_COMMAND_STATUS
%d@%zu.%06zu:pvscsi_io_read_unknown unknown read address: 0x%lx size: %u bytes
pvscsi_io_read_unknown unknown read address: 0x%lx size: %u bytes
%d@%zu.%06zu:pvscsi_process_io got descriptor 0x%lx
pvscsi_process_io got descriptor 0x%lx
pvscsi_process_req_descr SCSI cmd 0x%x, ctx: 0x%lx
%d@%zu.%06zu:pvscsi_process_req_descr SCSI cmd 0x%x, ctx: 0x%lx
%d@%zu.%06zu:pvscsi_process_req_descr_unknown_device command directed to unknown device rejected
pvscsi_process_req_descr_unknown_device command directed to unknown device rejected
%d@%zu.%06zu:pvscsi_process_req_descr_invalid_dir command with invalid transfer direction rejected
pvscsi_process_req_descr_invalid_dir command with invalid transfer direction rejected
%d@%zu.%06zu:pvscsi_get_next_sg_elem unknown flags in SG element (val: 0x%x)
pvscsi_get_next_sg_elem unknown flags in SG element (val: 0x%x)
%d@%zu.%06zu:pvscsi_convert_sglist element: ctx: 0x%lx addr: 0x%lx, len: %ul
pvscsi_convert_sglist element: ctx: 0x%lx addr: 0x%lx, len: %ul
%d@%zu.%06zu:pvscsi_on_cmd_unknown unknown command 0x%lx
pvscsi_on_cmd_unknown unknown command 0x%lx
bytes_arrived < sizeof(s->curr_cmd_data)
%d@%zu.%06zu:pvscsi_io_write %s write: 0x%lx
pvscsi_io_write %s write: 0x%lx
PVSCSI_REG_OFFSET_KICK_NON_RW_IO
%d@%zu.%06zu:pvscsi_io_write_unknown unknown write address: 0x%lx size: %u bytes value: 0x%lx
pvscsi_io_write_unknown unknown write address: 0x%lx size: %u bytes value: 0x%lx
virtio-scsi: Failed to set host notifier (%d)
/home/virus/AMD/AMD/include/hw/virtio/virtio-scsi.h
iothread and iothread-vq-mapping properties cannot be set at the same time
../hw/scsi/virtio-scsi-dataplane.c
device is incompatible with iothread (transport does not support notifiers)
ioeventfd is required for iothread
virtio-scsi: Failed to set guest notifiers (%d), ensure -accel kvm is set.
!vhost_dev_is_started(&vsc->dev)
/home/virus/AMD/AMD/include/hw/virtio/vhost-scsi.h
/home/virus/AMD/AMD/include/hw/virtio/vhost-scsi-common.h
vhost-scsi: The running tcm_vhost kernel abi_version: %d is greater than vhost_scsi userspace supports: %d, please upgrade your version of QEMU
Error setting vhost-scsi endpoint
unable to start vhost-scsi: %s
vhost-scsi: unable to parse vhostfd: 
vhost-scsi: open vhost char device failed: %s
vhost-scsi does not support migration in all cases. When external environment supports it (Orchestrator migrates target SCSI device state or use shared storage over network), set 'migratable' property to true to enable migration.
vhost-scsi: Backend supports a single worker. Ignoring worker_per_virtqueue=true setting.
vhost-scsi: vhost worker setup failed: %s
/home/virus/AMD/AMD/include/hw/virtio/vhost-user-scsi.h
vhost-user-scsi: vhost start failed: 
vhost-user-scsi: missing chardev
unable to start vhost-user-scsi: %s: 
%s: Optional CMD%i not implemented
%d@%zu.%06zu:sdcard_set_voltage %u mV
SD card voltage not supported: %.3fV
state < ARRAY_SIZE(state_name)
!FIELD_EX32(sd->ocr, OCR, CARD_POWER_UP)
%d@%zu.%06zu:sdcard_read_block addr 0x%lx size 0x%x
sdcard_read_block addr 0x%lx size 0x%x
sd_blk_read: read error on host side
%s: CMD%i in a wrong mode: %s (spec %s)
%s: CMD%i in a wrong state: %s (spec %s)
%d@%zu.%06zu:sdcard_set_rca new RCA: 0x%04x
sdcard_set_rca new RCA: 0x%04x
%d@%zu.%06zu:sdcard_inquiry_cmd41 
%d@%zu.%06zu:sdcard_set_blocklen block len 0x%03x
sdcard_set_blocklen block len 0x%03x
%s: Unknown CMD%i for spec %s
%d@%zu.%06zu:sdcard_set_block_count block cnt 0x%x
sdcard_set_block_count block cnt 0x%x
%d@%zu.%06zu:sdcard_req_addr req 0x%x addr 0x%lx
sdcard_req_addr req 0x%x addr 0x%lx
Invalid SD card Spec version: %u
Cannot use read-only drive as SD card
SD card size has to be a power of 2, e.g. %s.
You can resize disk images with 'qemu-img resize <imagefile> <new-size>'
(note that this will lose data if you make the image smaller than it currently is).
%d@%zu.%06zu:sdcard_inserted read_only: %u
sdcard_inserted read_only: %u
/home/virus/AMD/AMD/include/hw/sd/sd.h
%d@%zu.%06zu:sdcard_write_block addr 0x%lx size 0x%x
sdcard_write_block addr 0x%lx size 0x%x
sd_blk_write: write error on host side
%s: not in Receiving-Data state
%d@%zu.%06zu:sdcard_write_data %s %20s/ CMD%02d ofs %u value 0x%02x
sdcard_write_data %s %20s/ CMD%02d ofs %u value 0x%02x
%s offset %lu > card %lu [%%%u]
SD: Card force-erased by CMD42
%d@%zu.%06zu:sdcard_erase addr first 0x%x last 0x%x
sdcard_erase addr first 0x%x last 0x%x
SD: illegal RCA 0x%04x for APP_CMD
%d@%zu.%06zu:sdcard_normal_command %s %20s/ CMD%02d arg 0x%08x (state %s)
sdcard_normal_command %s %20s/ CMD%02d arg 0x%08x (state %s)
%d@%zu.%06zu:sdcard_app_command %s %23s/ACMD%02d arg 0x%08x (state %s)
sdcard_app_command %s %23s/ACMD%02d arg 0x%08x (state %s)
SD: CMD%i Security not implemented
%d@%zu.%06zu:sdcard_response %s (sz:%d)
%d@%zu.%06zu:sdcard_switch SWITCH acc:%u idx:%u val:%u set:%u
sdcard_switch SWITCH acc:%u idx:%u val:%u set:%u
MMC Command set switching not supported
%d@%zu.%06zu:sdcard_ext_csd_update index %u: 0x%02x -> 0x%02x
sdcard_ext_csd_update index %u: 0x%02x -> 0x%02x
%s: not in Sending-Data state
%d@%zu.%06zu:sdcard_read_data %s %20s/ CMD%02d ofs %u size %lu blklen %u
sdcard_read_data %s %20s/ CMD%02d ofs %u size %lu blklen %u
%s: DAT read illegal for command %s
%d@%zu.%06zu:sdbus_get_dat_lines @%s dat_lines: %u
sdbus_get_dat_lines @%s dat_lines: %u
%d@%zu.%06zu:sdbus_get_cmd_line @%s cmd_line: %u
sdbus_get_cmd_line @%s cmd_line: %u
sdbus_set_voltage @%s %u (mV)
%d@%zu.%06zu:sdbus_set_voltage @%s %u (mV)
%d@%zu.%06zu:sdbus_command @%s CMD%02d arg 0x%08x
sdbus_command @%s CMD%02d arg 0x%08x
%d@%zu.%06zu:sdbus_write @%s value 0x%02x
%d@%zu.%06zu:sdbus_read @%s value 0x%02x
/home/virus/AMD/AMD/include/hw/sd/sdhci.h
%d@%zu.%06zu:sdhci_end_transfer Automatically issue CMD%02u 0x%08x
sdhci_end_transfer Automatically issue CMD%02u 0x%08x
%d@%zu.%06zu:sdhci_set_inserted card state changed: %s
sdhci_set_inserted card state changed: %s
infinite transfer is not supported
%d@%zu.%06zu:sdhci_adma_loop addr=0x%08lx, len=%d, attr=0x%x
sdhci_adma_loop addr=0x%08lx, len=%d, attr=0x%x
%d@%zu.%06zu:sdhci_adma %s: admasysaddr=0x%x
sdhci_adma %s: admasysaddr=0x%x
%d@%zu.%06zu:sdhci_adma_transfer_completed 
sdhci_adma_transfer_completed 
SD/MMC host ADMA length mismatch
%s: Size 0x%x is larger than the maximum buffer 0x%x
%d@%zu.%06zu:sdhci_send_command CMD%02u ARG[0x%08x]
sdhci_send_command CMD%02u ARG[0x%08x]
%d@%zu.%06zu:sdhci_response4 RSPREG[31..0]=0x%08x
sdhci_response4 RSPREG[31..0]=0x%08x
%d@%zu.%06zu:sdhci_response16 RSPREG[127..96]=0x%08x, RSPREG[95..64]=0x%08x, RSPREG[63..32]=0x%08x, RSPREG[31..0]=0x%08x
sdhci_response16 RSPREG[127..96]=0x%08x, RSPREG[95..64]=0x%08x, RSPREG[63..32]=0x%08x, RSPREG[31..0]=0x%08x
timeout waiting for command response
SDHCI: Non-sequential access to Buffer Data Port register is prohibited
Can't write to data buffer: buffer full
%d@%zu.%06zu:sdhci_write_dataport write buffer filled with %u bytes of data
sdhci_write_dataport write buffer filled with %u bytes of data
SDHC wr_%ub @0x%02lx <- 0x%08x read-only
SDHC wr_%ub @0x%02lx <- 0x%08x not implemented
%d@%zu.%06zu:sdhci_access %s%u: addr[0x%04lx] %s 0x%08lx (%lu)
sdhci_access %s%u: addr[0x%04lx] %s 0x%08lx (%lu)
%d@%zu.%06zu:sdhci_read_dataport all %u bytes of data have been read from input buffer
sdhci_read_dataport all %u bytes of data have been read from input buffer
SDHC rd_%ub @0x%02lx not implemented
SD controller doesn't support big endianness
%d@%zu.%06zu:sdhci_capareg %s: %u
SD %s clock frequency can have valuein range 0-63 only
block size can be 512, 1024 or 2048 only
SDHCI: unknown CAPAB mask: 0x%016lx
NUL in OEM strings value in %s
SMBIOS 2.0 doesn't support number of processor cores/threads more than 255, use -machine smbios-entry-point-type=64 option to enable SMBIOS 3.0 support
No PCI device %s for SMBIOS type 9 entry %s
Cannot create type 9 entry for PCI device %s: not attached to the root bus
(mem_array_size + offset) < (T32_BASE - T19_BASE)
No PCI device %s for SMBIOS type 41 entry %s
Cannot create type 41 entry for PCI device %s: not attached to the root bus
Expected %d SMBIOS Type 4 tables, got %d instead
SMBIOS 2.1 table length %zu exceeds %d
can't load type %d struct, fields already specified!
can't add fields, binary file already loaded!
SMBIOS CPU speed is too large (> %d)
Don't know how to build fields for SMBIOS type %ld
string number for reference designation
slot characteristics1, see the spec
slot characteristics2, see the spec
socket designation string prefix
binary file containing an SMBIOS element
info->ipmi_spec_minor_revision <= 15
info->ipmi_spec_major_revision <= 15
IPMI register spacing %d is not compatible with SMBIOS, ignoring this entry.
can't process fields for smbios types > 1 on machine versions < 2.1!
can't process table for smbios type 4 on machine versions < 2.1!
Only 8 instances of HPET is allowed
%d@%zu.%06zu:hpet_ram_read enter hpet_ram_readl at 0x%lx
hpet_ram_read enter hpet_ram_readl at 0x%lx
%d@%zu.%06zu:hpet_timer_id_out_of_range timer id out of range: 0x%x
hpet_timer_id_out_of_range timer id out of range: 0x%x
%d@%zu.%06zu:hpet_ram_read_invalid invalid hpet_ram_readl
hpet_ram_read_invalid invalid hpet_ram_readl
%d@%zu.%06zu:hpet_ram_read_reading_counter reading counter + %u = 0x%lx
hpet_ram_read_reading_counter reading counter + %u = 0x%lx
%d@%zu.%06zu:hpet_ram_write enter hpet_ram_writel at 0x%lx = 0x%lx
hpet_ram_write enter hpet_ram_writel at 0x%lx = 0x%lx
%d@%zu.%06zu:hpet_ram_write_timer_id hpet_ram_writel timer_id = 0x%lx
hpet_ram_write_timer_id hpet_ram_writel timer_id = 0x%lx
%d@%zu.%06zu:hpet_ram_write_tn_cfg hpet_ram_writel HPET_TN_CFG + %u
hpet_ram_write_tn_cfg hpet_ram_writel HPET_TN_CFG + %u
%d@%zu.%06zu:hpet_ram_write_invalid_tn_cmp invalid HPET_TN_CMP + 4 write
hpet_ram_write_invalid_tn_cmp invalid HPET_TN_CMP + 4 write
%d@%zu.%06zu:hpet_ram_write_tn_cmp hpet_ram_writel HPET_TN_CMP + %u
hpet_ram_write_tn_cmp hpet_ram_writel HPET_TN_CMP + %u
%d@%zu.%06zu:hpet_ram_write_invalid invalid hpet_ram_writel
hpet_ram_write_invalid invalid hpet_ram_writel
%d@%zu.%06zu:hpet_ram_write_counter_write_while_enabled Writing counter while HPET enabled!
hpet_ram_write_counter_write_while_enabled Writing counter while HPET enabled!
/home/virus/AMD/AMD/include/hw/timer/i8254.h
channels[0].next_transition_time
%d@%zu.%06zu:tpm_tis_raise_irq Raising IRQ for flag 0x%08x
tpm_tis_raise_irq Raising IRQ for flag 0x%08x
%d@%zu.%06zu:tpm_tis_new_active_locality Active locality is now %d
tpm_tis_new_active_locality Active locality is now %d
%d@%zu.%06zu:tpm_tis_abort New active locality is %d
tpm_tis_abort New active locality is %d
%d@%zu.%06zu:tpm_tis_data_read byte 0x%02x   [%d]
tpm_tis_data_read byte 0x%02x   [%d]
tpm_tis: active locality      : %d
tpm_tis: state of locality %d : %d
tpm_tis: register dump:
tpm_tis: r/w offset    : %d
tpm_tis: result buffer : 
%d@%zu.%06zu:tpm_tis_mmio_read  read.%u(0x%08x) = 0x%08x
tpm_tis_mmio_read  read.%u(0x%08x) = 0x%08x
%d@%zu.%06zu:tpm_tis_mmio_write write.%u(0x%08x) = 0x%08x
tpm_tis_mmio_write write.%u(0x%08x) = 0x%08x
%d@%zu.%06zu:tpm_tis_mmio_write_locty4 Access to locality 4 only allowed from hardware
tpm_tis_mmio_write_locty4 Access to locality 4 only allowed from hardware
%d@%zu.%06zu:tpm_tis_mmio_write_release_locty Releasing locality %d
tpm_tis_mmio_write_release_locty Releasing locality %d
%d@%zu.%06zu:tpm_tis_mmio_write_locty_req_use Locality %d requests use
tpm_tis_mmio_write_locty_req_use Locality %d requests use
%d@%zu.%06zu:tpm_tis_mmio_write_next_locty Next active locality is %d
tpm_tis_mmio_write_next_locty Next active locality is %d
%d@%zu.%06zu:tpm_tis_mmio_write_locty_seized Locality %d seized from locality %d
tpm_tis_mmio_write_locty_seized Locality %d seized from locality %d
%d@%zu.%06zu:tpm_tis_mmio_write_init_abort Initiating abort
tpm_tis_mmio_write_init_abort Initiating abort
%d@%zu.%06zu:tpm_tis_mmio_write_lowering_irq Lowering IRQ
tpm_tis_mmio_write_lowering_irq Lowering IRQ
%d@%zu.%06zu:tpm_tis_mmio_write_data2send Data to send to TPM: 0x%08x (size=%d)
tpm_tis_mmio_write_data2send Data to send to TPM: 0x%08x (size=%d)
%d@%zu.%06zu:tpm_tis_pre_save locty: %d, rw_offset = %u
tpm_tis_pre_save locty: %d, rw_offset = %u
at most one TPM device is permitted
IRQ %d is outside valid range of 0 to 15
%d@%zu.%06zu:tpm_crb_mmio_write CRB write 0x%016lx len:%u val: 0x%x
tpm_crb_mmio_write CRB write 0x%016lx len:%u val: 0x%x
%d@%zu.%06zu:tpm_crb_mmio_read CRB read 0x%016lx len:%u val: 0x%x
tpm_crb_mmio_read CRB read 0x%016lx len:%u val: 0x%x
%d@%zu.%06zu:tpm_ppi_memset memset: %p %zu
tpm_ppi_memset memset: %p %zu
%d@%zu.%06zu:ufs_err_mcq_delete_sq_invalid_sqid invalid mcq sqid %u
ufs_err_mcq_delete_sq_invalid_sqid invalid mcq sqid %u
%d@%zu.%06zu:ufs_err_mcq_delete_sq_not_exists mcq sqid %unot exists
ufs_err_mcq_delete_sq_not_exists mcq sqid %unot exists
%d@%zu.%06zu:ufs_err_mcq_delete_cq_invalid_cqid invalid mcq cqid %u
ufs_err_mcq_delete_cq_invalid_cqid invalid mcq cqid %u
%d@%zu.%06zu:ufs_err_mcq_delete_cq_not_exists mcq cqid %unot exists
ufs_err_mcq_delete_cq_not_exists mcq cqid %unot exists
%d@%zu.%06zu:ufs_err_mcq_delete_cq_sq_not_deleted mcq sq %u still has cq %u
ufs_err_mcq_delete_cq_sq_not_deleted mcq sq %u still has cq %u
%s cannot be connected to ufs-bus
%d@%zu.%06zu:ufs_err_dma_write_rsp_upiu failed to write rsp upiu. UTRLDBR slot %u, response upiu addr %lu
ufs_err_dma_write_rsp_upiu failed to write rsp upiu. UTRLDBR slot %u, response upiu addr %lu
%d@%zu.%06zu:ufs_err_dma_read_utrd failed to read utrd. UTRLDBR slot %u, UTRD dma addr %lu
ufs_err_dma_read_utrd failed to read utrd. UTRLDBR slot %u, UTRD dma addr %lu
%d@%zu.%06zu:ufs_irq_raise INTx
%d@%zu.%06zu:ufs_irq_lower INTx
%d@%zu.%06zu:ufs_err_dma_write_utrd failed to write utrd. UTRLDBR slot %u, UTRD dma addr %lu
ufs_err_dma_write_utrd failed to write utrd. UTRLDBR slot %u, UTRD dma addr %lu
%d@%zu.%06zu:ufs_sendback_req UTRLDBR slot %u
ufs_sendback_req UTRLDBR slot %u
%d@%zu.%06zu:ufs_err_dma_write_cq failed to write cq entry. cqid %u, hwaddr %lu
ufs_err_dma_write_cq failed to write cq entry. cqid %u, hwaddr %lu
%d@%zu.%06zu:ufs_err_dma_read_prdt failed to read prdt. UTRLDBR slot %u, prdt addr %lu
ufs_err_dma_read_prdt failed to read prdt. UTRLDBR slot %u, prdt addr %lu
nutrs must be less than or equal to %d
nutmrs must be less than or equal to %d
%d@%zu.%06zu:ufs_err_dma_read_req_upiu failed to read req upiu. UTRLDBR slot %u, request upiu addr %lu
ufs_err_dma_read_req_upiu failed to read req upiu. UTRLDBR slot %u, request upiu addr %lu
%d@%zu.%06zu:ufs_err_query_invalid_index query request has invalid index. opcode: 0x%x, index 0x%x
ufs_err_query_invalid_index query request has invalid index. opcode: 0x%x, index 0x%x
%d@%zu.%06zu:ufs_err_invalid_register_offset Register offset 0x%x is invalid
ufs_err_invalid_register_offset Register offset 0x%x is invalid
%d@%zu.%06zu:ufs_mmio_read addr 0x%lx data 0x%lx size %d
ufs_mmio_read addr 0x%lx data 0x%lx size %d
%d@%zu.%06zu:ufs_err_query_flag_not_readable query flag idn 0x%x is denied to read
ufs_err_query_flag_not_readable query flag idn 0x%x is denied to read
%d@%zu.%06zu:ufs_err_query_flag_not_writable query flag idn 0x%x is denied to write
ufs_err_query_flag_not_writable query flag idn 0x%x is denied to write
%d@%zu.%06zu:ufs_mmio_write addr 0x%lx data 0x%lx size %d
ufs_mmio_write addr 0x%lx data 0x%lx size %d
%d@%zu.%06zu:ufs_err_utrl_slot_error UTRLDBR slot %u is in error
ufs_err_utrl_slot_error UTRLDBR slot %u is in error
%d@%zu.%06zu:ufs_err_utrl_slot_busy UTRLDBR slot %u is busy
ufs_err_utrl_slot_busy UTRLDBR slot %u is busy
%d@%zu.%06zu:ufs_process_db UTRLDBR slot %u
ufs_process_db UTRLDBR slot %u
%d@%zu.%06zu:ufs_process_uiccmd uiccmd 0x%x, ucmdarg1 0x%x, ucmdarg2 0x%x, ucmdarg3 0x%x
ufs_process_uiccmd uiccmd 0x%x, ucmdarg1 0x%x, ucmdarg2 0x%x, ucmdarg3 0x%x
%d@%zu.%06zu:ufs_err_unsupport_register_offset Register offset 0x%x is not yet supported
ufs_err_unsupport_register_offset Register offset 0x%x is not yet supported
%d@%zu.%06zu:ufs_err_mcq_create_sq_invalid_sqid invalid mcq sqid %u
ufs_err_mcq_create_sq_invalid_sqid invalid mcq sqid %u
%d@%zu.%06zu:ufs_err_mcq_create_sq_already_exists mcq sqid %ualready exists
ufs_err_mcq_create_sq_already_exists mcq sqid %ualready exists
%d@%zu.%06zu:ufs_err_mcq_create_sq_invalid_cqid invalid mcq cqid %u
ufs_err_mcq_create_sq_invalid_cqid invalid mcq cqid %u
%d@%zu.%06zu:ufs_mcq_create_sq mcq create sq sqid %u, cqid %u, addr 0x%lx, size %u
ufs_mcq_create_sq mcq create sq sqid %u, cqid %u, addr 0x%lx, size %u
%d@%zu.%06zu:ufs_err_mcq_create_cq_invalid_cqid invalid mcq cqid %u
ufs_err_mcq_create_cq_invalid_cqid invalid mcq cqid %u
%d@%zu.%06zu:ufs_err_mcq_create_cq_already_exists mcq cqid %ualready exists
ufs_err_mcq_create_cq_already_exists mcq cqid %ualready exists
%d@%zu.%06zu:ufs_mcq_create_cq mcq create cq cqid %u, addr 0x%lx, size %u
ufs_mcq_create_cq mcq create cq cqid %u, addr 0x%lx, size %u
%d@%zu.%06zu:ufs_err_mcq_db_wr_invalid_sqid invalid mcq sqid %u
ufs_err_mcq_db_wr_invalid_sqid invalid mcq sqid %u
%d@%zu.%06zu:ufs_err_mcq_db_wr_invalid_db invalid mcq doorbell sqid %u, db %u
ufs_err_mcq_db_wr_invalid_db invalid mcq doorbell sqid %u, db %u
req->state == UFS_REQUEST_RUNNING
%d@%zu.%06zu:ufs_mcq_complete_req sqid %u
%d@%zu.%06zu:ufs_complete_req UTRLDBR slot %u
ufs_complete_req UTRLDBR slot %u
%d@%zu.%06zu:ufs_exec_nop_cmd UTRLDBR slot %u
ufs_exec_nop_cmd UTRLDBR slot %u
%d@%zu.%06zu:ufs_exec_scsi_cmd slot %u, lun 0x%x, opcode 0x%x
ufs_exec_scsi_cmd slot %u, lun 0x%x, opcode 0x%x
%d@%zu.%06zu:ufs_err_scsi_cmd_invalid_lun scsi command has invalid lun: 0x%x
ufs_err_scsi_cmd_invalid_lun scsi command has invalid lun: 0x%x
%d@%zu.%06zu:ufs_exec_query_cmd slot %u, opcode 0x%x
ufs_exec_query_cmd slot %u, opcode 0x%x
%d@%zu.%06zu:ufs_err_query_invalid_idn query request has invalid idn. opcode: 0x%x, idn 0x%x
ufs_err_query_invalid_idn query request has invalid idn. opcode: 0x%x, idn 0x%x
%d@%zu.%06zu:ufs_err_query_attr_not_readable query attribute idn 0x%x is denied to read
ufs_err_query_attr_not_readable query attribute idn 0x%x is denied to read
%d@%zu.%06zu:ufs_err_query_invalid_opcode query request has invalid opcode. opcode: 0x%x
ufs_err_query_invalid_opcode query request has invalid opcode. opcode: 0x%x
%d@%zu.%06zu:ufs_err_query_attr_not_writable query attribute idn 0x%x is denied to write
ufs_err_query_attr_not_writable query attribute idn 0x%x is denied to write
%d@%zu.%06zu:ufs_err_invalid_trans_code request upiu has invalid transaction code. slot: %u, trans_code: 0x%x
ufs_err_invalid_trans_code request upiu has invalid transaction code. slot: %u, trans_code: 0x%x
%d@%zu.%06zu:ufs_err_dma_read_sq failed to read sq entry. sqid %u, hwaddr %lu
ufs_err_dma_read_sq failed to read sq entry. sqid %u, hwaddr %lu
%d@%zu.%06zu:ufs_process_req UTRLDBR slot %u
ufs_process_req UTRLDBR slot %u
ufs host controller has too many logical units.
ufs logical unit %d already exists.
/home/virus/AMD/AMD/include/hw/usb.h
%*saddr %d.%d, port %s, speed %s, name %s%s
Can't use USB bus '%s' as masterbus, it doesn't support companion controllers
usb port %s (bus %s) not found (in use?)
tried to attach usb device %s to a bus with no free ports
%d@%zu.%06zu:usb_port_claim bus %d, port %s
usb_port_claim bus %d, port %s
%d@%zu.%06zu:usb_port_release bus %d, port %s
usb_port_release bus %d, port %s
%d@%zu.%06zu:usb_port_attach bus %d, port %s, devspeed %s, portspeed %s
usb_port_attach bus %d, port %s, devspeed %s, portspeed %s
Warning: speed mismatch trying to attach usb device "%s" (%s speed) to bus "%s", port "%s" (%s speed)
%d@%zu.%06zu:usb_port_detach bus %d, port %s
usb_port_detach bus %d, port %s
  Device %d.%d, Port %s, Speed %s Mb/s, Product %s%s%s
usbdevice parameters are not supported anymore
Error: no usb bus to attach usbdevice %s, please try -machine usb=on and check that the machine model supports USB
Failed to create USB device '%s'
Failed to initialize USB device '%s': 
first->status == USB_RET_ASYNC
combined->first == p && p == QTAILQ_FIRST(&combined->packets)
dev->state == USB_STATE_NOTATTACHED
dev->state != USB_STATE_NOTATTACHED
%d@%zu.%06zu:usb_packet_state_fault bus %d, port %s, ep %d, packet %p, state %s, expected %s
usb_packet_state_fault bus %d, port %s, ep %d, packet %p, state %s, expected %s
!"usb packet state check failed"
%d@%zu.%06zu:usb_packet_state_change bus %d, port %s, ep %d, packet %p, state %s -> %s
usb_packet_state_change bus %d, port %s, ep %d, packet %p, state %s -> %s
p->stream || QTAILQ_FIRST(&ep->queue) == p
p->status != USB_RET_ASYNC && p->status != USB_RET_NAK
p->actual_length + bytes <= iov->size
usb_generic_handle_packet: ctrl buffer too small (%u > %zu)
dev->state == USB_STATE_DEFAULT
p->ep->type != USB_ENDPOINT_XFER_ISOC
p->ep->type != USB_ENDPOINT_XFER_INT || (dev->flags & (1 << USB_DEV_FLAG_IS_HOST))
p->stream || !p->ep->pipeline || QTAILQ_EMPTY(&p->ep->queue)
  Interface %d, alternative %d
    Endpoint %d, IN, %s, %d max
    Endpoint %d, OUT, %s, %d max
pid == USB_TOKEN_IN || pid == USB_TOKEN_OUT
ep > 0 && ep <= USB_MAX_ENDPOINTS
index != 0 && desc->str[index] != NULL
%d@%zu.%06zu:usb_desc_device dev %d query device, len %d, ret %d
usb_desc_device dev %d query device, len %d, ret %d
%d@%zu.%06zu:usb_desc_config dev %d query config %d, len %d, ret %d
usb_desc_config dev %d query config %d, len %d, ret %d
%d@%zu.%06zu:usb_desc_string dev %d query string %d, len %d, ret %d
usb_desc_string dev %d query string %d, len %d, ret %d
%d@%zu.%06zu:usb_desc_device_qualifier dev %d query device qualifier, len %d, ret %d
usb_desc_device_qualifier dev %d query device qualifier, len %d, ret %d
%d@%zu.%06zu:usb_desc_other_speed_config dev %d query config %d, len %d, ret %d
usb_desc_other_speed_config dev %d query config %d, len %d, ret %d
%d@%zu.%06zu:usb_desc_bos dev %d bos, len %d, ret %d
usb_desc_bos dev %d bos, len %d, ret %d
%s: %d unknown type %d (len %zd)
%d@%zu.%06zu:usb_set_addr dev %d
dev->ninterfaces <= USB_MAX_INTERFACES
%d@%zu.%06zu:usb_set_config dev %d, config %d, ret %d
usb_set_config dev %d, config %d, ret %d
%d@%zu.%06zu:usb_clear_device_feature dev %d, feature %d, ret %d
usb_clear_device_feature dev %d, feature %d, ret %d
%d@%zu.%06zu:usb_set_device_feature dev %d, feature %d, ret %d
usb_set_device_feature dev %d, feature %d, ret %d
%d@%zu.%06zu:usb_set_interface dev %d, interface %d, altsetting %d, ret %d
usb_set_interface dev %d, interface %d, altsetting %d, ret %d
%d@%zu.%06zu:usb_desc_msos dev %d msos, index 0x%x, len %d, ret %d
usb_desc_msos dev %d msos, index 0x%x, len %d, ret %d
%d@%zu.%06zu:usb_uhci_packet_unlink_async token 0x%x, td 0x%x
usb_uhci_packet_unlink_async token 0x%x, td 0x%x
%d@%zu.%06zu:usb_uhci_mmio_readw addr 0x%04x, ret 0x%04x
usb_uhci_mmio_readw addr 0x%04x, ret 0x%04x
%d@%zu.%06zu:usb_uhci_packet_del token 0x%x, td 0x%x
usb_uhci_packet_del token 0x%x, td 0x%x
%d@%zu.%06zu:usb_uhci_packet_cancel token 0x%x, td 0x%x, done %d
usb_uhci_packet_cancel token 0x%x, td 0x%x, done %d
%d@%zu.%06zu:usb_uhci_queue_del token 0x%x: %s
usb_uhci_queue_del token 0x%x: %s
%d@%zu.%06zu:usb_uhci_packet_complete_stall token 0x%x, td 0x%x
usb_uhci_packet_complete_stall token 0x%x, td 0x%x
%d@%zu.%06zu:usb_uhci_packet_complete_babble token 0x%x, td 0x%x
usb_uhci_packet_complete_babble token 0x%x, td 0x%x
%d@%zu.%06zu:usb_uhci_packet_complete_error token 0x%x, td 0x%x
usb_uhci_packet_complete_error token 0x%x, td 0x%x
%d@%zu.%06zu:usb_uhci_exit === EXIT ===
%d@%zu.%06zu:usb_uhci_reset === RESET ===
%d@%zu.%06zu:usb_uhci_mmio_writew addr 0x%04x, val 0x%04x
usb_uhci_mmio_writew addr 0x%04x, val 0x%04x
%d@%zu.%06zu:usb_uhci_schedule_start 
q == NULL || q == async->queue
%d@%zu.%06zu:usb_uhci_queue_add token 0x%x
usb_uhci_queue_add token 0x%x
%d@%zu.%06zu:usb_uhci_packet_add token 0x%x, td 0x%x
usb_uhci_packet_add token 0x%x, td 0x%x
%d@%zu.%06zu:usb_uhci_packet_link_async token 0x%x, td 0x%x
usb_uhci_packet_link_async token 0x%x, td 0x%x
%d@%zu.%06zu:usb_uhci_packet_complete_shortxfer token 0x%x, td 0x%x
usb_uhci_packet_complete_shortxfer token 0x%x, td 0x%x
%d@%zu.%06zu:usb_uhci_packet_complete_success token 0x%x, td 0x%x
usb_uhci_packet_complete_success token 0x%x, td 0x%x
%d@%zu.%06zu:usb_uhci_frame_stop_bandwidth 
usb_uhci_frame_stop_bandwidth 
%d@%zu.%06zu:usb_uhci_qh_load qh 0x%x
%d@%zu.%06zu:usb_uhci_frame_loop_stop_idle 
usb_uhci_frame_loop_stop_idle 
%d@%zu.%06zu:usb_uhci_frame_loop_continue 
usb_uhci_frame_loop_continue 
%d@%zu.%06zu:usb_uhci_td_load qh 0x%x, td 0x%x, ctrl 0x%x, token 0x%x
usb_uhci_td_load qh 0x%x, td 0x%x, ctrl 0x%x, token 0x%x
%d@%zu.%06zu:usb_uhci_td_nextqh qh 0x%x, td 0x%x
usb_uhci_td_nextqh qh 0x%x, td 0x%x
%d@%zu.%06zu:usb_uhci_td_async qh 0x%x, td 0x%x
usb_uhci_td_async qh 0x%x, td 0x%x
%d@%zu.%06zu:usb_uhci_td_complete qh 0x%x, td 0x%x
usb_uhci_td_complete qh 0x%x, td 0x%x
%d@%zu.%06zu:usb_uhci_schedule_stop 
%d@%zu.%06zu:usb_uhci_frame_start nr %d
%d@%zu.%06zu:usb_uhci_td_queue td 0x%x, ctrl 0x%x, token 0x%x
usb_uhci_td_queue td 0x%x, ctrl 0x%x, token 0x%x
%d@%zu.%06zu:usb_ohci_td_pkt_short %s data: %s
usb_ohci_td_pkt_short %s data: %s
%d@%zu.%06zu:usb_ohci_td_pkt_full %s data: %s
usb_ohci_td_pkt_full %s data: %s
%d@%zu.%06zu:usb_ohci_remote_wakeup %s: SUSPEND->RESUME
usb_ohci_remote_wakeup %s: SUSPEND->RESUME
%d@%zu.%06zu:usb_ohci_mem_read_unaligned at 0x%x
usb_ohci_mem_read_unaligned at 0x%x
%d@%zu.%06zu:usb_ohci_mem_port_read %d %s[%d] 0x%x %d -> 0x%x
usb_ohci_mem_port_read %d %s[%d] 0x%x %d -> 0x%x
%d@%zu.%06zu:usb_ohci_mem_read_bad_offset 0x%x
usb_ohci_mem_read_bad_offset 0x%x
%d@%zu.%06zu:usb_ohci_mem_read %d %s 0x%x %d -> 0x%x
usb_ohci_mem_read %d %s 0x%x %d -> 0x%x
%d@%zu.%06zu:usb_ohci_port_wakeup port #%d
usb_ohci_port_wakeup port #%d
%d@%zu.%06zu:usb_ohci_port_detach port #%d
usb_ohci_port_detach port #%d
%d@%zu.%06zu:usb_ohci_port_attach port #%d
usb_ohci_port_attach port #%d
%d@%zu.%06zu:usb_ohci_iso_td_read_failed ISO_TD read error at 0x%x
usb_ohci_iso_td_read_failed ISO_TD read error at 0x%x
%d@%zu.%06zu:usb_ohci_iso_td_head ISO_TD ED head 0x%.8x tailp 0x%.8x, flags 0x%.8x bp 0x%.8x next 0x%.8x be 0x%.8x, frame_number 0x%.8x starting_frame 0x%.8x, frame_count 0x%.8x relative %d
usb_ohci_iso_td_head ISO_TD ED head 0x%.8x tailp 0x%.8x, flags 0x%.8x bp 0x%.8x next 0x%.8x be 0x%.8x, frame_number 0x%.8x starting_frame 0x%.8x, frame_count 0x%.8x relative %d
%d@%zu.%06zu:usb_ohci_iso_td_head_offset 0x%.8x 0x%.8x 0x%.8x 0x%.8x 0x%.8x 0x%.8x 0x%.8x 0x%.8x
usb_ohci_iso_td_head_offset 0x%.8x 0x%.8x 0x%.8x 0x%.8x 0x%.8x 0x%.8x 0x%.8x 0x%.8x
%d@%zu.%06zu:usb_ohci_iso_td_relative_frame_number_neg ISO_TD R=%d < 0
usb_ohci_iso_td_relative_frame_number_neg ISO_TD R=%d < 0
%d@%zu.%06zu:usb_ohci_iso_td_relative_frame_number_big ISO_TD R=%d > FC=%d
usb_ohci_iso_td_relative_frame_number_big ISO_TD R=%d > FC=%d
%d@%zu.%06zu:usb_ohci_iso_td_bad_direction Bad direction %d
usb_ohci_iso_td_bad_direction Bad direction %d
%d@%zu.%06zu:usb_ohci_iso_td_bad_bp_be ISO_TD bp 0x%.8x be 0x%.8x
usb_ohci_iso_td_bad_bp_be ISO_TD bp 0x%.8x be 0x%.8x
%d@%zu.%06zu:usb_ohci_iso_td_bad_cc_not_accessed ISO_TD cc != not accessed 0x%.8x 0x%.8x
usb_ohci_iso_td_bad_cc_not_accessed ISO_TD cc != not accessed 0x%.8x 0x%.8x
%d@%zu.%06zu:usb_ohci_iso_td_bad_cc_overrun ISO_TD start_offset=0x%.8x > next_offset=0x%.8x
usb_ohci_iso_td_bad_cc_overrun ISO_TD start_offset=0x%.8x > next_offset=0x%.8x
%d@%zu.%06zu:usb_ohci_td_dev_error 
%d@%zu.%06zu:usb_ohci_iso_td_so 0x%.8x eo 0x%.8x sa 0x%.8x ea 0x%.8x dir %s len %zu ret %d
usb_ohci_iso_td_so 0x%.8x eo 0x%.8x sa 0x%.8x ea 0x%.8x dir %s len %zu ret %d
%d@%zu.%06zu:usb_ohci_iso_td_data_overrun DataOverrun %d > %zu
usb_ohci_iso_td_data_overrun DataOverrun %d > %zu
%d@%zu.%06zu:usb_ohci_iso_td_data_underrun DataUnderrun %d
usb_ohci_iso_td_data_underrun DataUnderrun %d
%d@%zu.%06zu:usb_ohci_iso_td_nak got NAK/STALL %d
usb_ohci_iso_td_nak got NAK/STALL %d
%d@%zu.%06zu:usb_ohci_iso_td_bad_response Bad device response %d
usb_ohci_iso_td_bad_response Bad device response %d
%d@%zu.%06zu:usb_ohci_ed_read_error ED read error at 0x%x
usb_ohci_ed_read_error ED read error at 0x%x
%d@%zu.%06zu:usb_ohci_ed_pkt ED @ 0x%.8x h=%u c=%u head=0x%.8x tailp=0x%.8x next=0x%.8x
usb_ohci_ed_pkt ED @ 0x%.8x h=%u c=%u head=0x%.8x tailp=0x%.8x next=0x%.8x
%d@%zu.%06zu:usb_ohci_ed_pkt_flags fa=%u en=%u d=%u s=%u k=%u f=%u mps=%u
usb_ohci_ed_pkt_flags fa=%u en=%u d=%u s=%u k=%u f=%u mps=%u
%d@%zu.%06zu:usb_ohci_td_skip_async 
%d@%zu.%06zu:usb_ohci_td_read_error TD read error at 0x%x
usb_ohci_td_read_error TD read error at 0x%x
%d@%zu.%06zu:usb_ohci_td_bad_pid Bad pid %s: ed.flags 0x%x td.flags 0x%x
usb_ohci_td_bad_pid Bad pid %s: ed.flags 0x%x td.flags 0x%x
%d@%zu.%06zu:usb_ohci_td_bad_direction Bad direction %d
usb_ohci_td_bad_direction Bad direction %d
%d@%zu.%06zu:usb_ohci_td_bad_buf Bad cbp = 0x%x > be = 0x%x
usb_ohci_td_bad_buf Bad cbp = 0x%x > be = 0x%x
%d@%zu.%06zu:usb_ohci_td_pkt_hdr  TD @ 0x%.8x %ld of %ld bytes %s r=%d cbp=0x%.8x be=0x%.8x
usb_ohci_td_pkt_hdr  TD @ 0x%.8x %ld of %ld bytes %s r=%d cbp=0x%.8x be=0x%.8x
%d@%zu.%06zu:usb_ohci_td_too_many_pending ep=%d
usb_ohci_td_too_many_pending ep=%d
%d@%zu.%06zu:usb_ohci_td_packet_status status=%d
usb_ohci_td_packet_status status=%d
%d@%zu.%06zu:usb_ohci_td_underrun 
%d@%zu.%06zu:usb_ohci_td_nak 
%d@%zu.%06zu:usb_ohci_td_stall 
%d@%zu.%06zu:usb_ohci_td_babble 
%d@%zu.%06zu:usb_ohci_td_bad_device_response %d
usb_ohci_td_bad_device_response %d
%d@%zu.%06zu:usb_ohci_process_lists head 0x%x, cur 0x%x
usb_ohci_process_lists head 0x%x, cur 0x%x
%d@%zu.%06zu:usb_ohci_async_complete 
%d@%zu.%06zu:usb_ohci_hcca_read_error HCCA read error at 0x%x
usb_ohci_hcca_read_error HCCA read error at 0x%x
%d@%zu.%06zu:usb_ohci_stop %s: USB Suspended
usb_ohci_stop %s: USB Suspended
%d@%zu.%06zu:usb_ohci_reset %s
%d@%zu.%06zu:usb_ohci_mem_write_unaligned at 0x%x
usb_ohci_mem_write_unaligned at 0x%x
%d@%zu.%06zu:usb_ohci_mem_port_write %d %s[%d] 0x%x %d <- 0x%x
usb_ohci_mem_port_write %d %s[%d] 0x%x %d <- 0x%x
%d@%zu.%06zu:usb_ohci_port_suspend port #%d
usb_ohci_port_suspend port #%d
%d@%zu.%06zu:usb_ohci_port_reset port #%d
%d@%zu.%06zu:usb_ohci_mem_write %d %s 0x%x %d <- 0x%x
usb_ohci_mem_write %d %s 0x%x %d <- 0x%x
%d@%zu.%06zu:usb_ohci_set_ctl %s: new state 0x%x
usb_ohci_set_ctl %s: new state 0x%x
%d@%zu.%06zu:usb_ohci_start %s: USB Operational
usb_ohci_start %s: USB Operational
%d@%zu.%06zu:usb_ohci_resume %s: USB Resume
usb_ohci_resume %s: USB Resume
%d@%zu.%06zu:usb_ohci_set_frame_interval %s: FrameInterval = 0x%x (%u)
usb_ohci_set_frame_interval %s: FrameInterval = 0x%x (%u)
%d@%zu.%06zu:usb_ohci_hub_power_down powered down all ports
usb_ohci_hub_power_down powered down all ports
%d@%zu.%06zu:usb_ohci_hub_power_up powered up all ports
usb_ohci_hub_power_up powered up all ports
%d@%zu.%06zu:usb_ohci_mem_write_bad_offset 0x%x
usb_ohci_mem_write_bad_offset 0x%x
OHCI num-ports=%u is too big (limit is %u ports)
%d@%zu.%06zu:usb_ohci_init_time usb_bit_time=%ld usb_frame_time=%ld
usb_ohci_init_time usb_bit_time=%ld usb_frame_time=%ld
%d@%zu.%06zu:usb_ohci_exit %s
%d@%zu.%06zu:usb_ehci_qtd_ptrs q %p - QTD @ 0x%08x: next 0x%08x altnext 0x%08x
usb_ehci_qtd_ptrs q %p - QTD @ 0x%08x: next 0x%08x altnext 0x%08x
%d@%zu.%06zu:usb_ehci_qtd_fields QTD @ 0x%08x - tbytes %d, cpage %d, cerr %d, pid %d
usb_ehci_qtd_fields QTD @ 0x%08x - tbytes %d, cpage %d, cerr %d, pid %d
%d@%zu.%06zu:usb_ehci_qtd_bits QTD @ 0x%08x - ioc %d, active %d, halt %d, babble %d, xacterr %d
usb_ehci_qtd_bits QTD @ 0x%08x - ioc %d, active %d, halt %d, babble %d, xacterr %d
%d@%zu.%06zu:usb_ehci_qh_ptrs q %p - QH @ 0x%08x: next 0x%08x qtds 0x%08x,0x%08x,0x%08x
usb_ehci_qh_ptrs q %p - QH @ 0x%08x: next 0x%08x qtds 0x%08x,0x%08x,0x%08x
%d@%zu.%06zu:usb_ehci_qh_fields QH @ 0x%08x - rl %d, mplen %d, eps %d, ep %d, dev %d
usb_ehci_qh_fields QH @ 0x%08x - rl %d, mplen %d, eps %d, ep %d, dev %d
%d@%zu.%06zu:usb_ehci_qh_bits QH @ 0x%08x - c %d, h %d, dtc %d, i %d
usb_ehci_qh_bits QH @ 0x%08x - c %d, h %d, dtc %d, i %d
%d@%zu.%06zu:usb_ehci_portsc_read rd mmio 0x%04x [port %d] = 0x%x
usb_ehci_portsc_read rd mmio 0x%04x [port %d] = 0x%x
%d@%zu.%06zu:usb_ehci_opreg_read rd mmio 0x%04x [%s] = 0x%x
usb_ehci_opreg_read rd mmio 0x%04x [%s] = 0x%x
%d@%zu.%06zu:usb_ehci_irq level %d, frindex 0x%04x, sts 0x%x, mask 0x%x
usb_ehci_irq level %d, frindex 0x%04x, sts 0x%x, mask 0x%x
firstport must be between 0 and %u
firstport %u asks for ports %u-%u, but port %u has a companion assigned already
%d@%zu.%06zu:usb_ehci_port_attach attach port #%d, owner %s, device %s
usb_ehci_port_attach attach port #%d, owner %s, device %s
%d@%zu.%06zu:usb_ehci_port_wakeup port #%d
usb_ehci_port_wakeup port #%d
%d@%zu.%06zu:usb_ehci_portsc_write wr mmio 0x%04x [port %d] = 0x%x
usb_ehci_portsc_write wr mmio 0x%04x [port %d] = 0x%x
%d@%zu.%06zu:usb_ehci_port_reset reset port #%d - %d
usb_ehci_port_reset reset port #%d - %d
%d@%zu.%06zu:usb_ehci_port_suspend port #%d
usb_ehci_port_suspend port #%d
%d@%zu.%06zu:usb_ehci_port_resume port #%d
usb_ehci_port_resume port #%d
%d@%zu.%06zu:usb_ehci_portsc_change ch mmio 0x%04x [port %d] = 0x%x (old: 0x%x)
usb_ehci_portsc_change ch mmio 0x%04x [port %d] = 0x%x (old: 0x%x)
p->async == EHCI_ASYNC_NONE || p->async == EHCI_ASYNC_INITIALIZED
Attempting to execute inactive qtd
guest requested more bytes than allowed
%d@%zu.%06zu:usb_ehci_guest_bug %s
%d@%zu.%06zu:usb_ehci_packet_action q %p p %p: %s
usb_ehci_packet_action q %p p %p: %s
ret from usb_handle_packet > BUFF_SIZE
%d@%zu.%06zu:usb_ehci_dma_error 
guest queued token with wrong pid
p->packet.status == USB_RET_ASYNC
%d@%zu.%06zu:usb_ehci_usbsts usbsts %s %d
%d@%zu.%06zu:usb_ehci_state %s schedule %s
usb_ehci_state %s schedule %s
p->async == EHCI_ASYNC_INITIALIZED || p->async == EHCI_ASYNC_FINISHED
EHCI: Dropping completed packet from halted %s ep %02X
%d@%zu.%06zu:usb_ehci_queue_action q %p: %s
usb_ehci_queue_action q %p: %s
%d@%zu.%06zu:usb_ehci_port_detach detach port #%d, owner %s
usb_ehci_port_detach detach port #%d, owner %s
p->async == EHCI_ASYNC_INFLIGHT
%d@%zu.%06zu:usb_ehci_reset === RESET ===
guest stopped busy async schedule
non queue head request in async schedule
FETCHENTRY: entry at %X is of type %u which is not supported yet
%d@%zu.%06zu:usb_ehci_itd ITD @ 0x%08x: next 0x%08x - mplen %d, mult %d, ep %d, dev %d
usb_ehci_itd ITD @ 0x%08x: next 0x%08x - mplen %d, mult %d, ep %d, dev %d
Unexpected iso usb result: %d
%d@%zu.%06zu:usb_ehci_sitd ITD @ 0x%08x: next 0x%08x - active %d
usb_ehci_sitd ITD @ 0x%08x: next 0x%08x - active %d
processing error - resetting ehci HC
%d@%zu.%06zu:usb_ehci_doorbell_ack 
ehci: Bad asynchronous state %d. Resetting to active
ehci: Bad periodic state %d. Resetting to active
%d@%zu.%06zu:usb_ehci_opreg_write wr mmio 0x%04x [%s] = 0x%x
usb_ehci_opreg_write wr mmio 0x%04x [%s] = 0x%x
attempt to set frame list size -- value %d
%d@%zu.%06zu:usb_ehci_doorbell_ring 
ehci: PERIODIC list base register set while periodic schedule
      is enabled and HC is enabled
ehci: ASYNC list address register set while async schedule
      is enabled and HC is enabled
%d@%zu.%06zu:usb_ehci_opreg_change ch mmio 0x%04x [%s] = 0x%x (old: 0x%x)
usb_ehci_opreg_change ch mmio 0x%04x [%s] = 0x%x (old: 0x%x)
Too many ports! Max. port number is %d.
maxframes %d out if range (8 .. 512)
%d@%zu.%06zu:usb_ehci_unrealize === UNREALIZE ===
usb_ehci_unrealize === UNREALIZE ===
/home/virus/AMD/AMD/hw/usb/hcd-ehci.h
%s: read from port register PORTHLPMC
%s: read from port offset 0x%lx
%d@%zu.%06zu:usb_xhci_port_read port %d, off 0x%04x, ret 0x%08x
usb_xhci_port_read port %d, off 0x%04x, ret 0x%08x
slotid >= 1 && slotid <= xhci->numslots
%d@%zu.%06zu:usb_xhci_doorbell_read off 0x%04x, ret 0x%08x
usb_xhci_doorbell_read off 0x%04x, ret 0x%08x
%d@%zu.%06zu:usb_xhci_queue_event v %d, idx %d, %s, %s, p 0x%016lx, s 0x%08x, c 0x%08x
usb_xhci_queue_event v %d, idx %d, %s, %s, p 0x%016lx, s 0x%08x, c 0x%08x
%s: DMA memory access failed!
%d@%zu.%06zu:usb_xhci_port_notify port %d, bits 0x%x
usb_xhci_port_notify port %d, bits 0x%x
%d@%zu.%06zu:usb_xhci_port_link port %d, pls %d
usb_xhci_port_link port %d, pls %d
%d@%zu.%06zu:usb_xhci_fetch_trb addr 0x%016lx, %s, p 0x%016lx, s 0x%08x, c 0x%08x
usb_xhci_fetch_trb addr 0x%016lx, %s, p 0x%016lx, s 0x%08x, c 0x%08x
%d@%zu.%06zu:usb_xhci_enforced_limit %s
slot->uport && slot->uport->dev
%d@%zu.%06zu:usb_xhci_port_reset port %d, warm %d
usb_xhci_port_reset port %d, warm %d
%d@%zu.%06zu:usb_xhci_unimplemented %s (0x%x)
usb_xhci_unimplemented %s (0x%x)
%d@%zu.%06zu:usb_xhci_runtime_read off 0x%04x, ret 0x%08x
usb_xhci_runtime_read off 0x%04x, ret 0x%08x
xhci: FIXME: secondary streams not implemented yet
%d@%zu.%06zu:usb_xhci_oper_read off 0x%04x, ret 0x%08x
usb_xhci_oper_read off 0x%04x, ret 0x%08x
%d@%zu.%06zu:usb_xhci_ep_state slotid %d, epid %d, %s -> %s
usb_xhci_ep_state slotid %d, epid %d, %s -> %s
%d@%zu.%06zu:usb_xhci_xfer_async %p
%d@%zu.%06zu:usb_xhci_xfer_nak %p
%d@%zu.%06zu:usb_xhci_xfer_success %p: len %d
usb_xhci_xfer_success %p: len %d
%d@%zu.%06zu:usb_xhci_xfer_error %p: ret %d
usb_xhci_xfer_error %p: ret %d
%d@%zu.%06zu:usb_xhci_ep_kick slotid %d, epid %d, streamid %d
usb_xhci_ep_kick slotid %d, epid %d, streamid %d
%d@%zu.%06zu:usb_xhci_xfer_retry %p
xfer->packet.status != USB_RET_NAK
%s: exceeded maximum transfer ring size!
%d@%zu.%06zu:usb_xhci_xfer_start %p: slotid %d, epid %d, streamid %d
usb_xhci_xfer_start %p: slotid %d, epid %d, streamid %d
%d@%zu.%06zu:usb_xhci_ep_disable slotid %d, epid %d
usb_xhci_ep_disable slotid %d, epid %d
%d@%zu.%06zu:usb_xhci_slot_disable slotid %d
usb_xhci_slot_disable slotid %d
%d@%zu.%06zu:usb_xhci_exit === EXIT ===
%d@%zu.%06zu:usb_xhci_reset === RESET ===
%d@%zu.%06zu:usb_xhci_ep_enable slotid %d, epid %d
usb_xhci_ep_enable slotid %d, epid %d
%d@%zu.%06zu:usb_xhci_runtime_write off 0x%04x, val 0x%08x
usb_xhci_runtime_write off 0x%04x, val 0x%08x
%d@%zu.%06zu:usb_xhci_cap_read off 0x%04x, ret 0x%08x
usb_xhci_cap_read off 0x%04x, ret 0x%08x
%d@%zu.%06zu:usb_xhci_oper_write off 0x%04x, val 0x%08x
usb_xhci_oper_write off 0x%04x, val 0x%08x
%d@%zu.%06zu:usb_xhci_doorbell_write off 0x%04x, val 0x%08x
usb_xhci_doorbell_write off 0x%04x, val 0x%08x
%d@%zu.%06zu:usb_xhci_slot_enable slotid %d
usb_xhci_slot_enable slotid %d
%d@%zu.%06zu:usb_xhci_slot_address slotid %d, port %s
usb_xhci_slot_address slotid %d, port %s
%d@%zu.%06zu:usb_xhci_slot_configure slotid %d
usb_xhci_slot_configure slotid %d
guest streams config not identical for all eps
device streams config not identical for all eps
%d@%zu.%06zu:usb_xhci_slot_evaluate slotid %d
usb_xhci_slot_evaluate slotid %d
%d@%zu.%06zu:usb_xhci_ep_stop slotid %d, epid %d
usb_xhci_ep_stop slotid %d, epid %d
%d@%zu.%06zu:usb_xhci_ep_reset slotid %d, epid %d
usb_xhci_ep_reset slotid %d, epid %d
%d@%zu.%06zu:usb_xhci_ep_set_dequeue slotid %d, epid %d, streamid %d, ptr 0x%016lx
usb_xhci_ep_set_dequeue slotid %d, epid %d, streamid %d, ptr 0x%016lx
%d@%zu.%06zu:usb_xhci_slot_reset slotid %d
usb_xhci_slot_reset slotid %d
%d@%zu.%06zu:usb_xhci_port_write port %d, off 0x%04x, val 0x%08x
usb_xhci_port_write port %d, off 0x%04x, val 0x%08x
%s: write 0x%lx (%u bytes) to port register at offset 0x%lx
%s: Write to read-only PORTLI register
%s: write 0x%lx (%u bytes) to unknown port register at offset 0x%lx
CC_MAX_EXIT_LATENCY_TOO_LARGE_ERROR
CR_VENDOR_NEC_FIRMWARE_REVISION
CR_VENDOR_NEC_CHALLENGE_RESPONSE
When true, disables interrupter mapping for pin-based IRQ mode. Intended to be used with guest drivers with questionable behaviour, such as macOS's.
%d@%zu.%06zu:usb_xhci_irq_msix_use nr %d
%d@%zu.%06zu:usb_xhci_irq_msix_unuse nr %d
usb_xhci_irq_msix_unuse nr %d
%s: Write to %s USB PHY register 0x%lx
%s: Read from non-existing USB PHY register 0x%lx
/home/virus/AMD/AMD/include/hw/usb/imx-usb-phy.h
%d@%zu.%06zu:usb_hub_detach dev %d, port %d
usb_hub_detach dev %d, port %d
%d@%zu.%06zu:usb_hub_attach dev %d, port %d
usb_hub_attach dev %d, port %d
%d@%zu.%06zu:usb_hub_control dev %d, req 0x%x, value %d, index %d, length %d
usb_hub_control dev %d, req 0x%x, value %d, index %d, length %d
%d@%zu.%06zu:usb_hub_get_port_status dev %d, port %d, status 0x%x, changed 0x%x
usb_hub_get_port_status dev %d, port %d, status 0x%x, changed 0x%x
%d@%zu.%06zu:usb_hub_set_port_feature dev %d, port %d, feature %s
usb_hub_set_port_feature dev %d, port %d, feature %s
%d@%zu.%06zu:usb_hub_clear_port_feature dev %d, port %d, feature %s
usb_hub_clear_port_feature dev %d, port %d, feature %s
%d@%zu.%06zu:usb_hub_status_report dev %d, status 0x%x
usb_hub_status_report dev %d, status 0x%x
%d@%zu.%06zu:usb_hub_reset dev %d
num_ports (%d) out of range (1..%d)
Invalid usb version %d for usb hid device
%d@%zu.%06zu:usb_msd_packet_complete 
%d@%zu.%06zu:usb_msd_send_status status %d, tag 0x%x, len %zd
usb_msd_send_status status %d, tag 0x%x, len %zd
s->csw.sig == cpu_to_le32(0x53425355)
%d@%zu.%06zu:usb_msd_maxlun %d
/home/virus/AMD/AMD/include/hw/usb/msd.h
%d@%zu.%06zu:usb_msd_cmd_submit lun %u, tag 0x%x, flags 0x%08x, len %d, data-len %d
usb_msd_cmd_submit lun %u, tag 0x%x, flags 0x%08x, len %d, data-len %d
le32_to_cpu(s->csw.residue) == 0
%d@%zu.%06zu:usb_msd_data_out %d/%d
%d@%zu.%06zu:usb_msd_packet_async 
%d@%zu.%06zu:usb_msd_data_in %d/%d (scsi %d)
usb_msd_data_in %d/%d (scsi %d)
%d@%zu.%06zu:usb_msd_fatal_error 
%d@%zu.%06zu:usb_msd_cmd_complete status %d, tag 0x%x
usb_msd_cmd_complete status %d, tag 0x%x
%d@%zu.%06zu:usb_msd_cmd_cancel tag 0x%x
../hw/usb/dev-storage-classic.c
%d@%zu.%06zu:usb_uas_xfer_data dev %d, tag 0x%x, copy %d, usb-pkt %d/%d, scsi-buf %d/%d
usb_uas_xfer_data dev %d, tag 0x%x, copy %d, usb-pkt %d/%d, scsi-buf %d/%d
%s: unhandled control request (req 0x%x, val 0x%x, idx 0x%x
!"canceled usb packet not found"
%d@%zu.%06zu:usb_uas_reset dev %d
%d@%zu.%06zu:usb_uas_response dev %d, tag 0x%x, code 0x%x
usb_uas_response dev %d, tag 0x%x, code 0x%x
%d@%zu.%06zu:usb_uas_scsi_complete dev %d, tag 0x%x, status 0x%x, residue %d
usb_uas_scsi_complete dev %d, tag 0x%x, status 0x%x, residue %d
%d@%zu.%06zu:usb_uas_sense dev %d, tag 0x%x, status 0x%x
usb_uas_sense dev %d, tag 0x%x, status 0x%x
%d@%zu.%06zu:usb_uas_read_ready dev %d, tag 0x%x
usb_uas_read_ready dev %d, tag 0x%x
%d@%zu.%06zu:usb_uas_write_ready dev %d, tag 0x%x
usb_uas_write_ready dev %d, tag 0x%x
additional adb length not yet supported
%d@%zu.%06zu:usb_uas_command dev %d, tag 0x%x, lun %d, lun64 0x%08x-0x%08x
usb_uas_command dev %d, tag 0x%x, lun %d, lun64 0x%08x-0x%08x
%d@%zu.%06zu:usb_uas_tmf_abort_task dev %d, tag 0x%x, task-tag 0x%x
usb_uas_tmf_abort_task dev %d, tag 0x%x, task-tag 0x%x
%d@%zu.%06zu:usb_uas_tmf_logical_unit_reset dev %d, tag 0x%x, lun %d
usb_uas_tmf_logical_unit_reset dev %d, tag 0x%x, lun %d
%d@%zu.%06zu:usb_uas_tmf_unsupported dev %d, tag 0x%x, function 0x%x
usb_uas_tmf_unsupported dev %d, tag 0x%x, function 0x%x
%s: unknown command iu: id 0x%x
uas->status3[p->stream] == NULL
%d@%zu.%06zu:usb_uas_scsi_data dev %d, tag 0x%x, bytes %d
usb_uas_scsi_data dev %d, tag 0x%x, bytes %d
usb-audio: control transaction: request 0x%04x value 0x%04x index 0x%04x length 0x%04x
usb-audio: failed control transaction: request 0x%04x value 0x%04x index 0x%04x length 0x%04x
buf->prod % USBAUDIO_PACKET_SIZE(channels) == 0
usb-audio: output overrun (%zd bytes)
usb-audio: failed data transaction: pid 0x%x ep 0x%x len 0x%zx
%d@%zu.%06zu:usb_serial_set_flow_control dev %d:%u flow control %d
usb_serial_set_flow_control dev %d:%u flow control %d
%d@%zu.%06zu:usb_serial_handle_control dev %d:%u got control 0x%x, value 0x%x
usb_serial_handle_control dev %d:%u got control 0x%x, value 0x%x
%d@%zu.%06zu:usb_serial_set_xonxoff dev %d:%u xon 0x%x xoff 0x%x
usb_serial_set_xonxoff dev %d:%u xon 0x%x xoff 0x%x
%d@%zu.%06zu:usb_serial_set_baud dev %d:%u baud rate %d
usb_serial_set_baud dev %d:%u baud rate %d
%d@%zu.%06zu:usb_serial_unsupported_data_bits dev %d:%u unsupported data bits %d, falling back to 8
usb_serial_unsupported_data_bits dev %d:%u unsupported data bits %d, falling back to 8
%d@%zu.%06zu:usb_serial_unsupported_parity dev %d:%u unsupported parity %d
usb_serial_unsupported_parity dev %d:%u unsupported parity %d
%d@%zu.%06zu:usb_serial_unsupported_stopbits dev %d:%u unsupported stop bits %d
usb_serial_unsupported_stopbits dev %d:%u unsupported stop bits %d
%d@%zu.%06zu:usb_serial_set_data dev %d:%u parity %c, data bits %d, stop bits %d
usb_serial_set_data dev %d:%u parity %c, data bits %d, stop bits %d
%d@%zu.%06zu:usb_serial_unsupported_control dev %d:%u got unsupported/bogus control 0x%x, value 0x%x
usb_serial_unsupported_control dev %d:%u got unsupported/bogus control 0x%x, value 0x%x
%d@%zu.%06zu:usb_serial_reset dev %d:%u reset
usb_serial_reset dev %d:%u reset
%d@%zu.%06zu:usb_serial_bad_token dev %d:%u bad token
usb_serial_bad_token dev %d:%u bad token
usbnet: failed data transaction: pid 0x%x ep 0x%x len 0x%zx
usbnet: failed control transaction: request 0x%x value 0x%x index 0x%x length 0x%x
MSI USB Net RNDIS Control Interface
%d@%zu.%06zu:usb_mtp_object_alloc dev %d, handle 0x%x, path %s
usb_mtp_object_alloc dev %d, handle 0x%x, path %s
%d@%zu.%06zu:usb_mtp_add_child dev %d, handle 0x%x, path %s
usb_mtp_add_child dev %d, handle 0x%x, path %s
USB Media Transfer Protocol device
%d@%zu.%06zu:usb_mtp_object_free dev %d, handle 0x%x, path %s
usb_mtp_object_free dev %d, handle 0x%x, path %s
usb-mtp: rootdir must be configured and be an absolute path
usb-mtp: rootdir does not exist/not readable
usb-mtp: rootdir does not have write permissions
%d@%zu.%06zu:usb_mtp_op_get_device_info dev %d
usb_mtp_op_get_device_info dev %d
%d@%zu.%06zu:usb_mtp_op_get_storage_info dev %d
usb_mtp_op_get_storage_info dev %d
%d@%zu.%06zu:usb_mtp_op_get_object_info dev %d, handle 0x%x, path %s
usb_mtp_op_get_object_info dev %d, handle 0x%x, path %s
%d@%zu.%06zu:usb_mtp_reset dev %d
%d@%zu.%06zu:usb_mtp_stall dev %d, reason: %s
usb_mtp_stall dev %d, reason: %s
%d@%zu.%06zu:usb_mtp_file_monitor_event dev %d, path %s event %s
usb_mtp_file_monitor_event dev %d, path %s event %s
%d@%zu.%06zu:usb_mtp_data_in dev %d, trans 0x%x, len %d
usb_mtp_data_in dev %d, trans 0x%x, len %d
%d@%zu.%06zu:usb_mtp_success dev %d, trans 0x%x, args 0x%x, 0x%x
usb_mtp_success dev %d, trans 0x%x, args 0x%x, 0x%x
%d@%zu.%06zu:usb_mtp_error dev %d, code 0x%x, trans 0x%x, args 0x%x, 0x%x
usb_mtp_error dev %d, code 0x%x, trans 0x%x, args 0x%x, 0x%x
%d@%zu.%06zu:usb_mtp_command dev %d, code 0x%x, trans 0x%x, args 0x%x, 0x%x, 0x%x, 0x%x, 0x%x
usb_mtp_command dev %d, code 0x%x, trans 0x%x, args 0x%x, 0x%x, 0x%x, 0x%x, 0x%x
%d@%zu.%06zu:usb_mtp_op_open_session dev %d
usb_mtp_op_open_session dev %d
usb-mtp: file monitoring init failed: 
%d@%zu.%06zu:usb_mtp_op_close_session dev %d
usb_mtp_op_close_session dev %d
%d@%zu.%06zu:usb_mtp_op_get_storage_ids dev %d
usb_mtp_op_get_storage_ids dev %d
usb-mtp: failed to add watch for %s: 
%d@%zu.%06zu:usb_mtp_op_get_num_objects dev %d, handle 0x%x, path %s
usb_mtp_op_get_num_objects dev %d, handle 0x%x, path %s
%d@%zu.%06zu:usb_mtp_op_get_object_handles dev %d, handle 0x%x, path %s
usb_mtp_op_get_object_handles dev %d, handle 0x%x, path %s
%d@%zu.%06zu:usb_mtp_op_get_object dev %d, handle 0x%x, path %s
usb_mtp_op_get_object dev %d, handle 0x%x, path %s
%d@%zu.%06zu:usb_mtp_op_get_partial_object dev %d, handle 0x%x, path %s, off %d, len %d
usb_mtp_op_get_partial_object dev %d, handle 0x%x, path %s, off %d, len %d
%d@%zu.%06zu:usb_mtp_op_unknown dev %d, command code 0x%x
usb_mtp_op_unknown dev %d, command code 0x%x
(s->dataset.size == 0xFFFFFFFF) || (s->dataset.size == d->offset)
packet too small to send event
%d@%zu.%06zu:usb_mtp_nak dev %d, ep %d
%d@%zu.%06zu:usb_mtp_xfer dev %d, ep %d, %d/%d
usb_mtp_xfer dev %d, ep %d, %d/%d
usb-ccid: usb-ccid: pending answers:
usb-ccid: %s: QUEUE: reserve %d bytes
usb-ccid: usb-ccid.c: %s: len larger then max (%d>%d). discarding message.
usb-ccid: usb-ccid.c: %s: No free bulk_in buffers. discarding message.
../hw/usb/dev-smartcard-reader.c
usb-ccid: error: no pending answer to return to guest
usb-ccid supports one slot, can't add %d
usb-ccid card already full, not adding
usb-ccid: %s: got control %s (%x), value %x
usb-ccid: ccid_control abort UNIMPLEMENTED
usb-ccid: ccid_control get clock frequencies UNIMPLEMENTED
usb-ccid: ccid_control get data rates UNIMPLEMENTED
usb-ccid: got unsupported/bogus control %x, value %x
usb-ccid: %s: header incomplete
usb-ccid: usb-ccid: bulk_in: expecting more packets (%u/%u)
usb-ccid: usb-ccid: bulk_in: message size mismatch (got %u, expected %u)
usb-ccid: %s: atr contains protocol=%d
usb-ccid: %s: error: unsupported ATR protocol %d
usb-ccid: usb-ccid: not sending apdu to client, no card connected
s->pending_answers_num < PENDING_ANSWERS_NUM
usb-ccid: warning: discarded apdu
usb-ccid: handle_data: ERROR: unhandled message type %Xh
usb-ccid: %s: %zd/%d req/act to guest (BULK_IN)
usb-ccid: %s: returning short (EREMOTEIO) %d < %zd
usb-ccid: handle_data: int_in: notify_slot_change %X, requested len %zd
usb-ccid: CCID ERROR: got an APDU without pending answers
usb-ccid: APDU returned to guest %u (answer seq %d, slot %d)
%s: Bad written size (req 0x%zu, val 0x%zd)
%s: Failed to find a U2F USB device
%s: Passed hidraw does not represent a U2F HID device
%8ld.%06ld xen-usb(%s):hotplug port %d speed %d
%8ld.%06ld xen-usb(%s):id %d, status %d, length %d, errcnt %d
domU provided bogus ring requests (%#x - %#x = %u). Halting ring processing.
%8ld.%06ld xen-usb(%s):start req_id %d pipe %08x
%8ld.%06ld xen-usb(%s):unlink id %d
%8ld.%06ld xen-usb(%s):devnum 0 GET_DESCRIPTOR
%8ld.%06ld xen-usb(%s):devnum 0 SET_ADDRESS
%8ld.%06ld xen-usb(%s):iso transfer %s: buflen: %x, %d frames
%8ld.%06ld xen-usb(%s):int transfer %s: buflen: %x
%8ld.%06ld xen-usb(%s):ctrl parameter: %lx, buflen: %x
%8ld.%06ld xen-usb(%s):bulk transfer %s: buflen: %x
bad number of segments in request (%d)
segment crosses page boundary
iso request without descriptor segments
%8ld.%06ld xen-usb(%s):finished
urb-ring-ref %d, conn-ring-ref %d, remote port %d, local port %d
%8ld.%06ld xen-usb(%s):port %d removed
%8ld.%06ld xen-usb(%s):path %s
device %s illegal specification
device %s could not be opened: %s
%8ld.%06ld xen-usb(%s):port %d attached
num-ports not readable or out of bounds
usb-ver not readable or out of bounds
vfio: unsupported write size, %u bytes
%s(%s:region%d+0x%lx, 0x%lx,%d) failed: %m
%d@%zu.%06zu:vfio_region_write  (%s:region%d+0x%lx, 0x%lx, %d)
vfio_region_write  (%s:region%d+0x%lx, 0x%lx, %d)
%s(%s:region%d+0x%lx, %d) failed: %m
vfio: unsupported read size, %u bytes
%d@%zu.%06zu:vfio_region_read  (%s:region%d+0x%lx, %d) = 0x%lx
vfio_region_read  (%s:region%d+0x%lx, %d) = 0x%lx
%d@%zu.%06zu:vfio_region_unmap Region %s unmap [0x%lx - 0x%lx]
vfio_region_unmap Region %s unmap [0x%lx - 0x%lx]
Failed to %s %s eventfd signaling for interrupt 
%d@%zu.%06zu:vfio_region_mmap Region %s [0x%lx - 0x%lx]
vfio_region_mmap Region %s [0x%lx - 0x%lx]
%d@%zu.%06zu:vfio_region_mmap_fault Region %s mmaps[%d], [0x%lx - 0x%lx], fault: %d
vfio_region_mmap_fault Region %s mmaps[%d], [0x%lx - 0x%lx], fault: %d
%d@%zu.%06zu:vfio_region_exit Device %s, region %d
vfio_region_exit Device %s, region %d
%d@%zu.%06zu:vfio_region_finalize Device %s, region %d
vfio_region_finalize Device %s, region %d
%d@%zu.%06zu:vfio_region_mmaps_set_enabled Region %s mmaps enabled: %d
vfio_region_mmaps_set_enabled Region %s mmaps enabled: %d
%d@%zu.%06zu:vfio_region_sparse_mmap_header Device %s region %d: %d sparse mmap entries
vfio_region_sparse_mmap_header Device %s region %d: %d sparse mmap entries
%d@%zu.%06zu:vfio_region_sparse_mmap_entry sparse entry %d [0x%lx - 0x%lx]
vfio_region_sparse_mmap_entry sparse entry %d [0x%lx - 0x%lx]
%d@%zu.%06zu:vfio_region_setup Device %s, region %d "%s", flags: 0x%lx, offset: 0x%lx, size: 0x%lx
vfio_region_setup Device %s, region %d "%s", flags: 0x%lx, offset: 0x%lx, size: 0x%lx
%d@%zu.%06zu:vfio_get_dev_region %s index %d, %08x/%08x
vfio_get_dev_region %s index %d, %08x/%08x
Use FD passing only with iommufd backend
Could not parse remote object fd %s:
/home/virus/AMD/AMD/include/system/host_iommu_device.h
/home/virus/AMD/AMD/hw/vfio/pci.h
/home/virus/AMD/AMD/include/hw/vfio/vfio-container-base.h
/home/virus/AMD/AMD/include/exec/memory.h
%d@%zu.%06zu:vfio_migration_set_device_state  (%s) state %s
vfio_migration_set_device_state  (%s) state %s
vbasedev->ops->vfio_get_object
%d@%zu.%06zu:vfio_state_pending_estimate  (%s) precopy %lu postcopy %lu precopy initial size %lu precopy dirty size %lu
vfio_state_pending_estimate  (%s) precopy %lu postcopy %lu precopy initial size %lu precopy dirty size %lu
%d@%zu.%06zu:vfio_load_cleanup  (%s)
%d@%zu.%06zu:vfio_save_block_precopy_empty_hit  (%s)
vfio_save_block_precopy_empty_hit  (%s)
%d@%zu.%06zu:vfio_save_block  (%s) data_size %d
vfio_save_block  (%s) data_size %d
%d@%zu.%06zu:vfio_save_iterate_start  (%s)
vfio_save_iterate_start  (%s)
%d@%zu.%06zu:vfio_save_iterate  (%s) precopy initial size %lu precopy dirty size %lu
vfio_save_iterate  (%s) precopy initial size %lu precopy dirty size %lu
%s: VFIO migration is not supported with postcopy migration
%s: VFIO migration is not supported with background snapshot
/home/virus/AMD/AMD/include/hw/vmstate-if.h
%d@%zu.%06zu:vfio_state_pending_exact  (%s) precopy %lu postcopy %lu stopcopy size %lu precopy initial size %lu precopy dirty size %lu
vfio_state_pending_exact  (%s) precopy %lu postcopy %lu stopcopy size %lu precopy initial size %lu precopy dirty size %lu
%s: Failed setting device state to %s.
%d@%zu.%06zu:vfio_migration_set_state  (%s) new state %s, recover state %s
vfio_migration_set_state  (%s) new state %s, recover state %s
%s Recover state is ERROR. Resetting device
%s Setting device in recover state %s
%s: Failed setting device in recover state, err: %s. Resetting device
%s: Failed resetting device, err: %s
%d@%zu.%06zu:vfio_migration_state_notifier  (%s) state %d
vfio_migration_state_notifier  (%s) state %d
%d@%zu.%06zu:vfio_vmstate_change  (%s) running %d reason %s device state %s
vfio_vmstate_change  (%s) running %d reason %s device state %s
%d@%zu.%06zu:vfio_vmstate_change_prepare  (%s) running %d reason %s device state %s
vfio_vmstate_change_prepare  (%s) running %d reason %s device state %s
%d@%zu.%06zu:vfio_save_cleanup  (%s)
%s: Failed to allocate migration data buffer
%d@%zu.%06zu:vfio_save_setup  (%s) data buffer size %lu
vfio_save_setup  (%s) data buffer size %lu
%d@%zu.%06zu:vfio_save_complete_precopy_start  (%s)
vfio_save_complete_precopy_start  (%s)
%d@%zu.%06zu:vfio_save_complete_precopy  (%s) ret %d
vfio_save_complete_precopy  (%s) ret %d
%d@%zu.%06zu:vfio_save_device_config_state  (%s)
vfio_save_device_config_state  (%s)
vfio: Failed to save device config space of %s - 
%d@%zu.%06zu:vfio_load_device_config_state_start  (%s)
vfio_load_device_config_state_start  (%s)
%s: Failed to load device config space
%s: Failed loading device config space, end flag incorrect 0x%lx
%d@%zu.%06zu:vfio_load_device_config_state_end  (%s)
vfio_load_device_config_state_end  (%s)
%d@%zu.%06zu:vfio_load_state  (%s) data 0x%lx
vfio_load_state  (%s) data 0x%lx
%s: got DEV_CONFIG_STATE in main migration channel but doing multifd transfer
%s: SETUP STATE: EOS not found 0x%lx
%d@%zu.%06zu:vfio_load_state_device_data  (%s) size %lu ret %d
vfio_load_state_device_data  (%s) size %lu ret %d
%s: Received INIT_DATA_SENT but switchover ack is not used
%s: qemu_loadvm_approve_switchover failed, err=%d (%s)
%s: Migration is disabled for VFIO device
%s: VFIO migration is not supported in kernel
%s: Migration couldn't be initialized for VFIO device, err: %d (%s)
%s: VFIO device doesn't support device and IOMMU dirty tracking
%s: Migration is currently not supported with vIOMMU enabled
%d@%zu.%06zu:vfio_migration_realize  (%s)
%d@%zu.%06zu:vfio_load_bufs_thread_start  (%s)
vfio_load_bufs_thread_start  (%s)
../hw/vfio/migration-multifd.c
multifd->load_bufs_thread_running
multifd->load_buf_idx <= multifd->load_buf_idx_last
multifd->load_buf_idx == bufs_len
%d@%zu.%06zu:vfio_load_state_device_buffer_starved  (%s) idx %u
vfio_load_state_device_buffer_starved  (%s) idx %u
%d@%zu.%06zu:vfio_load_state_device_buffer_start  (%s)
vfio_load_state_device_buffer_start  (%s)
%d@%zu.%06zu:vfio_load_state_device_buffer_load_start  (%s) idx %u
vfio_load_state_device_buffer_load_start  (%s) idx %u
%s: writing state buffer %u failed: %d
%d@%zu.%06zu:vfio_load_state_device_buffer_load_end  (%s) idx %u
vfio_load_state_device_buffer_load_end  (%s) idx %u
%d@%zu.%06zu:vfio_load_state_device_buffer_end  (%s)
vfio_load_state_device_buffer_end  (%s)
multifd->load_buf_idx == multifd->load_buf_idx_last
%s: load config state flush failed: %d
%s: expected FLAG_DEV_CONFIG_STATE but got %lx
%s: vfio_load_device_config_state() failed: %d
%d@%zu.%06zu:vfio_load_bufs_thread_end  (%s)
vfio_load_bufs_thread_end  (%s)
%s: got device state packet but not doing multifd transfer
%s: packet too short at %zu (min is %zu)
%s: packet has unknown version %u
%d@%zu.%06zu:vfio_load_state_device_buffer_incoming  (%s) idx %u
vfio_load_state_device_buffer_incoming  (%s) idx %u
%s: state buffer %u already filled
packet->idx >= multifd->load_buf_idx
%s: Multifd device transfer requested but unsupported in the current config
vfio_multifd_transfer_enabled(vbasedev)
%d@%zu.%06zu:vfio_save_complete_precopy_thread_start  (%s) idstr %s instance %u
vfio_save_complete_precopy_thread_start  (%s) idstr %s instance %u
%s: reading state buffer %u failed: %d
%s: multifd data queuing failed
%s: save config state flush failed: %d
%s: multifd config data queuing failed
%d@%zu.%06zu:vfio_save_complete_precopy_thread_end  (%s) ret %d
vfio_save_complete_precopy_thread_end  (%s) ret %d
!multifd->load_bufs_thread_running
VFIO device only supports cpr-reboot for runstate suspended
[iommufd=%d] error attach %s (%d) to id=%d
%d@%zu.%06zu:iommufd_cdev_attach_ioas_hwpt  [iommufd=%d] Successfully attached device %s (%d) to id=%d
iommufd_cdev_attach_ioas_hwpt  [iommufd=%d] Successfully attached device %s (%d) to id=%d
IOMMU instance for device %s doesn't support dirty tracking
%d@%zu.%06zu:iommufd_cdev_detach_ioas_hwpt  [iommufd=%d] Successfully detached %s
iommufd_cdev_detach_ioas_hwpt  [iommufd=%d] Successfully detached %s
host-iommu-device-iommufd-vfio
%d@%zu.%06zu:vfio_pci_hot_reset  (%s) %s
info->flags & VFIO_PCI_HOT_RESET_FLAG_DEV_ID
vfio: Cannot reset device %s, depends on device %04x:%02x:%02x.%x which is not owned.
%d@%zu.%06zu:vfio_pci_hot_reset_has_dep_devices %s: hot reset dependent devices:
vfio_pci_hot_reset_has_dep_devices %s: hot reset dependent devices:
%d@%zu.%06zu:iommufd_cdev_pci_hot_reset_dep_devices 	%04x:%02x:%02x.%x devid %d
iommufd_cdev_pci_hot_reset_dep_devices 	%04x:%02x:%02x.%x devid %d
devices[i].devid != VFIO_PCI_DEVID_NOT_OWNED
%d@%zu.%06zu:vfio_pci_hot_reset_result %s hot reset: %s
vfio_pci_hot_reset_result %s hot reset: %s
failed to find vfio-dev/vfioX/dev
failed to get major:minor for "%s"
%d@%zu.%06zu:iommufd_cdev_getfd  %s (fd=%d)
iommufd_cdev_getfd  %s (fd=%d)
error bind device fd=%d to iommufd=%d
%d@%zu.%06zu:iommufd_cdev_connect_and_bind  [iommufd=%d] Successfully bound device %s (fd=%d): output devid=%d
iommufd_cdev_connect_and_bind  [iommufd=%d] Successfully bound device %s (fd=%d): output devid=%d
%d@%zu.%06zu:iommufd_cdev_fail_attach_existing_container  %s
iommufd_cdev_fail_attach_existing_container  %s
Cannot set discarding of RAM broken
%d@%zu.%06zu:iommufd_cdev_alloc_ioas  [iommufd=%d] new IOMMUFD container with ioasid=%d
iommufd_cdev_alloc_ioas  [iommufd=%d] new IOMMUFD container with ioasid=%d
/home/virus/AMD/AMD/include/hw/vfio/vfio-common.h
Fallback to default 64bit IOVA range and 4K page size
memory listener initialization failed: 
%d@%zu.%06zu:iommufd_cdev_device_info  %s (%d) num_irqs=%d num_regions=%d flags=%d
iommufd_cdev_device_info  %s (%d) num_irqs=%d num_regions=%d flags=%d
ioctl VFIO_DEVICE_QUERY_GFX_PLANE: %s
dpy->region.buffer.mmaps[0].mmap != NULL
%d@%zu.%06zu:vfio_display_edid_write_error 
vfio_display_edid_write_error 
%d@%zu.%06zu:vfio_display_edid_link_up 
%d@%zu.%06zu:vfio_display_edid_link_down 
%d@%zu.%06zu:vfio_display_edid_update %ux%u
vfio_display_edid_update %ux%u
vfio-display-dmabuf: opengl not available
%d@%zu.%06zu:vfio_display_edid_available 
vfio: failed to read GFX edid field
vfio: device doesn't support any (known) display method
iommu_platform=true is not supported by the device
%s: failed. Fallback to userspace (slower).
%s: unable to init event notifier: %s (%d)
%s: unable to assign ioeventfd: %d
IOThread "%s" object does not exist
../hw/virtio/iothread-vq-mapping.c
duplicate IOThread name "%s" in iothread-vq-mapping
either all items in iothread-vq-mapping must have vqs or none of them must have it
vq index %u for IOThread "%s" must be less than num_queues %u in iothread-vq-mapping
cannot assign vq %u to IOThread "%s" because it is already assigned
missing vq %u IOThread assignment in iothread-vq-mapping
%d@%zu.%06zu:virtio_pci_notify_write 0x%lx = 0x%lx (%d)
virtio_pci_notify_write 0x%lx = 0x%lx (%d)
%d@%zu.%06zu:virtio_pci_notify_write_pio 0x%lx = 0x%lx (%d)
virtio_pci_notify_write_pio 0x%lx = 0x%lx (%d)
vdev->device_endian != VIRTIO_DEVICE_ENDIAN_UNKNOWN
!(((uintptr_t)buf) & (len - 1))
wrong value for queue_enable %lx
device cannot work as neither modern nor legacy mode is enabled
Set either disable-modern or disable-legacy to off
%s: unexpected address 0x%x value 0x%x
Device doesn't support modern mode, and legacy mode is disabled
device is modern-only, but for backward compatibility legacy is allowed
device is modern-only, use disable-legacy=on
VIRTIO_F_IOMMU_PLATFORM was supported by neither legacy nor transitional device
unable to init msix vectors to %u
assign || nvqs == proxy->nvqs_with_notifiers
virtio-pci-bus-master-bug-migration
virtio_mmio_read virtio_mmio_read offset 0x%lx
%d@%zu.%06zu:virtio_mmio_read virtio_mmio_read offset 0x%lx
%s: wrong size access to register!
%s: read from legacy register (0x%lx) in non-legacy mode
%s: read from non-legacy register (0x%lx) in legacy mode
%s: read of write-only register (0x%lx)
%s: bad register offset (0x%lx)
/home/virus/AMD/AMD/include/hw/virtio/virtio-mmio.h
%d@%zu.%06zu:virtio_mmio_setting_irq virtio_mmio setting IRQ %d
virtio_mmio_setting_irq virtio_mmio setting IRQ %d
virtio_mmio_write_offset virtio_mmio_write offset 0x%lx value 0x%lx
%d@%zu.%06zu:virtio_mmio_write_offset virtio_mmio_write offset 0x%lx value 0x%lx
%s: attempt to write guest features with guest_features_sel > 0 in legacy mode
%s: write to legacy register (0x%lx) in non-legacy mode
%d@%zu.%06zu:virtio_mmio_guest_page guest page size 0x%lx shift %d
virtio_mmio_guest_page guest page size 0x%lx shift %d
%d@%zu.%06zu:virtio_mmio_queue_write mmio_queue write 0x%lx max %d
virtio_mmio_queue_write mmio_queue write 0x%lx max %d
%s: write to non-legacy register (0x%lx) in legacy mode
%s: write to read-only register (0x%lx)
/home/virus/AMD/AMD/include/hw/virtio/virtio-crypto.h
virtio-crypto status incorrect
unable to start vhost crypto: %d: falling back on userspace virtio
'cryptodev' parameter expects a valid object
can't use already used cryptodev backend: %s
Invalid number of queues (= %u), must be a positive integer less than %d.
virtio-crypto length of cipher key is too big: %u
virtio-crypto cipher key incorrect
virtio-crypto dest data incorrect
virtio-crypto digest result incorrect
virtio-crypto asym dest data incorrect
sym request src len is different from dst len
virtio-crypto additional auth data incorrect
virtio-crypto source data incorrect
virtio-crypto dataq missing headers
virtio-crypto request outhdr too short
virtio-crypto request inhdr too short
virtio-crypto unsupported cipher type
virtio-crypto asym src data incorrectexpected %u, actual %u
virtio-crypto asym dst data incorrectexpected %u, actual %u
virtio-crypto unsupported dataq opcode: %u
virtio-crypto ctrl missing headers
virtio-crypto request ctrl_hdr too short
virtio-crypto length of auth key is too big: %u
virtio-crypto authenticated key incorrect
unsupported cipher op_type: VIRTIO_CRYPTO_SYM_OP_NONE
virtio-crypto asym key incorrect
virtio-crypto unsupported ctrl opcode: %d
vhost-vsock missed transport reset event
invalid vhost-vsock event virtqueue element with out buffers
vhost-vsock event virtqueue element is too short
/home/virus/AMD/AMD/include/hw/virtio/vhost-vsock-common.h
vhost-vsock backend doesn't support seqpacket
../hw/virtio/vhost-vsock-common.c
vhost guest notifier cleanup failed: %d
!vhost_dev_is_started(&vvc->vhost_dev)
%d@%zu.%06zu:virtio_iommu_device_status driver status = %d
virtio_iommu_device_status driver status = %d
%d@%zu.%06zu:virtio_iommu_freeze_granule granule set to 0x%lx
virtio_iommu_freeze_granule granule set to 0x%lx
Virtio-iommu does not support dev-iotlb yet
%d@%zu.%06zu:virtio_iommu_notify_flag_add add notifier to mr %s
virtio_iommu_notify_flag_add add notifier to mr %s
%d@%zu.%06zu:virtio_iommu_notify_flag_del del notifier from mr %s
virtio_iommu_notify_flag_del del notifier from mr %s
%d@%zu.%06zu:virtio_iommu_notify_unmap mr=%s virt_start=0x%lx virt_end=0x%lx
virtio_iommu_notify_unmap mr=%s virt_start=0x%lx virt_end=0x%lx
%d@%zu.%06zu:virtio_iommu_notify_map mr=%s virt_start=0x%lx virt_end=0x%lx phys_start=0x%lx flags=%d
virtio_iommu_notify_map mr=%s virt_start=0x%lx virt_end=0x%lx phys_start=0x%lx flags=%d
%d@%zu.%06zu:virtio_iommu_remap mr=%s virt_start=0x%lx virt_end=0x%lx phys_start=0x%lx
virtio_iommu_remap mr=%s virt_start=0x%lx virt_end=0x%lx phys_start=0x%lx
%d@%zu.%06zu:virtio_iommu_switch_address_space Device %02x:%02x.%x switching address space (iommu enabled=%d)
virtio_iommu_switch_address_space Device %02x:%02x.%x switching address space (iommu enabled=%d)
%d@%zu.%06zu:virtio_iommu_system_reset system reset!
virtio_iommu_system_reset system reset!
%d@%zu.%06zu:virtio_iommu_init_iommu_mr init %s
virtio_iommu_init_iommu_mr init %s
%d@%zu.%06zu:virtio_iommu_detach_endpoint_from_domain domain=%d endpoint=%d
virtio_iommu_detach_endpoint_from_domain domain=%d endpoint=%d
%d@%zu.%06zu:virtio_iommu_put_endpoint Free endpoint=%d
virtio_iommu_put_endpoint Free endpoint=%d
%d@%zu.%06zu:virtio_iommu_put_domain Free domain=%d
virtio_iommu_put_domain Free domain=%d
Host IOMMU device already exists
%s virtio-iommu does not support aliased BDF
%d@%zu.%06zu:virtio_iommu_host_resv_regions mr=%s host-resv-reg[%d] = [0x%lx,0x%lx]
virtio_iommu_host_resv_regions mr=%s host-resv-reg[%d] = [0x%lx,0x%lx]
virtio-iommu reports a page size mask 0x%lx incompatible with currently supported mask 0x%lx
virtio-iommu does not support frozen granule 0x%llx
%d@%zu.%06zu:virtio_iommu_update_page_size_mask host iommu device=%s old_mask=0x%lx new_mask=0x%lx
virtio_iommu_update_page_size_mask host iommu device=%s old_mask=0x%lx new_mask=0x%lx
no buffer available in event queue to report event
%d@%zu.%06zu:virtio_iommu_report_fault FAULT reason=%d flags=%d endpoint=%d address =0x%lx
virtio_iommu_report_fault FAULT reason=%d flags=%d endpoint=%d address =0x%lx
%d@%zu.%06zu:virtio_iommu_translate mr=%s rid=%d addr=0x%lx flag=%d
virtio_iommu_translate mr=%s rid=%d addr=0x%lx flag=%d
ep && ep->domain && !ep->domain->bypass
%s %02x:%02x.%01x not attached to any domain
%s no mapping for 0x%lx for sid=%d
%s permission error on 0x%lx(%d): allowed=%d
%d@%zu.%06zu:virtio_iommu_translate_out 0x%lx -> 0x%lx for sid=%d
virtio_iommu_translate_out 0x%lx -> 0x%lx for sid=%d
/home/virus/AMD/AMD/include/hw/virtio/virtio-iommu.h
%d@%zu.%06zu:virtio_iommu_get_features device supports features=0x%lx
virtio_iommu_get_features device supports features=0x%lx
invalid config.bypass value '%u'
%d@%zu.%06zu:virtio_iommu_set_config bypass=0x%x
virtio_iommu_set_config bypass=0x%x
%d@%zu.%06zu:virtio_iommu_device_reset_exit reset!
virtio_iommu_device_reset_exit reset!
%d@%zu.%06zu:virtio_iommu_get_config page_size_mask=0x%lx input range start=0x%lx input range end=0x%lx domain range start=%u domain range end=%u probe_size=0x%x bypass=0x%x
virtio_iommu_get_config page_size_mask=0x%lx input range start=0x%lx input range end=0x%lx domain range start=%u domain range end=%u probe_size=0x%x bypass=0x%x
aw-bits must be within [32,64]
VIRTIO-IOMMU is not attached to any PCI bus!
virtio-iommu bad head/tail size
%s: read %zu bytes from command headbut expected %zu
%d@%zu.%06zu:virtio_iommu_attach domain=%d endpoint=%d
virtio_iommu_attach domain=%d endpoint=%d
%d@%zu.%06zu:virtio_iommu_get_endpoint Alloc endpoint=%d
virtio_iommu_get_endpoint Alloc endpoint=%d
%d@%zu.%06zu:virtio_iommu_get_domain Alloc domain=%d
virtio_iommu_get_domain Alloc domain=%d
%d@%zu.%06zu:virtio_iommu_detach domain=%d endpoint=%d
virtio_iommu_detach domain=%d endpoint=%d
%d@%zu.%06zu:virtio_iommu_map domain=%d virt_start=0x%lx virt_end=0x%lx phys_start=0x%lx flags=%d
virtio_iommu_map domain=%d virt_start=0x%lx virt_end=0x%lx phys_start=0x%lx flags=%d
%d@%zu.%06zu:virtio_iommu_unmap domain=%d virt_start=0x%lx virt_end=0x%lx
virtio_iommu_unmap domain=%d virt_start=0x%lx virt_end=0x%lx
%d@%zu.%06zu:virtio_iommu_unmap_done domain=%d virt_start=0x%lx virt_end=0x%lx
virtio_iommu_unmap_done domain=%d virt_start=0x%lx virt_end=0x%lx
subtype == VIRTIO_IOMMU_RESV_MEM_T_RESERVED || subtype == VIRTIO_IOMMU_RESV_MEM_T_MSI
%d@%zu.%06zu:virtio_iommu_fill_resv_property dev= %d, type=%d start=0x%lx end=0x%lx
virtio_iommu_fill_resv_property dev= %d, type=%d start=0x%lx end=0x%lx
%s: wrote %zu bytes to command responsebut response size is %zu
VDPA-based generic device assignment
vhost-vdpa-device: cmd 0x%lx failed: %s
/home/virus/AMD/AMD/include/hw/virtio/vdpa-dev.h
get device config space failed
vhost-vdpa-device: start failed: 
vhost-vdpa-device: vhostdev are missing
vhost-vdpa-device: invalid queue_size: %u (max:%u)
invalid number of virtqueues: %u (max:%u)
vhost-vdpa-device: get iova range failed: %s
vhost-vdpa-device: vhost initialization failed: %s
vhost-vdpa-device: get config failed
vhost_set_vring_endian failed: %s (%d)
vhost_set_vring_busyloop_timeout failed: %s (%d)
vhost vring error in virtqueue %d: %s (%d)
vhost_vq_get_addr failed: %s (%d)
vhost_set_vring_addr failed: %s (%d)
Fail to invalidate device iotlb
end / VHOST_LOG_CHUNK < dev->log_size
start / VHOST_LOG_CHUNK < dev->log_size
vhost_set_features failed: %s (%d)
vhost_set_backend_cap failed: %s (%d)
dev->vhost_ops->backend_type > VHOST_BACKEND_TYPE_NONE
dev->vhost_ops->backend_type < VHOST_BACKEND_TYPE_MAX
translation failure for used_iova %lx
vhost_set_log_base failed: %s (%d)
%d@%zu.%06zu:vhost_reject_section %s:%d
%d@%zu.%06zu:vhost_section %s
%d@%zu.%06zu:vhost_region_add_section %s: 0x%lx+0x%lx @ 0x%lx
vhost_region_add_section %s: 0x%lx+0x%lx @ 0x%lx
%d@%zu.%06zu:vhost_region_add_section_aligned %s: 0x%lx+0x%lx @ 0x%lx
vhost_region_add_section_aligned %s: 0x%lx+0x%lx @ 0x%lx
%s:Section '%s' rounded to %lx prior to previous '%s' %lx
%d@%zu.%06zu:vhost_region_add_section_merge %s: size: 0x%lx gpa: 0x%lx owr: 0x%lx
vhost_region_add_section_merge %s: size: 0x%lx gpa: 0x%lx owr: 0x%lx
%s: Overlapping but not coherent sections at %lx
vhost_commit Started: %d Changed: %d
%d@%zu.%06zu:vhost_commit Started: %d Changed: %d
Verify ring failure on region %d
vhost_set_mem_table failed: %s (%d)
%d@%zu.%06zu:vhost_iotlb_miss %p step %d
Fail to lookup the translated address %lx
vhost VQ %u ring restore failed: %d: %s (%d)
%d@%zu.%06zu:vhost_dev_cleanup %p
dev->vhost_ops->backend_type == backend_type
some memory device (like virtio-mem) decided how many memory slots to use based on the overall number of memory slots; this vhost backend would further restricts the overall number of memory slots
Try plugging this vhost backend before plugging such memory devices.
vhost_set_vring_call failed: %s (%d)
vhost_set_vring_err failed: %s (%d)
Failed to initialize virtqueue %d
Failed to set busyloop timeout
Migration disabled: vhost lacks VHOST_F_LOG_ALL feature.
Migration disabled: failed to allocate shared memory
vhost backend memory slots limit (%d) is less than current number of used (%d) and reserved (%d) memory slots for memory devices.
vhost VQ %d notifier cleanup failed: %d
binding does not support host notifiers
vhost VQ %d notifier binding failed: %d
n >= hdev->vq_index && n < hdev->vq_index + hdev->nvqs
vhost_set_vring_call failed %d
vhost_set_vring_num failed: %s (%d)
vhost_set_vring_base failed: %s (%d)
vhost_set_vring_kick failed: %s (%d)
vhost_set_config_call failed %d
vhost_get_config not implemented
vhost_dev_prepare_inflight failed: %s (%d)
vhost_set_inflight_fd failed: %s (%d)
vhost_get_inflight_fd failed: %s (%d)
%d@%zu.%06zu:vhost_dev_start %p:%s vrings:%d
vhost_dev_start %p:%s vrings:%d
event_notifier_init failed: %s (%d)
%d@%zu.%06zu:vhost_dev_stop %p:%s vrings:%d
vhost_dev_stop %p:%s vrings:%d
vhost transport does not support migration state transfer
Failed to set up state transfer pipe: %s
Failed to initiate state transfer: 
Failed to send state: Connection is closed
/home/virus/AMD/AMD/include/hw/virtio/vhost-user-base.h
../hw/virtio/vhost-user-base.c
vub->config_size && vub->vhost_user.supports_config == true
vhost guest set device config space failed: %d
Error starting vhost-user-base: %d
vhost-user-base: missing chardev
vhost-user-base: need to define device id
../hw/virtio/vhost-user-device-pci.c
../hw/virtio/vhost-user-gpio-pci.c
../hw/virtio/vhost-user-i2c-pci.c
../hw/virtio/vhost-user-rng-pci.c
../hw/virtio/vhost-user-snd-pci.c
../hw/virtio/vhost-user-input-pci.c
%d@%zu.%06zu:vhost_vdpa_set_mem_table dev: %p nregions: %u padding: 0x%x
vhost_vdpa_set_mem_table dev: %p nregions: %u padding: 0x%x
%d@%zu.%06zu:vhost_vdpa_dump_regions dev: %p %d: guest_phys_addr: 0x%lx memory_size: 0x%lx userspace_addr: 0x%lx flags_padding: 0x%lx
vhost_vdpa_dump_regions dev: %p %d: guest_phys_addr: 0x%lx memory_size: 0x%lx userspace_addr: 0x%lx flags_padding: 0x%lx
dev->vhost_ops->backend_type == VHOST_BACKEND_TYPE_VDPA
%d@%zu.%06zu:vhost_vdpa_vq_get_addr dev: %p vq: %p desc_user_addr: 0x%lx avail_user_addr: 0x%lx used_user_addr: 0x%lx
vhost_vdpa_vq_get_addr dev: %p vq: %p desc_user_addr: 0x%lx avail_user_addr: 0x%lx used_user_addr: 0x%lx
idx >= dev->vq_index && idx < dev->vq_index + dev->nvqs
%d@%zu.%06zu:vhost_vdpa_get_vq_index dev: %p idx: %d vq idx: %d
vhost_vdpa_get_vq_index dev: %p idx: %d vq idx: %d
%d@%zu.%06zu:vhost_vdpa_skipped_memory_section is_ram=%d, is_iommu=%d, is_protected=%d, is_ram_device=%d iova_min=0x%lx iova_last=0x%lx page_mask=0x%x
vhost_vdpa_skipped_memory_section is_ram=%d, is_iommu=%d, is_protected=%d, is_ram_device=%d iova_min=0x%lx iova_last=0x%lx page_mask=0x%x
RAM section out of device range (min=0x%lx, addr=0x%lx)
RAM section out of device range (max=0x%lx, end addr=0x%lx)
%d@%zu.%06zu:vhost_vdpa_memslots_limit dev: %p = 0x%x
vhost_vdpa_memslots_limit dev: %p = 0x%x
%d@%zu.%06zu:vhost_vdpa_listener_commit vdpa_shared:%p fd: %d msg_type: %u type: %u
vhost_vdpa_listener_commit vdpa_shared:%p fd: %d msg_type: %u type: %u
failed to write, fd=%d, errno=%d (%s)
%d@%zu.%06zu:vhost_vdpa_listener_begin_batch vdpa_shared:%p fd: %d msg_type: %u type: %u
vhost_vdpa_listener_begin_batch vdpa_shared:%p fd: %d msg_type: %u type: %u
%d@%zu.%06zu:vhost_vdpa_set_log_base dev: %p base: 0x%lx size: %llu refcnt: %d fd: %d log: %p
vhost_vdpa_set_log_base dev: %p base: 0x%lx size: %llu refcnt: %d fd: %d log: %p
%d@%zu.%06zu:vhost_vdpa_set_owner dev: %p
%d@%zu.%06zu:vhost_vdpa_set_vring_addr dev: %p index: %u flags: 0x%x desc_user_addr: 0x%lx used_user_addr: 0x%lx avail_user_addr: 0x%lx log_guest_addr: 0x%lx
vhost_vdpa_set_vring_addr dev: %p index: %u flags: 0x%x desc_user_addr: 0x%lx used_user_addr: 0x%lx avail_user_addr: 0x%lx log_guest_addr: 0x%lx
%d@%zu.%06zu:vhost_vdpa_add_status dev: %p status: 0x%x
vhost_vdpa_add_status dev: %p status: 0x%x
%d@%zu.%06zu:vhost_vdpa_set_features dev: %p features: 0x%lx
vhost_vdpa_set_features dev: %p features: 0x%lx
%d@%zu.%06zu:vhost_vdpa_dump_config dev: %p 0x%04x: %s
vhost_vdpa_dump_config dev: %p 0x%04x: %s
%d@%zu.%06zu:vhost_vdpa_set_config dev: %p offset: %u size: %u flags: 0x%x
vhost_vdpa_set_config dev: %p offset: %u size: %u flags: 0x%x
%d@%zu.%06zu:vhost_vdpa_get_config dev: %p config: %p config_len: %u
vhost_vdpa_get_config dev: %p config: %p config_len: %u
%d@%zu.%06zu:vhost_vdpa_set_vring_enable_one dev: %p, idx: %u, enable: %u, r: %d
vhost_vdpa_set_vring_enable_one dev: %p, idx: %u, enable: %u, r: %d
%d@%zu.%06zu:vhost_vdpa_init dev: %p, common dev: %p vdpa: %p
vhost_vdpa_init dev: %p, common dev: %p vdpa: %p
%d@%zu.%06zu:vhost_vdpa_get_features dev: %p features: 0x%lx
vhost_vdpa_get_features dev: %p features: 0x%lx
%d@%zu.%06zu:vhost_vdpa_cleanup dev: %p vdpa: %p
vhost_vdpa_cleanup dev: %p vdpa: %p
%d@%zu.%06zu:vhost_vdpa_get_vring_base dev: %p index: %u num: %u svq: %d
vhost_vdpa_get_vring_base dev: %p index: %u num: %u svq: %d
%d@%zu.%06zu:vhost_vdpa_set_config_call dev: %p fd: %d
vhost_vdpa_set_config_call dev: %p fd: %d
%d@%zu.%06zu:vhost_vdpa_get_device_id dev: %p device_id %u
vhost_vdpa_get_device_id dev: %p device_id %u
%d@%zu.%06zu:vhost_vdpa_reset_device dev: %p
vhost_vdpa_reset_device dev: %p
%d@%zu.%06zu:vhost_vdpa_set_vring_kick dev: %p index: %u fd: %d
vhost_vdpa_set_vring_kick dev: %p index: %u fd: %d
%d@%zu.%06zu:vhost_vdpa_set_vring_call dev: %p index: %u fd: %d
vhost_vdpa_set_vring_call dev: %p index: %u fd: %d
%d@%zu.%06zu:vhost_vdpa_set_vring_num dev: %p index: %u num: %u
vhost_vdpa_set_vring_num dev: %p index: %u num: %u
%d@%zu.%06zu:vhost_vdpa_set_dev_vring_base dev: %p index: %u num: %u svq: %d
vhost_vdpa_set_dev_vring_base dev: %p index: %u num: %u svq: %d
%d@%zu.%06zu:vhost_vdpa_dma_map vdpa_shared:%p fd: %d msg_type: %u asid: %u iova: 0x%lx size: 0x%lx uaddr: 0x%lx perm: 0x%x type: %u
vhost_vdpa_dma_map vdpa_shared:%p fd: %d msg_type: %u asid: %u iova: 0x%lx size: 0x%lx uaddr: 0x%lx perm: 0x%x type: %u
Insertion to IOVA->HVA tree failed
%d@%zu.%06zu:vhost_vdpa_listener_region_add_unaligned vdpa_shared: %p region %s offset_within_address_space %lu offset_within_region %lu
vhost_vdpa_listener_region_add_unaligned vdpa_shared: %p region %s offset_within_address_space %lu offset_within_region %lu
%d@%zu.%06zu:vhost_vdpa_listener_region_add vdpa: %p iova 0x%lx llend 0x%lx vaddr: %p read-only: %d
vhost_vdpa_listener_region_add vdpa: %p iova 0x%lx llend 0x%lx vaddr: %p read-only: %d
Insertion to GPA->IOVA tree failed
vhost-vdpa: DMA mapping failed, unable to continue
%d@%zu.%06zu:vhost_vdpa_dma_unmap vdpa_shared:%p fd: %d msg_type: %u asid: %u iova: 0x%lx size: 0x%lx type: %u
vhost_vdpa_dma_unmap vdpa_shared:%p fd: %d msg_type: %u asid: %u iova: 0x%lx size: 0x%lx type: %u
Unable to find SVQ address to unmap
Unable to unmap SVQ vring: %s (%d)
%d@%zu.%06zu:vhost_vdpa_dev_start dev: %p started: %d
vhost_vdpa_dev_start dev: %p started: %d
vhost-vdpa/host-notifier@%p mmaps[%d]
Couldn't create kick event notifier
Couldn't create call event notifier
Cannot create vq driver region: 
Cannot create vq device region: 
%d@%zu.%06zu:vhost_vdpa_suspend dev: %p
SVQ can not work while IOMMU enable, please disableIOMMU and try again
%d@%zu.%06zu:vhost_vdpa_listener_region_del_unaligned vdpa_shared: %p region %s offset_within_address_space %lu offset_within_region %lu
vhost_vdpa_listener_region_del_unaligned vdpa_shared: %p region %s offset_within_address_space %lu offset_within_region %lu
%d@%zu.%06zu:vhost_vdpa_listener_region_del vdpa: %p iova 0x%lx llend 0x%lx
vhost_vdpa_listener_region_del vdpa: %p iova 0x%lx llend 0x%lx
vhost_vdpa_dma_unmap(%p, 0x%lx, 0x%lx) = %d (%m)
Wrong target AS "%s", only system memory is allowed
vhost_vdpa_dma_map(%p, 0x%lx, 0x%lx, %p) = %d (%m)
  device_name:             %s %s
  device_id:               %d
  vhost_started:           %s
  bus_name:                %s
  broken:                  %s
  disabled:                %s
  disable_legacy_check:    %s
  started:                 %s
  use_started:             %s
  start_on_kick:           %s
  use_guest_notifier_mask: %s
  vm_running:              %s
  num_vqs:                 %ld
  queue_sel:               %d
  isr:                     %d
  endianness:              %s
  unknown-protocols(0x%016lx)
  device_name:          %s (vhost)
%d@%zu.%06zu:watchdog_perform_action action=%u
watchdog_perform_action action=%u
%d@%zu.%06zu:watchdog_set_action action=%u
watchdog_set_action action=%u
i6300esb_timer_expired: I would send APIC 1 INT 10 here if I knew how (XXX)
i6300esb_timer_expired: I would send SMI here if I knew how (XXX)
attempt to register duplicate Xen backend type '%s'
backend type '%s' has no creator
%d@%zu.%06zu:xs_node_create %s
%d@%zu.%06zu:xs_node_destroy %s
%d@%zu.%06zu:xs_node_vprintf %s %s
%d@%zu.%06zu:xs_node_read %s %s
%d@%zu.%06zu:xs_node_watch %s
%*sname = '%s' frontend_id = %u
%d@%zu.%06zu:xen_bus_enumerate 
%d@%zu.%06zu:xen_bus_type_enumerate type: %s
xen_bus_type_enumerate type: %s
%d@%zu.%06zu:xen_bus_backend_create type: %s path: %s
xen_bus_backend_create type: %s path: %s
failed to create '%s' device '%s': 
%d@%zu.%06zu:xen_bus_cleanup 
%d@%zu.%06zu:xen_bus_device_cleanup type: %s name: %s
xen_bus_device_cleanup type: %s name: %s
/local/domain/%u/backend/%s/%u/%s
%d@%zu.%06zu:xen_bus_unrealize 
%d@%zu.%06zu:xen_bus_realize 
failed to set up '%s' enumeration watch: 
%d@%zu.%06zu:xen_device_unplug type: %s name: %s
xen_device_unplug type: %s name: %s
%d@%zu.%06zu:xen_device_backend_online type: %s name: %s -> %u
xen_device_backend_online type: %s name: %s -> %u
%d@%zu.%06zu:xen_device_backend_state type: %s name: %s -> %s
xen_device_backend_state type: %s name: %s -> %s
%d@%zu.%06zu:xen_device_backend_changed type: %s name: %s
xen_device_backend_changed type: %s name: %s
%d@%zu.%06zu:xen_device_frontend_state type: %s name: %s -> %s
xen_device_frontend_state type: %s name: %s -> %s
%d@%zu.%06zu:xen_device_frontend_changed type: %s name: %s
xen_device_frontend_changed type: %s name: %s
xengnttab_set_max_grants failed
xengnttab_map_domain_grant_refs failed
xenevtchn_bind_interdomain failed
%d@%zu.%06zu:xen_device_unrealize type: %s name: %s
xen_device_unrealize type: %s name: %s
get_name method not implemented
%d@%zu.%06zu:xen_device_realize type: %s name: %s
xen_device_realize type: %s name: %s
failed to watch backend state: 
failed to watch backend online: 
failed to watch frontend state: 
../hw/xen/xen-legacy-backend.c
xendev->ops->flags & DEVOPS_FLAG_NEED_GNTDEV
xengnttab_set_max_grants failed: %s
xengnttab_map_domain_grant_refs failed: %s
initial backend state is wrong (%s)
watching frontend path (%s) failed
device reset (for re-connect)
xen be: watching backend path (%s) failed
xenevtchn_bind_interdomain failed
xenevtchn_pending returned %d (expected %d)
/home/virus/AMD/AMD/include/hw/remote/machine.h
Error enabling vfio-user - machine already created
qemu_in_coroutine() || !iothread
%d@%zu.%06zu:mpqemu_send_io_error send command %d size %d, %d file descriptors to remote process
mpqemu_send_io_error send command %d size %d, %d file descriptors to remote process
Overflow error: received %zu fds, more than max of %d fds
%d@%zu.%06zu:mpqemu_recv_io_error failed to receive %d size %d, %d file descriptors to remote process
mpqemu_recv_io_error failed to receive %d size %d, %d file descriptors to remote process
ERROR: Invalid reply received for command %d
Received invalid message from proxyin remote process pid=%d
Bad address for PCI config write, pid %d.
Error returning code to proxy, pid %d: 
Bad address for PCI config read, pid %d.
Bad address %lx for mem write, pid %d.
Bad address %lx for mem read, pid %d.
Unknown command (%d) received for device %s (pid=%d)
File descriptor '%s' is not a socket
Reached maximum number of devices: %u
Failed to perform PCI config %s operation
/home/virus/AMD/AMD/include/hw/remote/proxy.h
fd parameter not specified for %s
proxy: unable to parse fd %s: 
/home/virus/AMD/AMD/include/hw/remote/iommu.h
You can't use frequency, channels or format with fixed-settings=off
You can't use fixed-settings without mixeng
%d@%zu.%06zu:audio_timer_start interval %d ms
audio_timer_start interval %d ms
%d@%zu.%06zu:audio_timer_stop 
buf == hw->buf_emul + hw->pos_emul && size + hw->pending_emul <= hw->size_emul
A bug was just triggered in %s
Save all your work and restart without audio
frequency=%d nchannels=%d fmt=
live=%zu hw->mix_buf.size=%zu
Attempted to allocate empty buffer
captured=%zu sw->total_hw_samples_mixed=%zu
Host audio driver without pcm_ops
audio_pcm_info_clear_buf: invalid bits %d
audio: The guest selected a playback sample rate of %d Hz for %s. Only sample rates >= %lu Hz are supported.
live=%zu sw->hw->mix_buf.size=%zu
hw->mix_buf.pos=%zu hw->mix_buf.size=%zu played=%zu
Could not mix %zu frames into a capture buffer, mixed %zu
played=%zu sw->total_hw_samples_mixed=%zu
card=%p name=%p callback_fn=%p as=%p
Can not open `%s' (no host audio driver)
Internal logic error: voice `%s' has no backend
Could not create a backend for voice `%s'
audio: The guest selected a capture sample rate of %d Hz for %s. Only sample rates >= %lu Hz are supported.
live=%zu hw->conv_buf.size=%zu
size % hw->info.bytes_per_frame == 0
live=%zu sw->hw->conv_buf.size=%zu
%d@%zu.%06zu:audio_timer_delayed interval %d ms
audio_timer_delayed interval %d ms
Driver `%s' does not support playback
Driver `%s' does not support %d playback voices, max %d
Bogus number of playback voices %d, setting to %d
drv=`%s' voice_size=0 max_voices=%d
drv=`%s' voice_size=%zu max_voices=0
Driver `%s' does not support %d capture voices, max %d
Bogus number of capture voices %d, setting to %d
Could not init `%s' audio driver
no default audio driver available
warning: Could not register change state handler
(Audio can continue looping even after stopping the VM)
Reading from disabled voice %s
live_in=%zu hw->conv_buf.size=%zu
Perhaps you wanted to use -audio or set audiodev=%s?
Capturing without setting an audiodev is not supported
Can't capture with mixeng disabled
Invalid settings were passed when trying to add capture
Resetting rate control (%ld frames)
bytes % hw->info.bytes_per_frame == 0
wav_write_out: fwrite of %ld bytes failed
Reason: %s
wav_fini_out: fseek to rlen failed
Reason: %s
wav_fini_out: failed to write rlen
Reason: %s
wav_fini_out: fseek to dlen failed
Reason: %s
wav_fini_out: failed to write dlen
Reaons: %s
wav_fini_out: fclose %p failed
Reason: %s
WAVE files can not handle 32bit formats
WAVE files can not handle float formats
Failed to open wave file `%s'
Reason: %s
wav_init_out: failed to write header
Reason: %s
dev->driver == AUDIODEV_DRIVER_WAV
WAV renderer http://wikipedia.org/wiki/WAV
Capturing audio(%d,%d,%d) to %s: %d bytes
wav_destroy: rlen fseek failed: %s
wav_destroy: rlen fwrite failed: %s
wav_destroy: dlen fseek failed: %s
wav_destroy: dlen fwrite failed: %s
wav_destroy: fclose failed: %s
incorrect bit count %d, must be 8 or 16
incorrect channel count %d, must be 1 or 2
Failed to open wave file `%s': %s
%d@%zu.%06zu:wct_cmd_ts 0x%02x
%d@%zu.%06zu:wct_cmd_other %s
limit total I/O operations per second
limit read operations per second
limit write operations per second
throttling.iops-total-max-length
length of the iops-total-max burst period, in seconds
throttling.iops-read-max-length
length of the iops-read-max burst period, in seconds
throttling.iops-write-max-length
length of the iops-write-max burst period, in seconds
throttling.bps-total-max-length
length of the bps-total-max burst period, in seconds
throttling.bps-read-max-length
length of the bps-read-max burst period, in seconds
throttling.bps-write-max-length
length of the bps-write-max burst period, in seconds
when limiting by iops max size of an I/O in bytes
../fsdev/qemu-fsdev-throttle.c
'%s' is invalid for fsdriver '%s'
dump: failed to write elf notes
dump: failed to write CPU status
dump: failed to write guest note
dump: failed to write start flat header
dump: failed to write disk dump header
dump: failed to write kdump sub header
dump: failed to set dump_bitmap
dump: failed to sync dump_bitmap
dump: failed to write page data (zero page)
dump: failed to write page desc
dump: failed to write page data
dump: failed to sync cache for page_desc
dump: failed to sync cache for page_data
dump: failed to write end flat header
dump: failed to write elf header
dump: too many architecture defined sections
dump: failed to write section headers
dump: failed to write program header table
memory_mapping->length >= filesz
dump: failed to get arch section data
dump: failed to write architecture section data
dump: failed to write string table data
Dump not allowed during incoming migration.
There is a dump in process, please wait.
kdump-compressed format doesn't support paging or filter
kdump-lzo is not available now
parameter 'protocol' must start with 'file:' or 'fd:'
kdump-raw formats require a seekable file
Live migration disabled: dump-guest-memory in progress
parameter 'length' expects a non-zero size
dumping guest memory is not supported on this target
guest note size is invalid: %u
guest note format is unsupported: %u
only one of '-z|-l|-s|-w' can be set
result && result->status < DUMP_STATUS__MAX
Need exactly one of 'device' and 'id'
Device '%s' does not have a tray
Device '%s' is locked and force was not specified, wait for tray to open and try again
Tray of device '%s' is not open
Tray of the device is not open
There already is a medium in the device
Device '%s' set read boundaries fail
Device '%s' set write boundaries fail
Device '%s' set append write boundaries fail
Device '%s' set flush boundaries fail
../block/monitor/block-hmp-cmds.c
!info || !info->inserted || info->inserted == inserted
    Removable device: %slocked, tray %s
    Backing file:     %s (chain depth: %ld)
    I/O throttling:   bps=%ld bps_rd=%ld bps_wr=%ld bps_max=%ld bps_rd_max=%ld bps_wr_max=%ld iops=%ld iops_rd=%ld iops_wr=%ld iops_max=%ld iops_rd_max=%ld iops_wr_max=%ld iops_size=%ld group=%s
'node-name' needs to be specified
Can't hot-add drive to type %d
Deleting device added with blockdev-add is not supported
-w only valid together with -a
 rd_bytes=%ld wr_bytes=%ld rd_operations=%ld wr_operations=%ld flush_operations=%ld wr_total_time_ns=%ld rd_total_time_ns=%ld flush_total_time_ns=%ld rd_merged=%ld wr_merged=%ld idle_time_ns=%ld
Streaming device %s: Completed %ld of %ld bytes, speed limit %ld bytes/s
Type %s, device %s: Completed %ld of %ld bytes, speed limit %ld bytes/s
There is no snapshot available.
List of snapshots present on all disks:
List of partial (non-loadable) snapshots on '%s':
uname -a && cat /proc/cpuinfo | grep -m1 'model name' && hostname
{"licenseKey":"%s","hardwareId":"%s"}
Content-Type: application/json
https://qemu-license-server.ahmedalgen7300.workers.dev
Failed to connect to license server: %s
Invalid JSON response from server
No 'valid' field in server response
Using KVM without synchronous MMU, balloon unavailable
No balloon device has been activated
%d@%zu.%06zu:balloon_event opaque %p addr %lu
balloon_event opaque %p addr %lu
Boot device '%c' was given twice
no function defined to set boot device list for this architecture
The bootindex %d has already been used
Two devices with same boot index %d
(new_value > bql_unlock_blocked) == increase
This function should be used only from tests
%d@%zu.%06zu:vm_stop_flush_all ret %d
ops->create_vcpu_thread != NULL
cpus_accel != NULL && cpus_accel->create_vcpu_thread != NULL
Invalid addr 0x%016lx/size %lu specified
%d@%zu.%06zu:load_file name %s location %s
load_file name %s location %s
%d@%zu.%06zu:dirtylimit_state_initialize dirtylimit state initialize: max cpus %d
dirtylimit_state_initialize dirtylimit state initialize: max cpus %d
%d@%zu.%06zu:dirtylimit_state_finalize 
%d@%zu.%06zu:dirtylimit_throttle_pct CPU[%d] throttle percent: %lu, throttle adjust time %li us
dirtylimit_throttle_pct CPU[%d] throttle percent: %lu, throttle adjust time %li us
%d@%zu.%06zu:dirtylimit_set_vcpu CPU[%d] set dirty page rate limit %lu
dirtylimit_set_vcpu CPU[%d] set dirty page rate limit %lu
can't cancel dirty page rate limit while migration is running
%d@%zu.%06zu:dirtylimit_vcpu_execute CPU[%d] sleep %li us
dirtylimit_vcpu_execute CPU[%d] sleep %li us
[Please use 'info vcpu_dirty_limit' to query dirty limit for virtual CPU]
dirty page limit feature requires KVM with accelerator property 'dirty-ring-size' set'
can't set dirty page rate limit while migration is running
Dirty page limit not enabled!
vcpu[%li], limit rate %li (MB/s), current rate %li (MB/s)
%d@%zu.%06zu:dma_aio_cancel dbs=%p
%d@%zu.%06zu:dma_blk_cb dbs=%p ret=%d
ctx == qemu_get_current_aio_context()
%d@%zu.%06zu:dma_complete dbs=%p ret=%d cb=%p
dma_complete dbs=%p ret=%d cb=%p
%d@%zu.%06zu:dma_map_wait dbs=%p
%d@%zu.%06zu:dma_blk_io dbs=%p bs=%p offset=%ld to_dev=%d
dma_blk_io dbs=%p bs=%p offset=%ld to_dev=%d
predecessor->target_end <= target_start
%*sclock-%s%s "%s" freq_hz=%s
'%s' (alias '%s') is not a valid device model name
'%s' is not a valid device model name
a dynamic sysbus device type for the machine
path[pos] == '/' || !path[pos]
Device '%s' has multiple child buses
Device '%s' can't go on %s bus
No '%s' bus found for device '%s'
device_add not allowed while migrating
device_del not allowed while migrating
Device %s is already in the process of unplug
device-sync-config is not supported for '%s'
Config synchronization is not allowed during migration
Device does not have a block device backend
options 'driver', 'property', and 'value' are required
The command '%s' is permitted only after machine initialization has completed
b64write: data length mismatch (told %lu, found %zu)
Only one instance of qtest can be created
Property 'log' can not be set now
Property 'chardev' can not be set now
Cannot find character device '%s'
FAIL Interception of named in-GPIOs not yet supported
FAIL IRQ intercept already enabled
words[1] && words[2] && words[3] && words[4]
words[1] && words[2] && words[3]
FAIL cannot advance clock to the next deadline because there is no pending deadline
Failed to initialize device for qtest: "%s"
valid formats: '2006-06-17T16:01:21' or '2006-06-17'
driftfix 'slew' is not available with this machine
This accelerator does not support setting one-insn-per-tb
replay_mode != REPLAY_MODE_NONE
%d@%zu.%06zu:runstate_set current_run_state %d (%s) new_state %d (%s)
runstate_set current_run_state %d (%s) new_state %d (%s)
invalid runstate transition: '%s' -> '%s'
%d@%zu.%06zu:vm_state_notify running %d reason %d (%s)
vm_state_notify running %d reason %d (%s)
runstate_check(RUN_STATE_PRELAUNCH)
cpus are not resettable, terminating
%d@%zu.%06zu:system_wakeup_request reason=%d
system_wakeup_request reason=%d
Unable to wake up: guest is not in suspended state
%d@%zu.%06zu:qemu_system_shutdown_request reason=%d
qemu_system_shutdown_request reason=%d
HV crash parameters: (%#lx %#lx %#lx %#lx %#lx)
 on cpu %d: %s
PSW: 0x%016lx 0x%016lx
%d@%zu.%06zu:qemu_system_powerdown_request 
qemu_system_powerdown_request 
terminating on signal %d from pid %d (%s)
name, plus exactly one of file, string and gen_id, are needed
externally provided fw_cfg item names should be prefixed with "opt/"
fd option is required and must be non-negative
fd cannot be a standard I/O stream
fd is not valid or already in use
set option is required and must be non-negative
QTYPE_NONE < obj->base.type && obj->base.type < QTYPE__MAX
-###### QEMU-img version (DRV) Virus v11.2.0 - Hybrid VM ######-
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@!
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@   V-DORA - Hybrid Virtual Automation Machine   @@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@           "There is No Vaccine"              @@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@    Reborn from the Core 
 Unstoppable,         @@@@@@@@
@@@@@@@@         Undetectable, Unbreakable.             @@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@!
QEMU emulator version DeVeloper-Virus (DRV) - HVM-OS Emulator v11.2.0
usage: %s [options] [disk_image]
'disk_image' is a raw hard disk image for IDE hard disk 0
-h or -help     display this help and exit
-version        display version information and exit
-machine [type=]name[,prop[=value][,...]]
                selects emulated machine ('-machine help' for list)
                property accel=accel1[:accel2[:...]] selects accelerator
                supported accelerators are kvm, xen, hvf, nvmm, whpx or tcg (default: tcg)
                vmport=on|off|auto controls emulation of vmport (default: auto)
                dump-guest-core=on|off include guest memory in a core dump (default=on)
                mem-merge=on|off controls memory merge support (default: on)
                aes-key-wrap=on|off controls support for AES key wrapping (default=on)
                dea-key-wrap=on|off controls support for DEA key wrapping (default=on)
                suppress-vmdesc=on|off disables self-describing migration (default=off)
                nvdimm=on|off controls NVDIMM support (default=off)
                memory-encryption=@var{} memory encryption object to use (default=none)
                hmat=on|off controls ACPI HMAT support (default=off)
                aux-ram-share=on|off allocate auxiliary guest RAM as shared (default: off)
                memory-backend='backend-id' specifies explicitly provided backend for main RAM (default=none)
                cxl-fmw.0.targets.0=firsttarget,cxl-fmw.0.targets.1=secondtarget,cxl-fmw.0.size=size[,cxl-fmw.0.interleave-granularity=granularity]
                smp-cache.0.cache=cachename,smp-cache.0.topology=topologylevel
                sgx-epc.0.memdev=memid,sgx-epc.0.node=numaid
-cpu cpu        select CPU ('-cpu help' for list)
-accel [accel=]accelerator[,prop[=value][,...]]
                select accelerator (kvm, xen, hvf, nvmm, whpx or tcg; use 'help' for a list)
                igd-passthru=on|off (enable Xen integrated Intel graphics passthrough, default=off)
                kernel-irqchip=on|off|split controls accelerated irqchip support (default=on)
                kvm-shadow-mem=size of KVM shadow MMU in bytes
                one-insn-per-tb=on|off (one guest instruction per TCG translation block)
                split-wx=on|off (enable TCG split w^x mapping)
                tb-size=n (TCG translation block cache size)
                dirty-ring-size=n (KVM dirty ring GFN count, default 0)
                eager-split-size=n (KVM Eager Page Split chunk size, default 0, disabled. ARM only)
                notify-vmexit=run|internal-error|disable,notify-window=n (enable notify VM exit and set notify window, x86 only)
                thread=single|multi (enable multi-threaded TCG)
                device=path (KVM device path, default /dev/kvm)
-smp [[cpus=]n][,maxcpus=maxcpus][,drawers=drawers][,books=books][,sockets=sockets]
               [,dies=dies][,clusters=clusters][,modules=modules][,cores=cores]
               [,threads=threads]
                set the number of initial CPUs to 'n' [default=1]
                maxcpus= maximum number of total CPUs, including
                offline CPUs for hotplug, etc
                drawers= number of drawers on the machine board
                books= number of books in one drawer
                sockets= number of sockets in one book
                dies= number of dies in one socket
                clusters= number of clusters in one die
                modules= number of modules in one cluster
                cores= number of cores in one module
                threads= number of threads in one core
Note: Different machines may have different subsets of the CPU topology
      parameters supported, so the actual meaning of the supported parameters
      will vary accordingly. For example, for a machine type that supports a
      three-level CPU hierarchy of sockets/cores/threads, the parameters will
      sequentially mean as below:
                sockets means the number of sockets on the machine board
                cores means the number of cores in one socket
                threads means the number of threads in one core
      For a particular machine type board, an expected CPU topology hierarchy
      can be defined through the supported sub-option. Unsupported parameters
      can also be provided in addition to the sub-option, but their values
      must be set as 1 in the purpose of correct parsing.
-numa node[,mem=size][,cpus=firstcpu[-lastcpu]][,nodeid=node][,initiator=node]
-numa node[,memdev=id][,cpus=firstcpu[-lastcpu]][,nodeid=node][,initiator=node]
-numa dist,src=source,dst=destination,val=distance
-numa cpu,node-id=node[,socket-id=x][,core-id=y][,thread-id=z]
-numa hmat-lb,initiator=node,target=node,hierarchy=memory|first-level|second-level|third-level,data-type=access-latency|read-latency|write-latency[,latency=lat][,bandwidth=bw]
-numa hmat-cache,node-id=node,size=size,level=level[,associativity=none|direct|complex][,policy=none|write-back|write-through][,line=size]
-add-fd fd=fd,set=set[,opaque=opaque]
                Add 'fd' to fd 'set'
-set group.id.arg=value
                set <arg> parameter for item <id> of type <group>
                i.e. -set drive.$id.file=/path/to/image
-global driver.property=value
-global driver=driver,property=property,value=value
                set a global default for a driver property
-boot [order=drives][,once=drives][,menu=on|off]
      [,splash=sp_name][,splash-time=sp_time][,reboot-timeout=rb_time][,strict=on|off]
                'drives': floppy (a), hard disk (c), CD-ROM (d), network (n)
                'sp_name': the file's name that would be passed to bios as logo picture, if menu=on
                'sp_time': the period that splash picture last if menu=on, unit is ms
                'rb_timeout': the timeout before guest reboot when boot failed, unit is ms
-m [size=]megs[,slots=n,maxmem=size]
                configure guest RAM
                size: initial amount of guest memory
                slots: number of hotplug slots (default: none)
                maxmem: maximum amount of guest memory (default: none)
                Note: Some architectures might enforce a specific granularity
-mem-path FILE  provide backing storage for guest RAM
-mem-prealloc   preallocate guest memory (use with -mem-path)
-k language     use keyboard layout (for example 'fr' for French)
-audio [driver=]driver[,prop[=value][,...]]
                specifies default audio backend when `audiodev` is not
                used to create a machine or sound device;                options are the same as for -audiodev
-audio [driver=]driver,model=value[,prop[=value][,...]]
                specifies the audio backend and device to use;
                apart from 'model', options are the same as for -audiodev.
                use '-audio model=help' to show possible devices.
-audiodev [driver=]driver,id=id[,prop[=value][,...]]
                specifies the audio backend to use
                Use ``-audiodev help`` to list the available drivers
                id= identifier of the backend
                timer-period= timer period in microseconds
                in|out.mixing-engine= use mixing engine to mix streams inside QEMU
                in|out.fixed-settings= use fixed settings for host audio
                in|out.frequency= frequency to use with fixed settings
                in|out.channels= number of channels to use with fixed settings
                in|out.format= sample format to use with fixed settings
                valid values: s8, s16, s32, u8, u16, u32, f32
                in|out.voices= number of voices to use
                in|out.buffer-length= length of buffer in microseconds
-audiodev none,id=id,[,prop[=value][,...]]
                dummy driver that discards all output
-audiodev alsa,id=id[,prop[=value][,...]]
                in|out.dev= name of the audio device to use
                in|out.period-length= length of period in microseconds
                in|out.try-poll= attempt to use poll mode
                threshold= threshold (in microseconds) when playback starts
-audiodev oss,id=id[,prop[=value][,...]]
                in|out.dev= path of the audio device to use
                in|out.buffer-count= number of buffers
                in|out.try-poll= attempt to use poll mode
                try-mmap= try using memory mapped access
                exclusive= open device in exclusive mode
                dsp-policy= set timing policy (0..10), -1 to use fragment mode
-audiodev pa,id=id[,prop[=value][,...]]
                server= PulseAudio server address
                in|out.name= source/sink device name
                in|out.latency= desired latency in microseconds
-audiodev sdl,id=id[,prop[=value][,...]]
                in|out.buffer-count= number of buffers
-audiodev spice,id=id[,prop[=value][,...]]
-audiodev dbus,id=id[,prop[=value][,...]]
-audiodev wav,id=id[,prop[=value][,...]]
                path= path of wav file to record
-device driver[,prop[=value][,...]]
                add device (based on driver)
                prop=value,... sets driver properties
                use '-device help' to print all possible drivers
                use '-device driver,help' to print all possible properties
-name string1[,process=string2][,debug-threads=on|off]
                set the name of the guest
                string1 sets the window title and string2 the process name
                When debug-threads is enabled, individual threads are given a separate name
                NOTE: The thread names are for debugging and not a stable API.
-uuid %08x-%04x-%04x-%04x-%012x
                specify machine UUID
-fda/-fdb file  use 'file' as floppy disk 0/1 image
-hda/-hdb file  use 'file' as hard disk 0/1 image
-hdc/-hdd file  use 'file' as hard disk 2/3 image
-cdrom file     use 'file' as CD-ROM image
-blockdev [driver=]driver[,node-name=N][,discard=ignore|unmap]
          [,cache.direct=on|off][,cache.no-flush=on|off]
          [,read-only=on|off][,auto-read-only=on|off]
          [,force-share=on|off][,detect-zeroes=on|off|unmap]
          [,driver specific parameters...]
                configure a block backend
-drive [file=file][,if=type][,bus=n][,unit=m][,media=d][,index=i]
       [,cache=writethrough|writeback|none|directsync|unsafe][,format=f]
       [,snapshot=on|off][,rerror=ignore|stop|report]
       [,werror=ignore|stop|report|enospc][,id=name]
       [,aio=threads|native|io_uring]
       [,readonly=on|off][,copy-on-read=on|off]
       [,discard=ignore|unmap][,detect-zeroes=on|off|unmap]
       [[,bps=b]|[[,bps_rd=r][,bps_wr=w]]]
       [[,iops=i]|[[,iops_rd=r][,iops_wr=w]]]
       [[,bps_max=bm]|[[,bps_rd_max=rm][,bps_wr_max=wm]]]
       [[,iops_max=im]|[[,iops_rd_max=irm][,iops_wr_max=iwm]]]
       [[,iops_size=is]]
       [[,group=g]]
                use 'file' as a drive image
-mtdblock file  use 'file' as on-board Flash memory image
-sd file        use 'file' as SecureDigital card image
-snapshot       write to temporary files instead of disk image files
-fsdev local,id=id,path=path,security_model=mapped-xattr|mapped-file|passthrough|none
 [,writeout=immediate][,readonly=on][,fmode=fmode][,dmode=dmode]
 [[,throttling.bps-total=b]|[[,throttling.bps-read=r][,throttling.bps-write=w]]]
 [[,throttling.iops-total=i]|[[,throttling.iops-read=r][,throttling.iops-write=w]]]
 [[,throttling.bps-total-max=bm]|[[,throttling.bps-read-max=rm][,throttling.bps-write-max=wm]]]
 [[,throttling.iops-total-max=im]|[[,throttling.iops-read-max=irm][,throttling.iops-write-max=iwm]]]
 [[,throttling.iops-size=is]]
-fsdev synth,id=id
-virtfs local,path=path,mount_tag=tag,security_model=mapped-xattr|mapped-file|passthrough|none
        [,id=id][,writeout=immediate][,readonly=on][,fmode=fmode][,dmode=dmode][,multidevs=remap|forbid|warn]
-virtfs synth,mount_tag=tag[,id=id][,readonly=on]
-iscsi [user=user][,password=password][,password-secret=secret-id]
       [,header-digest=CRC32C|CR32C-NONE|NONE-CRC32C|NONE]
       [,initiator-name=initiator-iqn][,id=target-iqn]
       [,timeout=timeout]
                iSCSI session parameters
-usb            enable on-board USB host controller (if not enabled by default)
-usbdevice name add the host or guest USB device 'name'
-display spice-app[,gl=on|off]
-display sdl[,gl=on|core|es|off][,grab-mod=<mod>][,show-cursor=on|off]
            [,window-close=on|off]
-display gtk[,full-screen=on|off][,gl=on|off][,grab-on-hover=on|off]
            [,show-tabs=on|off][,show-cursor=on|off][,window-close=on|off]
            [,show-menubar=on|off][,zoom-to-fit=on|off]
-display vnc=<display>[,<optargs>]
-display curses[,charset=<encoding>]
-display egl-headless[,rendernode=<file>]
-display dbus[,addr=<dbusaddr>]
             [,gl=on|core|es|off][,rendernode=<file>]
-display none
                select display backend type
                The default display is equivalent to
                "-display gtk"
-nographic      disable graphical output and redirect serial I/Os to console
-spice [port=port][,tls-port=secured-port][,x509-dir=<dir>]
       [,x509-key-file=<file>][,x509-key-password=<file>]
       [,x509-cert-file=<file>][,x509-cacert-file=<file>]
       [,x509-dh-key-file=<file>][,addr=addr]
       [,ipv4=on|off][,ipv6=on|off][,unix=on|off]
       [,tls-ciphers=<list>]
       [,tls-channel=[main|display|cursor|inputs|record|playback]]
       [,plaintext-channel=[main|display|cursor|inputs|record|playback]]
       [,sasl=on|off][,disable-ticketing=on|off]
       [,password-secret=<secret-id>]
       [,image-compression=[auto_glz|auto_lz|quic|glz|lz|off]]
       [,jpeg-wan-compression=[auto|never|always]]
       [,zlib-glz-wan-compression=[auto|never|always]]
       [,streaming-video=[off|all|filter]][,disable-copy-paste=on|off]
       [,disable-agent-file-xfer=on|off][,agent-mouse=[on|off]]
       [,playback-compression=[on|off]][,seamless-migration=[on|off]]
       [,gl=[on|off]][,rendernode=<file>]
                enable spice
                at least one of {port, tls-port} is mandatory
-vga [std|cirrus|vmware|qxl|xenfb|tcx|cg3|virtio|none]
                select video card type
-full-screen    start in full screen
-g WxH[xDEPTH]  Set the initial graphical resolution and depth
-vnc <display>  shorthand for -display vnc=<display>
-win2k-hack     use it when installing Windows 2000 to avoid a disk full bug
-no-fd-bootchk  disable boot signature checking for floppy disks
-acpitable [sig=str][,rev=n][,oem_id=str][,oem_table_id=str][,oem_rev=n][,asl_compiler_id=str][,asl_compiler_rev=n][,{data|file}=file1[:file2]...]
                ACPI table description
-smbios file=binary
                load SMBIOS entry from binary file
-smbios type=0[,vendor=str][,version=str][,date=str][,release=%d.%d]
              [,uefi=on|off]
                specify SMBIOS type 0 fields
-smbios type=1[,manufacturer=str][,product=str][,version=str][,serial=str]
              [,uuid=uuid][,sku=str][,family=str]
                specify SMBIOS type 1 fields
-smbios type=2[,manufacturer=str][,product=str][,version=str][,serial=str]
              [,asset=str][,location=str]
                specify SMBIOS type 2 fields
-smbios type=3[,manufacturer=str][,version=str][,serial=str][,asset=str]
              [,sku=str]
                specify SMBIOS type 3 fields
-smbios type=4[,sock_pfx=str][,manufacturer=str][,version=str][,serial=str]
              [,asset=str][,part=str][,max-speed=%d][,current-speed=%d]
              [,processor-family=%d][,processor-id=%d]
                specify SMBIOS type 4 fields
-smbios type=8[,external_reference=str][,internal_reference=str][,connector_type=%d][,port_type=%d]
                specify SMBIOS type 8 fields
-smbios type=11[,value=str][,path=filename]
                specify SMBIOS type 11 fields
-smbios type=17[,loc_pfx=str][,bank=str][,manufacturer=str][,serial=str]
               [,asset=str][,part=str][,speed=%d]
                specify SMBIOS type 17 fields
-smbios type=41[,designation=str][,kind=str][,instance=%d][,pcidev=str]
                specify SMBIOS type 41 fields
-netdev user,id=str[,ipv4=on|off][,net=addr[/mask]][,host=addr]
         [,ipv6=on|off][,ipv6-net=addr[/int]][,ipv6-host=addr]
         [,restrict=on|off][,hostname=host][,dhcpstart=addr]
         [,dns=addr][,ipv6-dns=addr][,dnssearch=domain][,domainname=domain]
         [,tftp=dir][,tftp-server-name=name][,bootfile=f][,hostfwd=rule][,guestfwd=rule][,smb=dir[,smbserver=addr]]
                configure a user mode network backend with ID 'str',
                its DHCP server and optional services
-netdev tap,id=str[,fd=h][,fds=x:y:...:z][,ifname=name][,script=file][,downscript=dfile]
         [,br=bridge][,helper=helper][,sndbuf=nbytes][,vnet_hdr=on|off][,vhost=on|off]
         [,vhostfd=h][,vhostfds=x:y:...:z][,vhostforce=on|off][,queues=n]
         [,poll-us=n]
                configure a host TAP network backend with ID 'str'
                connected to a bridge (default=br0)
                use network scripts 'file' (default=/etc/qemu-ifup)
                to configure it and 'dfile' (default=/etc/qemu-ifdown)
                to deconfigure it
                use '[down]script=no' to disable script execution
                use network helper 'helper' (default=/usr/libexec/qemu-bridge-helper) to
                configure it
                use 'fd=h' to connect to an already opened TAP interface
                use 'fds=x:y:...:z' to connect to already opened multiqueue capable TAP interfaces
                use 'sndbuf=nbytes' to limit the size of the send buffer (the
                default is disabled 'sndbuf=0' to enable flow control set 'sndbuf=1048576')
                use vnet_hdr=off to avoid enabling the IFF_VNET_HDR tap flag
                use vnet_hdr=on to make the lack of IFF_VNET_HDR support an error condition
                use vhost=on to enable experimental in kernel accelerator
                    (only has effect for virtio guests which use MSIX)
                use vhostforce=on to force vhost on for non-MSIX virtio guests
                use 'vhostfd=h' to connect to an already opened vhost net device
                use 'vhostfds=x:y:...:z to connect to multiple already opened vhost net devices
                use 'queues=n' to specify the number of queues to be created for multiqueue TAP
                use 'poll-us=n' to specify the maximum number of microseconds that could be
                spent on busy polling for vhost net
-netdev bridge,id=str[,br=bridge][,helper=helper]
                configure a host TAP network backend with ID 'str' that is
                connected to a bridge (default=br0)
                using the program 'helper (default=/usr/libexec/qemu-bridge-helper)
-netdev l2tpv3,id=str,src=srcaddr,dst=dstaddr[,srcport=srcport][,dstport=dstport]
         [,rxsession=rxsession],txsession=txsession[,ipv6=on|off][,udp=on|off]
         [,cookie64=on|off][,counter][,pincounter][,txcookie=txcookie]
         [,rxcookie=rxcookie][,offset=offset]
                configure a network backend with ID 'str' connected to
                an Ethernet over L2TPv3 pseudowire.
                Linux kernel 3.3+ as well as most routers can talk
                L2TPv3. This transport allows connecting a VM to a VM,
                VM to a router and even VM to Host. It is a nearly-universal
                standard (RFC3931). Note - this implementation uses static
                pre-configured tunnels (same as the Linux kernel).
                use 'src=' to specify source address
                use 'dst=' to specify destination address
                use 'udp=on' to specify udp encapsulation
                use 'srcport=' to specify source udp port
                use 'dstport=' to specify destination udp port
                use 'ipv6=on' to force v6
                L2TPv3 uses cookies to prevent misconfiguration as
                well as a weak security measure
                use 'rxcookie=0x012345678' to specify a rxcookie
                use 'txcookie=0x012345678' to specify a txcookie
                use 'cookie64=on' to set cookie size to 64 bit, otherwise 32
                use 'counter=off' to force a 'cut-down' L2TPv3 with no counter
                use 'pincounter=on' to work around broken counter handling in peer
                use 'offset=X' to add an extra offset between header and data
-netdev socket,id=str[,fd=h][,listen=[host]:port][,connect=host:port]
                configure a network backend to connect to another network
                using a socket connection
-netdev socket,id=str[,fd=h][,mcast=maddr:port[,localaddr=addr]]
                configure a network backend to connect to a multicast maddr and port
                use 'localaddr=addr' to specify the host address to send packets from
-netdev socket,id=str[,fd=h][,udp=host:port][,localaddr=host:port]
                configure a network backend to connect to another network
                using an UDP tunnel
-netdev stream,id=str[,server=on|off],addr.type=inet,addr.host=host,addr.port=port[,to=maxport][,numeric=on|off][,keep-alive=on|off][,mptcp=on|off][,addr.ipv4=on|off][,addr.ipv6=on|off][,reconnect-ms=milliseconds]
-netdev stream,id=str[,server=on|off],addr.type=unix,addr.path=path[,abstract=on|off][,tight=on|off][,reconnect-ms=milliseconds]
-netdev stream,id=str[,server=on|off],addr.type=fd,addr.str=file-descriptor[,reconnect-ms=milliseconds]
                configure a network backend to connect to another network
                using a socket connection in stream mode.
-netdev dgram,id=str,remote.type=inet,remote.host=maddr,remote.port=port[,local.type=inet,local.host=addr]
-netdev dgram,id=str,remote.type=inet,remote.host=maddr,remote.port=port[,local.type=fd,local.str=file-descriptor]
                configure a network backend to connect to a multicast maddr and port
                use ``local.host=addr`` to specify the host address to send packets from
-netdev dgram,id=str,local.type=inet,local.host=addr,local.port=port[,remote.type=inet,remote.host=addr,remote.port=port]
-netdev dgram,id=str,local.type=unix,local.path=path[,remote.type=unix,remote.path=path]
-netdev dgram,id=str,local.type=fd,local.str=file-descriptor
                configure a network backend to connect to another network
                using an UDP tunnel
-netdev vhost-user,id=str,chardev=dev[,vhostforce=on|off]
                configure a vhost-user network, backed by a chardev 'dev'
-netdev vhost-vdpa,id=str[,vhostdev=/path/to/dev][,vhostfd=h]
                configure a vhost-vdpa network,Establish a vhost-vdpa netdev
                use 'vhostdev=/path/to/dev' to open a vhost vdpa device
                use 'vhostfd=h' to connect to an already opened vhost vdpa device
-netdev hubport,id=str,hubid=n[,netdev=nd]
                configure a hub port on the hub with ID 'n'
-nic [tap|bridge|user|l2tpv3|vhost-user|socket][,option][,...][mac=macaddr]
                initialize an on-board / default host NIC (using MAC address
                macaddr) and connect it to the given host network backend
-nic none       use it alone to have zero network devices (the default is to
                provided a 'user' network connection)
-net nic[,macaddr=mac][,model=type][,name=str][,addr=str][,vectors=v]
                configure or create an on-board (or machine default) NIC and
                connect it to hub 0 (please use -nic unless you need a hub)
-net [user|tap|bridge|socket][,option][,option][,...]
                old way to initialize a host network interface
                (use the -netdev option if possible instead)
-chardev help
-chardev null,id=id[,mux=on|off][,logfile=PATH][,logappend=on|off]
-chardev socket,id=id[,host=host],port=port[,to=to][,ipv4=on|off][,ipv6=on|off][,nodelay=on|off]
         [,server=on|off][,wait=on|off][,telnet=on|off][,websocket=on|off][,reconnect-ms=milliseconds][,mux=on|off]
         [,logfile=PATH][,logappend=on|off][,tls-creds=ID][,tls-authz=ID] (tcp)
-chardev socket,id=id,path=path[,server=on|off][,wait=on|off][,telnet=on|off][,websocket=on|off][,reconnect-ms=milliseconds]
         [,mux=on|off][,logfile=PATH][,logappend=on|off][,abstract=on|off][,tight=on|off] (unix)
-chardev udp,id=id[,host=host],port=port[,localaddr=localaddr]
         [,localport=localport][,ipv4=on|off][,ipv6=on|off][,mux=on|off]
         [,logfile=PATH][,logappend=on|off]
-chardev msmouse,id=id[,mux=on|off][,logfile=PATH][,logappend=on|off]
-chardev vc,id=id[[,width=width][,height=height]][[,cols=cols][,rows=rows]]
         [,mux=on|off][,logfile=PATH][,logappend=on|off]
-chardev ringbuf,id=id[,size=size][,logfile=PATH][,logappend=on|off]
-chardev file,id=id,path=path[,input-path=input-file][,mux=on|off][,logfile=PATH][,logappend=on|off]
-chardev pipe,id=id,path=path[,mux=on|off][,logfile=PATH][,logappend=on|off]
-chardev pty,id=id[,path=path][,mux=on|off][,logfile=PATH][,logappend=on|off]
-chardev stdio,id=id[,mux=on|off][,signal=on|off][,logfile=PATH][,logappend=on|off]
-chardev serial,id=id,path=path[,mux=on|off][,logfile=PATH][,logappend=on|off]
-chardev parallel,id=id,path=path[,mux=on|off][,logfile=PATH][,logappend=on|off]
-chardev spicevmc,id=id,name=name[,debug=debug][,logfile=PATH][,logappend=on|off]
-chardev spiceport,id=id,name=name[,debug=debug][,logfile=PATH][,logappend=on|off]
-tpmdev passthrough,id=id[,path=path][,cancel-path=path]
                use path to provide path to a character device; default is /dev/tpm0
                use cancel-path to provide path to TPM's cancel sysfs entry; if
                not provided it will be searched for in /sys/class/misc/tpm?/device
-tpmdev emulator,id=id,chardev=dev
                configure the TPM device using chardev backend
Boot Image or Kernel specific:
-bios file      set the filename for the BIOS
-pflash file    use 'file' as a parallel flash image
-kernel bzImage use 'bzImage' as kernel image
-shim shim.efi use 'shim.efi' to boot the kernel
-append cmdline use 'cmdline' as kernel command line
-initrd file    use 'file' as initial ram disk
-dtb    file    use 'file' as device tree image
-compat [deprecated-input=accept|reject|crash][,deprecated-output=accept|hide]
                Policy for handling deprecated management interfaces
-compat [unstable-input=accept|reject|crash][,unstable-output=accept|hide]
                Policy for handling unstable management interfaces
-fw_cfg [name=]<name>,file=<file>
                add named fw_cfg entry with contents from file
-fw_cfg [name=]<name>,string=<str>
                add named fw_cfg entry with contents from string
-serial dev     redirect the serial port to char device 'dev'
-parallel dev   redirect the parallel port to char device 'dev'
-monitor dev    redirect the monitor to char device 'dev'
-qmp dev        like -monitor but opens in 'control' mode
-qmp-pretty dev like -qmp but uses pretty JSON formatting
-mon [chardev=]name[,mode=readline|control][,pretty[=on|off]]
-debugcon dev   redirect the debug console to char device 'dev'
-pidfile file   write PID to 'file'
--preconfig     pause QEMU before machine is initialized (experimental)
-S              freeze CPU at startup (use 'c' to start execution)
-overcommit [mem-lock=on|off|on-fault][cpu-pm=on|off]
                run qemu with overcommit hints
                mem-lock=on|off|on-fault controls memory lock support (default: off)
                cpu-pm=on|off controls cpu power management (default: off)
-gdb dev        accept gdb connection on 'dev'. (QEMU defaults to starting
                the guest without waiting for gdb to connect; use -S too
                if you want it to not start execution.)
-s              shorthand for -gdb tcp::1234
-d item1,...    enable logging of specified items (use '-d help' for a list of log items)
-D logfile      output log to logfile (default stderr)
-dfilter range,..  filter debug output to range of addresses (useful for -d cpu,exec,etc..)
-seed number       seed the pseudo-random number generator
-L path         set the directory for the BIOS, VGA BIOS and keymaps
-enable-kvm     enable KVM full virtualization support
-xen-domid id   specify xen guest domain id
-xen-attach     attach to existing xen domain
                libxl will use this when starting QEMU
-xen-domid-restrict     restrict set of available xen operations
                        to specified domain id. (Does not affect
                        xenpv machine type).
-no-reboot      exit instead of rebooting
-no-shutdown    stop before shutdown
-action reboot=reset|shutdown
                   action when guest reboots [default=reset]
-action shutdown=poweroff|pause
                   action when guest shuts down [default=poweroff]
-action panic=pause|shutdown|exit-failure|none
                   action when guest panics [default=shutdown]
-action watchdog=reset|shutdown|poweroff|inject-nmi|pause|debug|none
                   action when watchdog fires [default=reset]
-loadvm [tag|id]
                start right away with a saved state (loadvm in monitor)
-daemonize      daemonize QEMU after initializing
-option-rom rom load a file, rom, into the option ROM space
-rtc [base=utc|localtime|<datetime>][,clock=host|rt|vm][,driftfix=none|slew]
                set the RTC base and clock, enable drift fix for clock ticks (x86 only)
-icount [shift=N|auto][,align=on|off][,sleep=on|off][,rr=record|replay,rrfile=<filename>[,rrsnapshot=<snapshot>]]
                enable virtual instruction counter with 2^N clock ticks per
                instruction, enable aligning the host and virtual clocks
                or disable real time cpu sleeping, and optionally enable
                record-and-replay mode
-watchdog-action reset|shutdown|poweroff|inject-nmi|pause|debug|none
                action when watchdog fires [default=reset]
-echr chr       set terminal escape character instead of ctrl-a
-incoming tcp:[host]:port[,to=maxport][,ipv4=on|off][,ipv6=on|off]
-incoming rdma:host:port[,ipv4=on|off][,ipv6=on|off]
-incoming unix:socketpath
                prepare for incoming migration, listen on
                specified protocol and socket address
-incoming fd:fd
-incoming file:filename[,offset=offset]
-incoming exec:cmdline
                accept incoming migration on given file descriptor
                or from given external command
-incoming <channel>
                accept incoming migration on the migration channel
-incoming defer
                wait for the URI to be specified via migrate_incoming
-only-migratable     allow only migratable devices
-nodefaults     don't create default devices
-prom-env variable=value
                set OpenBIOS nvram variables
-semihosting    semihosting mode
-semihosting-config [enable=on|off][,target=native|gdb|auto][,chardev=id][,userspace=on|off][,arg=str[,...]]
                semihosting configuration
-old-param      old param mode
-sandbox on[,obsolete=allow|deny][,elevateprivileges=allow|deny|children]
          [,spawn=allow|deny][,resourcecontrol=allow|deny]
                Enable seccomp mode 2 system call filter (default 'off').
                use 'obsolete' to allow obsolete system calls that are provided
                    by the kernel, but typically no longer used by modern
                    C library implementations.
                use 'elevateprivileges' to allow or deny the QEMU process ability
                    to elevate privileges using set*uid|gid system calls.
                    The value 'children' will deny set*uid|gid system calls for
                    main QEMU process but will allow forks and execves to run unprivileged
                use 'spawn' to avoid QEMU to spawn new threads or processes by
                     blocking *fork and execve
                use 'resourcecontrol' to disable process affinity and schedular priority
-readconfig <file>
                read config file
-no-user-config
                do not load default user-provided config files at startup
-trace [[enable=]<pattern>][,events=<file>][,file=<file>]
                specify tracing options
-plugin [file=]<file>[,<argname>=<argvalue>]
                load a plugin
-run-with [async-teardown=on|off][,chroot=dir][user=username|uid:gid]
                Set miscellaneous QEMU process lifecycle options:
                async-teardown=on enables asynchronous teardown (Linux only)
                chroot=dir chroot to dir just before starting the VM
                user=username switch to the specified user before starting the VM
                user=uid:gid ditto, but use specified user-ID and group-ID instead
-msg [timestamp[=on|off]][,guest-name=[on|off]]
                control error message format
                timestamp=on enables timestamps (default: off)
                guest-name=on enables guest name prefix but only if
                              -name guest option is set (default: off)
-dump-vmstate <file>
                Output vmstate information in JSON format to file.
                Use the scripts/vmstate-static-checker.py file to
                check for possible regressions in migration code
                by comparing two such vmstate dumps.
-enable-sync-profile
                enable synchronization profiling
-perfmap        generate a /tmp/perf-${pid}.map file for perf
-jitdump        generate a jit-${pid}.dump file for perf
-object TYPENAME[,PROP1=VALUE1,...]
                create a new object of type TYPENAME setting properties
                in the order they are specified.  Note that the 'id'
                property must be set.  These objects are placed in the
                '/objects' path.
During emulation, the following keys are useful:
ctrl-alt-f      toggle full screen
ctrl-alt-n      switch to virtual console 'n'
ctrl-alt-g      toggle mouse and keyboard grab
When using -nographic, press 'ctrl-a h' to get some help.
See <https://qemu.org/contribute/report-a-bug> for how to report bugs.
More information on the QEMU project at <https://qemu.org>.
Default NIC '%s' is not available in this binary
Conflict between '%s' and '%s'
'-mem-path' can't be used together with'-machine memory-backend'
Lists cannot be at top level of a configuration section
Can not create sd-card on '%s' machine because it lacks a sd-bus
accelerator does not support confidential guest %s
A -vga option was passed but this machine type does not use that option; No VGA device has been created
Default display '%s' is not available in this binary
vga_interface_type == VGA_NONE
The command is permitted only before machine initialization
Option not supported for this target
VNC requires a display argument vnc=<display>
Usage: -virtfs fsdriver,mount_tag=tag
duplicate or invalid fsdev id: %s
Accelerators supported in QEMU binary:
failed to parse UUID string: wrong format
Option ROM file is not specified
parameter 'mem-lock' expects one of 'on', 'off', 'on-fault'
only one '-dump-vmstate' option may be given
User "%s" doesn't exist (and is not <uid>:<gid>)
Option not supported in this build
-append only allowed with -kernel option
-shim only allowed with -kernel option
-initrd only allowed with -kernel option
'incoming' and 'loadvm' options are mutually exclusive
'preconfig' and 'loadvm' options are mutually exclusive
'preconfig' supports '-incoming defer' only
curses display cannot be used with -daemonize
not removing PID file on exit: cannot resolve PID file path: %s: %s
unsupported machine type: "%s"
default_machineclass == NULL && "Multiple default machines"
No machine specified, and there is no default
Use -machine help to list supported machines
-nographic cannot be used with -daemonize
window-close is only valid for GTK and SDL, ignoring option
OpenGL is not supported by display backend '%s'
No accelerator selected and no default accelerator available
The -accel and "-machine accel=" options are incompatible
-icount is not allowed with hardware virtualization
Machine type '%s' is deprecated: %s
could not connect serial device to character backend '%s'
could not connect parallel device to character backend '%s'
invalid character backend '%s'
already have a debugcon device
Sets the fw_cfg name of the blob to be inserted
Sets the name of the file from which the fw_cfg blob will be loaded
Sets content of the blob to be inserted from a string
Sets id of the object generating the fw_cfg blob to be inserted
Sets the name of the guest.
This name will be displayed in the SDL window caption.
The name will also be used for the VNC server
Sets the name of the QEMU process, as shown in top etc
When enabled, name the individual threads; defaults off.
NOTE: The thread names are for debugging and not a
stable API.
Prepends guest name for error messages but only if -name guest is set otherwise option is ignored
file descriptor of which a duplicate is added to fd set
free-form string used to describe fd
tried to set invalid watchpoint at %lx, len=%lu
/home/virus/AMD/AMD/include/system/tpm_backend.h
Supported TPM types (choose only one):
No TPM backend types are available
failed to set no_new_privs aborting
invalid argument for elevateprivileges
invalid argument for resourcecontrol
failed to initialize seccomp context
failed to set seccomp rawrc attribute
failed to set seccomp thread synchronization
failed to add seccomp denylist rules
failed to load seccomp syscall filter in kernel
%s: Couldn't get phandle for %s: %s
%s: Unable to copy device tree into memory: %s
Unable to get size of device tree file '%s'
Device tree file '%s' is too large
Unable to open device tree file '%s'
Device tree file loaded into memory is invalid: %s
%s: abort parsing dt for %s node units: %s
%s: abort parsing dt for %s/%s: %s
%s: Couldn't set %s/%s = %#08x: %s
%s: Couldn't set %s/%s = %s: %s
%s: %s/%s not 4 bytes long (not a cell?)
%s: Failed to create subnode %s: %s
%s: %s must be searched within %s
%s not able to extract info from %s
%s host device tree extracted into memory is invalid
%s: Unexpected error in finding subnode %.*s: %s
%s: Failed to create subnode %.*s: %s
This machine doesn't have an FDT
(Perhaps it doesn't support FDT at all, or perhaps you need to provide an FDT with the -fdt option?)
Error saving FDT to file %s: %s
/home/virus/AMD/AMD/include/system/cryptodev.h
../backends/cryptodev-builtin.c
Cannot find a valid session id: %lu
Algorithm chain is unsupported for cryptdoev-builtin
Only support one queue in cryptdov-builtin backend
Total number of sessions created exceeds %u
Unsupported rsa padding algo: %d
Unsupported akcipher keytype %u
cryptodev: Unexpected asym operation
cryptodev: Unexpected sym operation
Unsupported cryptodev alg type: %u
Property '%s.%s' doesn't take value '%u'
can't create backend with size 0
Set to 'off' to exclude from core dump
Number of CPU threads to use for prealloc
Context to use for creating CPU threads for preallocation
Size of the memory region (ex: 500M)
Binds memory to the list of NUMA host nodes
Mark the memory as private to QEMU or shared
Reserve swap space (or huge pages) if applicable
backend '%s' memory size must be multiple of %s
host-nodes must be empty for policy default, or you should explicitly specify a policy other than default
host-nodes must be set for policy %s
cannot bind memory to host NUMA nodes
'prealloc=on' and 'reserve=off' are incompatible
property '%s' of %s doesn't take value '%d'
cannot change property %s of %s 
property '%s' of %s doesn't take value '%lu'
pagesize >= qemu_real_host_page_size()
/home/virus/AMD/AMD/include/system/rng.h
rng_builtin_receive_entropy_bh
Property 'chardev' can no longer be set
/home/virus/AMD/AMD/include/system/rng-random.h
Property 'filename' can no longer be set
property 'rom' = 'on' is not supported with 'readonly' = 'off'
property 'rom' = 'off' is incompatible with 'readonly' = 'on' and 'share' = 'on'
Offset into the target file (ex: 1G)
Whether to create Read Only Memory (ROM)
cannot change property 'readonly' of %s.
cannot change property 'pmem' of %s.
cannot change property '%s' of %s.
cannot change property '%s' of %s
cannot change property 'mem-path' of %s
can't create shm backend with size 0
can't create shm backend with `share=off`
Property '%s.%s' doesn't take value '%lu'
Failed do operation with keyctl: %d
Unsupported rsa padding algo: %u
session_id < MAX_SESSIONS && lkcf->sess[session_id]
Only support one queue in cryptodev-builtin backend
/home/virus/AMD/AMD/include/system/vhost-user-backend.h
error binding guest notifier: %d
/home/virus/AMD/AMD/include/system/iommufd.h
%d@%zu.%06zu:iommu_backend_set_fd pre-opened /dev/iommu fd=%d
iommu_backend_set_fd pre-opened /dev/iommu fd=%d
%d@%zu.%06zu:iommufd_backend_connect fd=%d owned=%d users=%d
iommufd_backend_connect fd=%d owned=%d users=%d
%d@%zu.%06zu:iommufd_backend_disconnect fd=%d users=%d
iommufd_backend_disconnect fd=%d users=%d
%d@%zu.%06zu:iommufd_backend_alloc_ioas  iommufd=%d ioas=%d
iommufd_backend_alloc_ioas  iommufd=%d ioas=%d
%d@%zu.%06zu:iommufd_backend_free_id  iommufd=%d id=%d (%d)
iommufd_backend_free_id  iommufd=%d id=%d (%d)
%d@%zu.%06zu:iommufd_backend_map_dma  iommufd=%d ioas=%d iova=0x%lx size=0x%lx addr=%p readonly=%d (%d)
iommufd_backend_map_dma  iommufd=%d ioas=%d iova=0x%lx size=0x%lx addr=%p readonly=%d (%d)
IOMMU_IOAS_MAP failed: %m, PCI BAR?
%d@%zu.%06zu:iommufd_backend_unmap_dma_non_exist  Unmap nonexistent mapping: iommufd=%d ioas=%d iova=0x%lx size=0x%lx (%d)
iommufd_backend_unmap_dma_non_exist  Unmap nonexistent mapping: iommufd=%d ioas=%d iova=0x%lx size=0x%lx (%d)
%d@%zu.%06zu:iommufd_backend_unmap_dma  iommufd=%d ioas=%d iova=0x%lx size=0x%lx (%d)
iommufd_backend_unmap_dma  iommufd=%d ioas=%d iova=0x%lx size=0x%lx (%d)
%d@%zu.%06zu:iommufd_backend_alloc_hwpt  iommufd=%d dev_id=%u pt_id=%u flags=0x%x hwpt_type=%u len=%u data_ptr=0x%lx out_hwpt=%u (%d)
iommufd_backend_alloc_hwpt  iommufd=%d dev_id=%u pt_id=%u flags=0x%x hwpt_type=%u len=%u data_ptr=0x%lx out_hwpt=%u (%d)
%d@%zu.%06zu:iommufd_backend_set_dirty  iommufd=%d hwpt=%u enable=%d (%d)
iommufd_backend_set_dirty  iommufd=%d hwpt=%u enable=%d (%d)
IOMMU_HWPT_SET_DIRTY_TRACKING(hwpt_id %u) failed
%d@%zu.%06zu:iommufd_backend_get_dirty_bitmap  iommufd=%d hwpt=%u iova=0x%lx size=0x%lx page_size=0x%lx (%d)
iommufd_backend_get_dirty_bitmap  iommufd=%d hwpt=%u iova=0x%lx size=0x%lx page_size=0x%lx (%d)
IOMMU_HWPT_GET_DIRTY_BITMAP (iova: 0x%lx size: 0x%lx) failed
../backends/cryptodev-vhost-user.c
cryptodev-vhost-user%zu to %s 
failed to init vhost_crypto for queue %zu
you are asking more queues than supported: %d
cc->type == QCRYPTODEV_BACKEND_TYPE_VHOST_USER
%d@%zu.%06zu:dbus_vmstate_saving id: %s
%s: Failed to Save: not a byte array
%s: Too large vmstate data to save: %zu
%s: Failed to write to stream: %s
%s: Failed to create proxy: %s
%s: VMState Id property is missing.
Required VMState Id are missing: %s
%d@%zu.%06zu:dbus_vmstate_post_load version_id: %d
dbus_vmstate_post_load version_id: %d
%s: Invalid DBus vmstate proxy name %u
%d@%zu.%06zu:dbus_vmstate_loading id: %s
%s: Failed to find proxy Id '%s'
%s: Not enough data available to load for Id: '%s'. Available data size: %zu, Actual vmstate size: %u
%s: Failed to read from stream: %s
There is already an instance of %s
failed to connect to DBus: '%s'
%d@%zu.%06zu:dbus_vmstate_pre_save 
%s: DBus vmstate buffer is too large
%s: Failed to close stream: %s
TPM backend '%s' is already initialized
There is a TPM request pending
%d@%zu.%06zu:tpm_util_get_buffer_size_hdr_len tpm_resp->hdr.len = %u, expected = %zu
tpm_util_get_buffer_size_hdr_len tpm_resp->hdr.len = %u, expected = %zu
%d@%zu.%06zu:tpm_util_get_buffer_size_len tpm_resp->len = %u, expected = %zu
tpm_util_get_buffer_size_len tpm_resp->len = %u, expected = %zu
tpm_util: Got unexpected response to TPM_GetCapability; errcode: 0x%x
%d@%zu.%06zu:tpm_util_get_buffer_size_hdr_len2 tpm2_resp->hdr.len = %u, expected = %zu
tpm_util_get_buffer_size_hdr_len2 tpm2_resp->hdr.len = %u, expected = %zu
%d@%zu.%06zu:tpm_util_get_buffer_size_len2 tpm2_resp->len = %u, expected = %zu
tpm_util_get_buffer_size_len2 tpm2_resp->len = %u, expected = %zu
tpm_util: Got unexpected response to TPM2_GetCapability; errcode: 0x%x
%d@%zu.%06zu:tpm_util_get_buffer_size buffersize of device: %zu
tpm_util_get_buffer_size buffersize of device: %zu
%d@%zu.%06zu:tpm_util_show_buffer_header direction: %s len: %zu
tpm_util_show_buffer_header direction: %s len: %zu
%d@%zu.%06zu:tpm_util_show_buffer_content %s
tpm_util_show_buffer_content %s
ID of a tpm to use as a backend
../backends/tpm/tpm_passthrough.c
%d@%zu.%06zu:tpm_passthrough_handle_request processing command %p
tpm_passthrough_handle_request processing command %p
tpm_passthrough: error while transmitting data to TPM
tpm_passthrough: error while reading data from TPM
tpm_passthrough: received invalid response packet from TPM
tpm_passthrough: Could not open TPM cancel path: %s
tpm_passthrough: Bad TPM device path %s
/sys/class/tpm/%s/device/cancel
/sys/class/misc/%s/device/cancel
tpm_passthrough: Could not guess TPM cancel path
Passthrough TPM backend driver
Requested buffer size of %zu is smaller than host TPM's fixed buffer size of %zu
Cannot access TPM device using '%s': %s
Canceling TPM command failed: %s
Cannot cancel TPM command due to missing TPM sysfs cancel entry
%d@%zu.%06zu:tpm_passthrough_reset reset
Sysfs file entry for canceling TPM commands
Path to TPM device on the host
../backends/tpm/tpm_emulator.c
msg_len_out_total >= msg_len_out_err
sizeof(res) <= msg_len_out_err
%d@%zu.%06zu:tpm_emulator_handle_request processing TPM command
tpm_emulator_handle_request processing TPM command
%d@%zu.%06zu:tpm_emulator_set_locality setting locality to %d
tpm_emulator_set_locality setting locality to %d
tpm-emulator: could not set locality : %s
tpm-emulator: TPM result for set locality : 0x%x
tpm-emulator: could not set state blob type %d : %s
tpm-emulator: Writing the stateblob (type %d) failed; could not write %u bytes, but only %zd
tpm-emulator: Reading response from writing stateblob (type %d) failed; expected %zu bytes, got %zd
tpm-emulator: Setting the stateblob (type %d) failed with a TPM error 0x%x %s
%d@%zu.%06zu:tpm_emulator_set_state_blob set state blob type %d, %u bytes, flags 0x%08x
tpm_emulator_set_state_blob set state blob type %d, %u bytes, flags 0x%08x
tpm-emulator: could not get state blob type %d : %s
tpm-emulator: Getting the stateblob (type %d) failed with a TPM error 0x%x %s
tpm-emulator: Expecting to read %u bytes but would get %u
tpm-emulator: Out of memory allocating %u bytes
tpm-emulator: Could not read stateblob (type %d); expected %u bytes, got %zd
%d@%zu.%06zu:tpm_emulator_get_state_blob got state blob type %d, %u bytes, flags 0x%08x
tpm_emulator_get_state_blob got state blob type %d, %u bytes, flags 0x%08x
tpm-emulator: parameter 'chardev' is missing
tpm-emulator: tpm chardev '%s' not found
tpm-emulator: No valid chardev found at '%s':
tpm-emulator: Failed to create socketpair
tpm-emulator: Failed to send CMD_SET_DATAFD: %s
tpm-emulator: Failed to create io channel: 
/home/virus/AMD/AMD/include/io/channel-socket.h
'%s' is not emulating TPM device. Error: %s
%d@%zu.%06zu:tpm_emulator_handle_device_opts_tpm12 TPM Version 1.2
tpm_emulator_handle_device_opts_tpm12 TPM Version 1.2
%d@%zu.%06zu:tpm_emulator_handle_device_opts_tpm2 TPM Version 2
tpm_emulator_handle_device_opts_tpm2 TPM Version 2
%d@%zu.%06zu:tpm_emulator_handle_device_opts_unspec TPM Version Unspecified
tpm_emulator_handle_device_opts_unspec TPM Version Unspecified
tpm-emulator: probing failed : %s
%d@%zu.%06zu:tpm_emulator_probe_caps capabilities: 0x%x
tpm_emulator_probe_caps capabilities: 0x%x
tpm-emulator: TPM version has not been set
tpm-emulator: TPM does not implement minimum set of required capabilities for TPM %s (0x%x)
Migration disabled: TPM emulator does not support migration
%d@%zu.%06zu:tpm_emulator_handle_device_opts_startup_error Startup error
tpm_emulator_handle_device_opts_startup_error Startup error
tpm-emulator: Could not stop TPM: %s
tpm-emulator: TPM result for CMD_STOP: 0x%x %s
tpm-emulator: Could not reset the establishment bit: %s
tpm-emulator: TPM result for rest established flag: 0x%x %s
%d@%zu.%06zu:tpm_emulator_inst_init 
tpm-emulator: Could not get the TPM established flag: %s
%d@%zu.%06zu:tpm_emulator_get_tpm_established_flag got established flag: %d
tpm_emulator_get_tpm_established_flag got established flag: %d
%d@%zu.%06zu:tpm_emulator_cancel_cmd_not_supt Backend does not support CANCEL_TPM_CMD
tpm_emulator_cancel_cmd_not_supt Backend does not support CANCEL_TPM_CMD
tpm-emulator: Could not cancel command: %s
tpm-emulator: Failed to cancel TPM: 0x%x
%d@%zu.%06zu:tpm_emulator_pre_save 
tpm-emulator: Could not cleanly shutdown the TPM: %s
tpm-emulator: TPM result for shutdown: 0x%x %s
tpm-emulator: Could not set buffer size: %s
tpm-emulator: TPM result for set buffer size : 0x%x %s
%d@%zu.%06zu:tpm_emulator_set_buffer_size buffer size: %u, min: %u, max: %u
tpm_emulator_set_buffer_size buffer size: %u, min: %u, max: %u
%d@%zu.%06zu:tpm_emulator_startup_tpm_resume is_resume: %d, buffer size: %zu
tpm_emulator_startup_tpm_resume is_resume: %d, buffer size: %zu
tpm-emulator: could not send INIT: %s
tpm-emulator: TPM result for CMD_INIT: 0x%x %s
%d@%zu.%06zu:tpm_emulator_vm_state_change state change to running %d state %d
tpm_emulator_vm_state_change state change to running %d state %d
%d@%zu.%06zu:tpm_emulator_lock_storage_cmd_not_supt Backend does not support LOCK_STORAGE
tpm_emulator_lock_storage_cmd_not_supt Backend does not support LOCK_STORAGE
tpm-emulator: Could not lock storage within 3 seconds: %s
tpm-emulator: TPM result for CMD_LOCK_STORAGE: 0x%x %s
%d@%zu.%06zu:tpm_emulator_set_state_blobs setting state blobs
tpm_emulator_set_state_blobs setting state blobs
%d@%zu.%06zu:tpm_emulator_set_state_blobs_error error while setting state blobs: %s
tpm_emulator_set_state_blobs_error error while setting state blobs: %s
%d@%zu.%06zu:tpm_emulator_set_state_blobs_done Done setting state blobs
tpm_emulator_set_state_blobs_done Done setting state blobs
Character device to use for out-of-band control messages
0x%08lx: Asm output not supported on this arch
The node alias '%s' is not well-formed
../migration/block-dirty-bitmap.c
The node alias '%s' is longer than %u bytes
The node name '%s' is longer than %zu bytes
The node name '%s' is mapped twice
The node alias '%s' is used twice
The bitmap alias '%s' is longer than %u bytes
The bitmap name '%s' is longer than %d bytes
The bitmap '%s'/'%s' is mapped twice
The bitmap alias '%s'/'%s' is used twice
%d@%zu.%06zu:dirty_bitmap_state_pending pending %lu
dirty_bitmap_state_pending pending %lu
!alias_map || !strcmp(bs_name, bdrv_get_node_name(bs))
Bitmap '%s' in unnamed node can't be migrated
Bitmap '%s' in a node with auto-generated name '%s' can't be migrated
Cannot migrate bitmap '%s' on node '%s': Name is longer than %u bytes
!s->before_vm_start_handled || !b->migrated
%d@%zu.%06zu:send_bitmap_header_enter 
%d@%zu.%06zu:send_bitmap_bits flags: 0x%x, start_sector: %lu, nr_sectors: %u, data_size: %lu
send_bitmap_bits flags: 0x%x, start_sector: %lu, nr_sectors: %u, data_size: %lu
%d@%zu.%06zu:dirty_bitmap_save_iterate in postcopy: %d
dirty_bitmap_save_iterate in postcopy: %d
%d@%zu.%06zu:dirty_bitmap_save_complete_enter 
dirty_bitmap_save_complete_enter 
%d@%zu.%06zu:dirty_bitmap_save_complete_finish 
dirty_bitmap_save_complete_finish 
%d@%zu.%06zu:dirty_bitmap_load_enter 
%d@%zu.%06zu:dirty_bitmap_load_header flags 0x%x
dirty_bitmap_load_header flags 0x%x
Unable to read node alias string
Error: Unknown node alias '%s'
Error: block device name is not set
nothing || s->cancelled || !!alias_map == !!bitmap_alias_map
Unable to read bitmap alias string
Error: Unknown bitmap alias '%s' on node '%s' (alias '%s')
Error: unknown dirty bitmap '%s' for block device '%s'
Bitmap with the same name ('%s') already exists on destination
Unknown flags in migrated dirty bitmap header: %x
%d@%zu.%06zu:dirty_bitmap_load_complete 
%d@%zu.%06zu:dirty_bitmap_load_bits_enter chunk: %lu %u
dirty_bitmap_load_bits_enter chunk: %lu %u
%d@%zu.%06zu:dirty_bitmap_load_bits_zeroes 
dirty_bitmap_load_bits_zeroes 
Bitmap migration stream buffer allocation request is too large
Migrated bitmap granularity doesn't match the destination bitmap '%s' granularity
%d@%zu.%06zu:dirty_bitmap_load_success 
%d@%zu.%06zu:migration_block_activation %s
migration_block_activation %s
%s: bdrv_inactivate_all() failed: %d
%d@%zu.%06zu:migration_set_incoming_channel ioc=%p ioctype=%s
migration_set_incoming_channel ioc=%p ioctype=%s
%d@%zu.%06zu:migration_set_outgoing_channel ioc=%p ioctype=%s hostname=%s err=%p
migration_set_outgoing_channel ioc=%p ioctype=%s hostname=%s err=%p
/home/virus/AMD/AMD/migration/channel-block.h
Non-blocking mode not supported for block devices
Size of VMstate region is unknown
%d@%zu.%06zu:cpr_save_fd %s, id %d, fd %d
%d@%zu.%06zu:cpr_delete_fd %s, id %d
%d@%zu.%06zu:cpr_find_fd %s, id %d returns %d
cpr_find_fd %s, id %d returns %d
%d@%zu.%06zu:cpr_state_save %s mode
%d@%zu.%06zu:cpr_state_load %s mode
Not a migration stream (bad magic %x)
Unsupported migration stream version %d
%d@%zu.%06zu:cpr_transfer_output %s
bad cpr channel address; must be unix
%d@%zu.%06zu:cpr_transfer_input %s
bad cpr channel socket type; must be unix
%d@%zu.%06zu:cpu_throttle_dirty_sync 
%d@%zu.%06zu:cpu_throttle_set set guest CPU throttled by %d%%
cpu_throttle_set set guest CPU throttled by %d%%
%d@%zu.%06zu:get_ramblock_vfn_hash ramblock name: %s, vfn: %lu, hash: %u
get_ramblock_vfn_hash ramblock name: %s, vfn: %lu, hash: %u
%d@%zu.%06zu:skip_sample_ramblock ramblock name: %s, ramblock size: %lu
skip_sample_ramblock ramblock name: %s, ramblock size: %lu
%d@%zu.%06zu:query_dirty_rate_info current state %s
query_dirty_rate_info current state %s
%d@%zu.%06zu:dirtyrate_do_calculate_vcpu vcpu[%d]: %lu MB/s
dirtyrate_do_calculate_vcpu vcpu[%d]: %lu MB/s
%d@%zu.%06zu:dirtyrate_set_state new state %s
dirtyrate_set_state new state %s
change dirtyrate state failed.
%d@%zu.%06zu:find_page_matched ramblock %s addr or size changed
find_page_matched ramblock %s addr or size changed
%d@%zu.%06zu:calc_page_dirty_rate ramblock name: %s, new hash: %u, old hash: %u
calc_page_dirty_rate ramblock name: %s, new hash: %u, old hash: %u
%d@%zu.%06zu:dirtyrate_calculate dirty rate: %li MB/s
dirtyrate_calculate dirty rate: %li MB/s
the dirty rate is already being measured.
Calculation time is out of range [%dms, %dms].
sample-pages is used only in page-sampling mode
sample-pages is out of range[%d, %d].
mode %s is not enabled, use other method instead.
init dirty rate calculation state failed.
vcpu[%li], Dirty rate: %li (MB/s)
Incorrect period length specified!
Either dirty ring or dirty bitmap can be specified!
Starting dirty rate measurement with period %li seconds
[Please use 'info dirty_rate' to check results]
%d@%zu.%06zu:migration_exec_outgoing cmd=%s
migration_exec_outgoing cmd=%s
%d@%zu.%06zu:migration_exec_incoming cmd=%s
migration_exec_incoming cmd=%s
fd: migration to a file is deprecated. Use file: instead.
%d@%zu.%06zu:migration_fd_outgoing fd=%d
%d@%zu.%06zu:migration_fd_incoming fd=%d
%d@%zu.%06zu:migration_file_outgoing filename=%s
migration_file_outgoing filename=%s
failed to truncate migration file to offset %lx
%d@%zu.%06zu:migration_file_incoming filename=%s
migration_file_incoming filename=%s
offset %lxoutside of ramblock %s range
multifd recv (%u): read 0x%zx, expected 0x%zx
%d@%zu.%06zu:migrate_global_state_post_load loaded state: %s
migrate_global_state_post_load loaded state: %s
strlen(state_str) < sizeof(global_state.runstate)
%d@%zu.%06zu:migrate_global_state_pre_save saved state: %s
migrate_global_state_pre_save saved state: %s
s->size <= sizeof(s->runstate)
Zero-copy-send fallbacks happened: %lu times
xbzrle transferred: %lu kbytes
xbzrle cache miss rate: %0.2f
dirty-limit throttle time: %lu us
dirty-limit ring full time: %lu us
vfio device transferred: %lu kbytes
../migration/migration-hmp-cmds.c
params->has_throttle_trigger_threshold
params->has_cpu_throttle_initial
params->has_cpu_throttle_increment
params->has_cpu_throttle_tailslow
params->has_avail_switchover_bandwidth
params->has_x_checkpoint_delay
params->has_zero_page_detection
The block-bitmap-mapping parameter can only be set through QMP
terminal does not allow synchronous migration, continuing detached
%d@%zu.%06zu:migrate_handle_rp_req_pages in %s at 0x%zx len 0x%zx
migrate_handle_rp_req_pages in %s at 0x%zx len 0x%zx
MIG_RP_MSG_REQ_PAGES: Misaligned page request, start:%lx len: %zd
Migration requires seekable transport (e.g. file)
Migration requires multi-channel URIs (e.g. tcp)
Migration requires a transport that allows for extra fds (e.g. file)
Migration requires streamable transport (eg unix)
%d@%zu.%06zu:migrate_send_rp_message %d: len %d
migrate_send_rp_message %d: len %d
%d@%zu.%06zu:migrate_transferred transferred %lu time_spent %lu bandwidth %lu switchover_bw %lu max_size %ld
migrate_transferred transferred %lu time_spent %lu bandwidth %lu switchover_bw %lu max_size %ld
disallowing migration blocker (migration/snapshot in progress) for: 
%d@%zu.%06zu:vmstate_downtime_checkpoint %s
vmstate_downtime_checkpoint %s
%d@%zu.%06zu:migration_completion_vm_stop ret %d
migration_completion_vm_stop ret %d
postcopy_page_req_add new page req %p total %d
%d@%zu.%06zu:postcopy_page_req_add new page req %p total %d
ENABLE_COLO command come in migration stream, but x-colo capability is not set
COLO: cannot disable RAM discard
unknown migration protocol: %s
%s: MSG_RP_RECV_BITMAP only used for recovery
%d@%zu.%06zu:migrate_send_rp_recv_bitmap block '%s' size 0x%li
migrate_send_rp_recv_bitmap block '%s' size 0x%li
Enable postcopy with migrate_set_capability before the start of migration
Postcopy must be started after migration has been started
new_state < MIGRATION_STATUS__MAX
%d@%zu.%06zu:migrate_set_state new state %s
migrate_set_state new state %s
migration_needs_multiple_sockets()
need either 'uri' or 'channels' argument
Channel list must have only one entry, for type 'main'
Illegal migration incoming state: %s
RDMA and XBZRLE can't be used together
RDMA and multifd can't be used together
Block inactivate failed during switchover
%d@%zu.%06zu:migration_precopy_complete 
migration: partially unplugged device on failure
%d@%zu.%06zu:migrate_error error=%s
%d@%zu.%06zu:process_incoming_migration_co_end ret=%d postcopy-state=%d
process_incoming_migration_co_end ret=%d postcopy-state=%d
%d@%zu.%06zu:process_incoming_migration_co_postcopy_end_main 
process_incoming_migration_co_postcopy_end_main 
%s: Illegal migration status (%s) detected
%d@%zu.%06zu:source_return_path_thread_entry 
source_return_path_thread_entry 
%d@%zu.%06zu:source_return_path_thread_loop_top 
source_return_path_thread_loop_top 
Received invalid message 0x%04x length 0x%04x
Received '%s' message (0x%04x) withincorrect length %d expecting %zu
Failed reading data for message 0x%04x read %d expected %d
%d@%zu.%06zu:source_return_path_thread_shut 0x%x
source_return_path_thread_shut 0x%x
%d@%zu.%06zu:source_return_path_thread_pong 0x%x
source_return_path_thread_pong 0x%x
Req_Page_id with length %d expecting %zd
MIG_RP_MSG_RECV_BITMAP missing block name
MIG_RP_MSG_RECV_BITMAP has invalid block name '%s'
%d@%zu.%06zu:source_return_path_thread_resume_ack %u
source_return_path_thread_resume_ack %u
%d@%zu.%06zu:source_return_path_thread_switchover_acked 
source_return_path_thread_switchover_acked 
%d@%zu.%06zu:source_return_path_thread_bad_end 
source_return_path_thread_bad_end 
%d@%zu.%06zu:source_return_path_thread_end 
source_return_path_thread_end 
%d@%zu.%06zu:migration_return_path_end_before 
migration_return_path_end_before 
%d@%zu.%06zu:migration_return_path_end_after 
migration_return_path_end_after 
%d@%zu.%06zu:migration_cleanup 
!ret || type == MIG_EVENT_PRECOPY_SETUP
s->state == MIGRATION_STATUS_POSTCOPY_ACTIVE
Detected IO failure for postcopy. Migration paused.
%s: resume_prepare() failure detected: %d
%s: postcopy_preempt_establish_channel(): %d
%d@%zu.%06zu:postcopy_pause_continued 
%d@%zu.%06zu:migration_thread_file_err 
%d@%zu.%06zu:migration_thread_setup_complete 
migration_thread_setup_complete 
%d@%zu.%06zu:migration_completion_file_err 
migration_completion_file_err 
%d@%zu.%06zu:migration_thread_after_loop 
%d@%zu.%06zu:migration_cancel 
mode >= MIG_MODE_NORMAL && mode < MIG_MODE__MAX
disallowing migration blocker (--only-migratable) for: 
The incoming migration has already been started
'-incoming' was not specified on the command line
Migrate recover can only be run when postcopy is paused.
Postcopy migration is paused by the user
Failed to pause source migration
migrate-pause is currently only supported during postcopy-active or postcopy-recover state
Failed to pause destination migration
Channel list has more than one %s entry
Channel list has no main entry
missing 'cpr' migration channel
Cannot resume if there is no paused migration
Postcopy recovery cannot work when release-ram capability is set
There's a migration process in progress
Guest is waiting for an incoming migration
Can't migrate the vm that was paused due to previous migration
Can't migrate this vm with hardware poisoned memory, please reboot the vm and try again
Cannot use TLS with mapped-ram
Cannot use compression with mapped-ram
Postcopy migration in progress, cannot cancel.
Migration not in expected state: %s
%d@%zu.%06zu:migration_rate_limit_pre %d ms
migration_rate_limit_pre %d ms
%d@%zu.%06zu:migration_rate_limit_post urgent: %d
migration_rate_limit_post urgent: %d
%d@%zu.%06zu:migrate_pending_estimate estimate pending size %lu (pre = %lu post=%lu)
migrate_pending_estimate estimate pending size %lu (pre = %lu post=%lu)
%d@%zu.%06zu:migrate_pending_exact exact pending size %lu (pre = %lu post=%lu)
migrate_pending_exact exact pending size %lu (pre = %lu post=%lu)
%d@%zu.%06zu:migration_thread_low_pending %lu
migration_thread_low_pending %lu
%d@%zu.%06zu:migration_completion_postcopy_end 
migration_completion_postcopy_end 
%d@%zu.%06zu:migration_completion_postcopy_end_after_complete 
migration_completion_postcopy_end_after_complete 
%s: Failed to establish preempt channel
%d@%zu.%06zu:postcopy_start_set_run 
Postcopy save non-postcopiable iterables failed
Postcopy save non-iterable device states failed
postcopy_start: Migration stream errored (pre package)
%s: Failed to send packaged data
postcopy_start: Migration stream error
%d@%zu.%06zu:postcopy_preempt_enabled %d
Unable to open return-path for postcopy
%d@%zu.%06zu:open_return_path_on_source 
%d@%zu.%06zu:open_return_path_on_source_continue 
open_return_path_on_source_continue 
migration_stop_vm failed, error %d
%d@%zu.%06zu:multifd_recv_terminate_threads error %d
multifd_recv_terminate_threads error %d
%d@%zu.%06zu:multifd_recv_thread_start %u
multifd: received packet magic %x, expected %x
multifd: received packet version %u, expected %u
multifd: unexpected EOF after packet header
%d@%zu.%06zu:multifd_recv_unfill channel %u packet_num %lu flags 0x%x next packet size %u
multifd_recv_unfill channel %u packet_num %lu flags 0x%x next packet size %u
unterminated multifd device state idstr
multifd: received empty device state packet
multifd: received SYNC device state packet
%d@%zu.%06zu:multifd_recv_thread_end channel %u packets %lu
multifd_recv_thread_end channel %u packets %lu
%d@%zu.%06zu:multifd_new_send_channel_async channel %u
multifd_new_send_channel_async channel %u
%d@%zu.%06zu:multifd_set_outgoing_channel ioc=%p ioctype=%s hostname=%s
multifd_set_outgoing_channel ioc=%p ioctype=%s hostname=%s
%d@%zu.%06zu:multifd_tls_outgoing_handshake_start ioc=%p tioc=%p hostname=%s
multifd_tls_outgoing_handshake_start ioc=%p tioc=%p hostname=%s
%d@%zu.%06zu:multifd_new_send_channel_async_error channel=%u err=%p
multifd_new_send_channel_async_error channel=%u err=%p
0 <= method && method < MULTIFD_COMPRESSION__MAX
%d@%zu.%06zu:multifd_send_fill channel %u packet_num %lu flags 0x%x next packet size %u
multifd_send_fill channel %u packet_num %lu flags 0x%x next packet size %u
%d@%zu.%06zu:multifd_send_thread_start %u
!multifd_payload_empty(p->data)
%d@%zu.%06zu:multifd_send_error channel %u
multifd_send_error channel %u
%d@%zu.%06zu:multifd_send_thread_end channel %u packets %lu
multifd_send_thread_end channel %u packets %lu
multifd_payload_empty(p->data)
multifd_send_%d: Failed to terminate TLS connection: %s
%d@%zu.%06zu:multifd_send_terminate_threads 
multifd_send_terminate_threads 
%d@%zu.%06zu:multifd_send_sync_main_signal channel %u
multifd_send_sync_main_signal channel %u
qatomic_read(&p->pending_sync) == MULTIFD_SYNC_NONE
%d@%zu.%06zu:multifd_send_sync_main_wait channel %u
multifd_send_sync_main_wait channel %u
%d@%zu.%06zu:multifd_send_sync_main packet num %ld
multifd_send_sync_main packet num %ld
%d@%zu.%06zu:multifd_recv_sync_main_signal channel %u
multifd_recv_sync_main_signal channel %u
%d@%zu.%06zu:multifd_recv_sync_main_wait iter %u
multifd_recv_sync_main_wait iter %u
%d@%zu.%06zu:multifd_recv_sync_main packet num %ld
multifd_recv_sync_main packet num %ld
multifd: received packet magic %x expected %x
multifd: received packet version %u expected %u
multifd: received uuid '%s' and expected uuid '%s' for channel %hhd
multifd: received channel id %u is greater than number of channels %u
failed to receive packet via multifd channel %d: 
%d@%zu.%06zu:multifd_recv_new_channel channel %u
multifd_recv_new_channel channel %u
multifd: received id '%d' already setup'
../migration/multifd-device-state.c
multifd_payload_device_state(p->data)
!(p->flags & MULTIFD_FLAG_SYNC)
multifd_payload_empty(multifd_send_device_state->send_data)
multifd_device_state_supported()
!qatomic_read(&multifd_send_device_state->threads_abort)
multifd %u: flags received %x flags expected %x
%d@%zu.%06zu:multifd_send_ram_fill channel %u normal pages %u zero pages %u
multifd_send_ram_fill channel %u normal pages %u zero pages %u
multifd: received packet with %u pages, expected %u
multifd: received packet with %u non-zero pages, which exceeds maximum expected pages %u
multifd: received packet with %u zero pages, expected maximum %u
multifd: offset too long %lu (max %lx)
multifd %u: inflate generated too few output
multifd %u: inflate returned %d instead of Z_OK
multifd %u: packet size received %u size expected %u
multifd %u: inflate init failed
multifd %u: out of memory for zbuff
multifd %u: deflate failed to compress all input
multifd %u: deflate returned %d instead of Z_OK
s->parameters.multifd_compression < MULTIFD_COMPRESSION__MAX
zero-blocks capability is deprecated
Postcopy is not compatible with ignore-shared
Postcopy is not yet compatible with multifd
Background-snapshot is not supported by host kernel
Background-snapshot is not compatible with guest memory configuration
Background-snapshot is not compatible with %s
Zero copy only available for non-compressed non-TLS multifd migration
Postcopy preempt requires postcopy-ram
Postcopy preempt must be set before incoming starts
Multifd must be set before incoming starts
Capability 'switchover-ack' requires capability 'return-path'
dirty-limit conflicts with auto-converge either of then available currently
dirty-limit requires KVM with accelerator property 'dirty-ring-size' set
Multifd is not compatible with xbzrle
Mapped-ram migration is incompatible with xbzrle
Mapped-ram migration is incompatible with postcopy
mode >= 0 && mode < MIG_MODE__MAX
an integer in the range of 1 to 100
an integer in the range of 1 to 99
an integer in the range of 0 to (2000 * 1000) ms
a power of two no less than the target page size
an integer in the range of cpu_throttle_initial to 99
Invalid mapping given for block-bitmap-mapping: 
Mapped-ram only available for non-compressed non-TLS multifd migration
Parameter 'vcpu_dirty_limit' must be greater than 1 MB/s
No build-time support for direct-io
params->tls_creds->type == QTYPE_QSTRING
params->tls_hostname->type == QTYPE_QSTRING
params->tls_authz->type == QTYPE_QSTRING
%d@%zu.%06zu:postcopy_init_range %s: %p offset=0x%zx length=0x%zx
postcopy_init_range %s: %p offset=0x%zx length=0x%zx
%d@%zu.%06zu:postcopy_pause_fault_thread 
%d@%zu.%06zu:postcopy_pause_fault_thread_continued 
postcopy_pause_fault_thread_continued 
%d@%zu.%06zu:postcopy_cleanup_range %s: %p offset=0x%zx length=0x%zx
postcopy_cleanup_range %s: %p offset=0x%zx length=0x%zx
%d@%zu.%06zu:postcopy_nhp_range %s: %p offset=0x%zx length=0x%zx
postcopy_nhp_range %s: %p offset=0x%zx length=0x%zx
%s userfault: Region doesn't support COPY
%d@%zu.%06zu:postcopy_preempt_thread_entry 
postcopy_preempt_thread_entry 
%d@%zu.%06zu:postcopy_pause_fast_load 
%d@%zu.%06zu:postcopy_pause_fast_load_continued 
postcopy_pause_fast_load_continued 
%d@%zu.%06zu:postcopy_preempt_thread_exit 
postcopy_preempt_thread_exit 
Userfault feature detection failed
%s failed: UFFDIO_API failed: %s
Missing userfault features: %lx
Userfault on this host does not support huge pages
%d@%zu.%06zu:postcopy_preempt_tls_handshake 
postcopy_preempt_tls_handshake 
%d@%zu.%06zu:postcopy_preempt_new_channel 
postcopy_preempt_new_channel 
%d@%zu.%06zu:postcopy_page_req_del resolved page req %p total %d
postcopy_page_req_del resolved page req %p total %d
%d@%zu.%06zu:mark_postcopy_blocktime_end addr: 0x%lx, dd: %p, time: %u, affected_cpu: %d
mark_postcopy_blocktime_end addr: 0x%lx, dd: %p, time: %u, affected_cpu: %d
Target page size bigger than host page size
Postcopy requires RAM blocks to be a page size multiple, block %s is 0x%lx bytes with a page size of 0x%zx
Host backend files need to be TMPFS or HUGETLBFS only
QEMU_PTR_IS_ALIGNED(testarea, pagesize)
Missing userfault map features: %lx
%d@%zu.%06zu:postcopy_wake_shared at 0x%lx in %s
postcopy_wake_shared at 0x%lx in %s
%s: Failed to open userfault fd: %s
%s: Opening userfault_event_fd: %s
ram_block_enable_notify failed
%s: Failed to map postcopy_tmp_pages[%d]: %s
%s: Failed to map large zero page %s
%d@%zu.%06zu:postcopy_ram_enable_notify 
%d@%zu.%06zu:postcopy_place_page host=%p
%d@%zu.%06zu:postcopy_place_page_zero host=%p
postcopy_place_page_zero host=%p
QEMU_IS_ALIGNED(start, qemu_ram_pagesize(rb))
%d@%zu.%06zu:postcopy_request_shared_page for %s in %s offset 0x%lx
postcopy_request_shared_page for %s in %s offset 0x%lx
%d@%zu.%06zu:postcopy_request_shared_page_present %s already %s offset 0x%lx
postcopy_request_shared_page_present %s already %s offset 0x%lx
%d@%zu.%06zu:postcopy_ram_fault_thread_entry 
postcopy_ram_fault_thread_entry 
%d@%zu.%06zu:postcopy_ram_fault_thread_fds_core ufd: %d quitfd: %d
postcopy_ram_fault_thread_fds_core ufd: %d quitfd: %d
%d@%zu.%06zu:postcopy_ram_fault_thread_fds_extra %zd/%s: %d
postcopy_ram_fault_thread_fds_extra %zd/%s: %d
%d@%zu.%06zu:postcopy_ram_fault_thread_quit 
postcopy_ram_fault_thread_quit 
%s: Failed to read full userfault message: %s
%s: Read %d bytes from userfaultfd expected %zd
%s: Read unexpected event %ud from userfaultfd
postcopy_ram_fault_thread: Fault outside guest: %lx
%d@%zu.%06zu:postcopy_ram_fault_thread_request Request for HVA=0x%lx rb=%s offset=0x%zx pid=%u
postcopy_ram_fault_thread_request Request for HVA=0x%lx rb=%s offset=0x%zx pid=%u
%d@%zu.%06zu:get_mem_fault_cpu_index cpu: %d, pid: %u
get_mem_fault_cpu_index cpu: %d, pid: %u
%d@%zu.%06zu:mark_postcopy_blocktime_begin addr: 0x%lx, dd: %p, time: %u, cpu: %d, already_received: %d
mark_postcopy_blocktime_begin addr: 0x%lx, dd: %p, time: %u, cpu: %d, already_received: %d
%s: Failed to read full userfault message: %s (shared) revents=%d
%s: Read %d bytes from userfaultfd expected %zd (shared)
%s: Read unexpected event %ud from userfaultfd (shared)
%s: Failed to resolve shared fault on %zd/%s
%d@%zu.%06zu:postcopy_ram_fault_thread_exit 
postcopy_ram_fault_thread_exit 
%d@%zu.%06zu:postcopy_ram_incoming_cleanup_entry 
postcopy_ram_incoming_cleanup_entry 
%d@%zu.%06zu:postcopy_ram_incoming_cleanup_join 
postcopy_ram_incoming_cleanup_join 
%d@%zu.%06zu:postcopy_ram_incoming_cleanup_closeuf 
postcopy_ram_incoming_cleanup_closeuf 
%d@%zu.%06zu:postcopy_ram_incoming_cleanup_blocktime total blocktime %lu
postcopy_ram_incoming_cleanup_blocktime total blocktime %lu
%d@%zu.%06zu:postcopy_ram_incoming_cleanup_exit 
postcopy_ram_incoming_cleanup_exit 
%d@%zu.%06zu:postcopy_discard_send_range %s:%lx/%lx
postcopy_discard_send_range %s:%lx/%lx
%d@%zu.%06zu:postcopy_discard_send_finish %s mask words sent=%d in %d commands
postcopy_discard_send_finish %s mask words sent=%d in %d commands
%s: Detected duplicate SaveStateEntry: id=%s, instance_id=0x%x
save_state_priority(se) < priority
VMSTATE not ending with VMS_END: %s
!strncmp(vmsd->name, (*subsection)->name, strlen(vmsd->name))
%d@%zu.%06zu:savevm_command_send com=0x%x len=%d
savevm_command_send com=0x%x len=%d
UUID is received %s, but local uuid isn't set
UUID received is %s and local is %s
Received unknown capability %s
%s: Read section footer failed: %d
Mismatched section id in footer for %s - read 0x%x expected 0x%x
%d@%zu.%06zu:loadvm_postcopy_ram_handle_discard 
loadvm_postcopy_ram_handle_discard 
CMD_POSTCOPY_RAM_DISCARD in wrong postcopy state (%d)
CMD_POSTCOPY_RAM_DISCARD invalid length (%d)
CMD_POSTCOPY_RAM_DISCARD invalid version (%d)
CMD_POSTCOPY_RAM_DISCARD Failed to read RAMBlock ID
CMD_POSTCOPY_RAM_DISCARD missing nil (%d)
%d@%zu.%06zu:loadvm_postcopy_ram_handle_discard_header %s: %ud
loadvm_postcopy_ram_handle_discard_header %s: %ud
%d@%zu.%06zu:loadvm_postcopy_ram_handle_discard_end 
loadvm_postcopy_ram_handle_discard_end 
%s: send rp message failed for addr %p
%d@%zu.%06zu:postcopy_page_req_sync sync page req %p
postcopy_page_req_sync sync page req %p
%s: invalid payload length (%d)
%d@%zu.%06zu:loadvm_handle_recv_bitmap %s
instance_id != VMSTATE_INSTANCE_ID_ANY
%d@%zu.%06zu:savevm_section_skip %s, section_id %u
savevm_section_skip %s, section_id %u
%d@%zu.%06zu:savevm_section_start %s, section_id %u
savevm_section_start %s, section_id %u
%d@%zu.%06zu:vmstate_save %s, %s
%d@%zu.%06zu:savevm_section_end %s, section_id %u -> %d
savevm_section_end %s, section_id %u -> %d
%d@%zu.%06zu:vmstate_load %s, %s
Unable to read ID string for section %u
%s: Failed to read instance/version ID: %d
%d@%zu.%06zu:qemu_loadvm_state_section_startfull %u(%s) %u %u
qemu_loadvm_state_section_startfull %u(%s) %u %u
Unknown savevm section or instance '%s' %u. Make sure that your current VM setup matches your saved VM setup, including any hotplugged devices
savevm: unsupported version %d for '%s' v%d
loadvm: %s RAM loading not allowed on Xen
error while loading state for instance 0x%x of device '%s'
%d@%zu.%06zu:vmstate_downtime_load type=%s idstr=%s instance_id=%d downtime=%li
vmstate_downtime_load type=%s idstr=%s instance_id=%d downtime=%li
Machine type received is '%.*s' and local is '%s'
Received TARGET_PAGE_BITS is %d but local is %d
Capability %s is %s, but received capability is %s
dst-postcopy-bh-cache-invalidated
!se->compat || se->instance_id == 0
alias_id == -1 || required_for_version >= vmsd->minimum_version_id
Path too long for VMState (%s)
%d@%zu.%06zu:savevm_send_colo_enable 
%d@%zu.%06zu:savevm_send_ping 0x%x
%d@%zu.%06zu:savevm_send_open_return_path 
savevm_send_open_return_path 
%s: Unreasonably large packaged state: %zu
%d@%zu.%06zu:qemu_savevm_send_packaged 
%d@%zu.%06zu:qemu_savevm_send_postcopy_advise 
qemu_savevm_send_postcopy_advise 
%d@%zu.%06zu:qemu_savevm_send_postcopy_ram_discard %s: %ud
qemu_savevm_send_postcopy_ram_discard %s: %ud
%d@%zu.%06zu:savevm_send_postcopy_listen 
%d@%zu.%06zu:savevm_send_postcopy_run 
%d@%zu.%06zu:savevm_send_postcopy_resume 
%d@%zu.%06zu:savevm_send_recv_bitmap %s
%d@%zu.%06zu:savevm_send_switchover_start 
savevm_send_switchover_start 
State blocked by non-migratable device '%s'
%d@%zu.%06zu:savevm_state_header 
%d@%zu.%06zu:savevm_state_setup 
%d@%zu.%06zu:savevm_state_resume_prepare 
%d@%zu.%06zu:savevm_state_iterate 
failed to save SaveStateEntry with id(name): %d(%s): %d
%d@%zu.%06zu:vmstate_downtime_save type=%s idstr=%s instance_id=%d downtime=%li
vmstate_downtime_save type=%s idstr=%s instance_id=%d downtime=%li
%d@%zu.%06zu:savevm_state_cleanup 
%d@%zu.%06zu:loadvm_state_cleanup 
%d@%zu.%06zu:qemu_loadvm_state_section %d
%s: Failed to read section ID: %d
%d@%zu.%06zu:qemu_loadvm_state_section_partend %u
qemu_loadvm_state_section_partend %u
error while loading state section id %d(%s)
MIG_CMD 0x%x unknown (len 0x%x)
%d@%zu.%06zu:loadvm_process_command com=%s len=%d
loadvm_process_command com=%s len=%d
%s received with bad length - expecting %zu, got %d
CMD_OPEN_RETURN_PATH called when RP already open
Could not send switchover ack RP MSG, err %d (%s)
%d@%zu.%06zu:loadvm_process_command_ping 0x%x
loadvm_process_command_ping 0x%x
CMD_PING (0x%x) received with no return path
%d@%zu.%06zu:loadvm_handle_cmd_packaged %u
loadvm_handle_cmd_packaged %u
CMD_PACKAGED: Buffer receive fail ret=%d length=%zu
%d@%zu.%06zu:loadvm_handle_cmd_packaged_received %d
loadvm_handle_cmd_packaged_received %d
%d@%zu.%06zu:loadvm_handle_cmd_packaged_main %d
loadvm_handle_cmd_packaged_main %d
%d@%zu.%06zu:loadvm_postcopy_handle_advise 
loadvm_postcopy_handle_advise 
CMD_POSTCOPY_ADVISE in wrong postcopy state (%d)
RAM postcopy is enabled but have 0 byte advise
RAM postcopy is disabled but have 16 byte advise
CMD_POSTCOPY_ADVISE invalid length (%d)
Postcopy needs matching RAM page sizes (s=%lx d=%lx)
Postcopy needs matching target page sizes (s=%d d=%zd)
%d@%zu.%06zu:loadvm_postcopy_handle_listen %s
loadvm_postcopy_handle_listen %s
CMD_POSTCOPY_LISTEN in wrong postcopy state (%d)
%d@%zu.%06zu:loadvm_postcopy_handle_run 
CMD_POSTCOPY_RUN in wrong postcopy state (%d)
%d@%zu.%06zu:loadvm_postcopy_handle_resume 
loadvm_postcopy_handle_resume 
%d@%zu.%06zu:qemu_loadvm_state_section_command %d
qemu_loadvm_state_section_command %d
Unknown savevm section type %d
%d@%zu.%06zu:postcopy_pause_incoming 
%d@%zu.%06zu:postcopy_pause_incoming_continued 
postcopy_pause_incoming_continued 
%d@%zu.%06zu:postcopy_ram_listen_thread_start 
postcopy_ram_listen_thread_start 
%d@%zu.%06zu:postcopy_ram_listen_thread_exit 
postcopy_ram_listen_thread_exit 
%s: loadvm failed during postcopy: %d. All states are migrated except dirty bitmaps. Some dirty bitmaps may be lost, and present migrated dirty bitmaps are correctly migrated and valid.
SaveVM v2 format is obsolete and don't work anymore
Unsupported migration stream version
%d@%zu.%06zu:loadvm_state_setup 
Load state of device %s failed: 
%d@%zu.%06zu:loadvm_state_switchover_ack_needed Switchover ack pending num=%u
loadvm_state_switchover_ack_needed Switchover ack pending num=%u
%d@%zu.%06zu:qemu_loadvm_state_post_main %d
qemu_loadvm_state_post_main %d
Expected vmdescription section, but got %d
Failed to load device state: %d
%d@%zu.%06zu:loadvm_approve_switchover Switchover ack pending num=%u
loadvm_approve_switchover Switchover ack pending num=%u
Unknown idstr %s or instance id %u for load state buffer
idstr %s / instance %u has no load state buffer operation
Record/replay does not allow making snapshot right now. Try once more later.
Snapshot '%s' already exists in one or more devices
saving Xen device state failed
Cannot update device state while vm is running
loading Xen device state failed
Snapshot '%s' does not exist in one or more devices
This is a disk-only snapshot. Revert to it  offline using qemu-img
Error %d while loading VM state
configuration/target-page-bits
%d@%zu.%06zu:migration_socket_outgoing_error error=%s
migration_socket_outgoing_error error=%s
%d@%zu.%06zu:migration_socket_outgoing_connected hostname=%s
migration_socket_outgoing_connected hostname=%s
Zero copy send feature not detected in host kernel
%d@%zu.%06zu:migration_socket_incoming_accepted 
migration_socket_incoming_accepted 
%s: Extra incoming migration connection; ignoring
%d@%zu.%06zu:migration_tls_incoming_handshake_error err=%s
migration_tls_incoming_handshake_error err=%s
%d@%zu.%06zu:migration_tls_incoming_handshake_complete 
migration_tls_incoming_handshake_complete 
%d@%zu.%06zu:migration_tls_outgoing_handshake_error err=%s
migration_tls_outgoing_handshake_error err=%s
%d@%zu.%06zu:migration_tls_outgoing_handshake_complete 
migration_tls_outgoing_handshake_complete 
%d@%zu.%06zu:migration_tls_incoming_handshake_start 
migration_tls_incoming_handshake_start 
%d@%zu.%06zu:migration_tls_outgoing_handshake_start hostname=%s
migration_tls_outgoing_handshake_start hostname=%s
/home/virus/AMD/AMD/include/io/channel-tls.h
%d@%zu.%06zu:colo_failover_set_state new state %s
colo_failover_set_state new state %s
Unknown error for failover, old_state = %s
COLO failover is already activated
%d@%zu.%06zu:colo_send_message Send '%s' message
colo_send_message Send '%s' message
%d@%zu.%06zu:colo_receive_message Receive '%s' message
colo_receive_message Receive '%s' message
Unexpected COLO message %d, expected %d
COLO mode must be COLO_MODE_SECONDARY
COLO incoming thread: Open QEMUFile to_src_file failed
%d@%zu.%06zu:colo_vm_state_change Change '%s' => '%s'
colo_vm_state_change Change '%s' => '%s'
Load VM's live state (ram) error
Failed to get value for COLO message: %s
Got %lu VMState data, less than expected %lu
COLO: load device state failed
colo_do_failover failed because the colo mode could not be obtained
Incorrect state (%s) while doing failover for Primary VM
Unknown error while do failover for secondary VM,old_state: %s
"-S" qemu option will be ignored in secondary side
Incorrect state (%s) while doing failover for secondary VM
Parameter 'failover' is only for stopping replication
COLO mode must be COLO_MODE_PRIMARY
Open QEMUFile from_dst_file failed
Failed to send value for message:%s
migration_incoming_colo_enabled()
receive cm event, cm event is %d
failed to allocate protection domain
failed to allocate receive completion channel
failed to allocate receive completion queue
failed to allocate send completion channel
failed to allocate send completion queue
%d@%zu.%06zu:qemu_rdma_init_ram_blocks Allocated %d local ram block structures
qemu_rdma_init_ram_blocks Allocated %d local ram block structures
%d@%zu.%06zu:qemu_rdma_dump_gid %s Source GID: %s, Dest GID: %s
qemu_rdma_dump_gid %s Source GID: %s, Dest GID: %s
%d@%zu.%06zu:qemu_rdma_poll_recv completion %lu received (%ld) left %d
qemu_rdma_poll_recv completion %lu received (%ld) left %d
%d@%zu.%06zu:qemu_rdma_poll_write completions %lu left %d, block %lu, chunk: %lu %p %p
qemu_rdma_poll_write completions %lu left %d, block %lu, chunk: %lu %p %p
%d@%zu.%06zu:qemu_rdma_poll_other other completion %lu received left %d
qemu_rdma_poll_other other completion %lu received left %d
%d@%zu.%06zu:qemu_rdma_advise_mr Try to advise block %s prefetch at %u@0x%lx: %s
qemu_rdma_advise_mr Try to advise block %s prefetch at %u@0x%lx: %s
%d@%zu.%06zu:qemu_rdma_register_and_get_keys Registering %lu bytes @ %p
qemu_rdma_register_and_get_keys Registering %lu bytes @ %p
%d@%zu.%06zu:qemu_rdma_register_odp_mr Try to register On-Demand Paging memory region: %s
qemu_rdma_register_odp_mr Try to register On-Demand Paging memory region: %s
%d@%zu.%06zu:rdma_add_block Added Block: '%s':%d, addr: %lu, offset: %lu length: %lu end: %lu bits %lu chunks %d
rdma_add_block Added Block: '%s':%d, addr: %lu, offset: %lu length: %lu end: %lu bits %lu chunks %d
%d@%zu.%06zu:qemu_rdma_block_for_wrid_miss A Wanted wrid %lu but got %lu
qemu_rdma_block_for_wrid_miss A Wanted wrid %lu but got %lu
%d@%zu.%06zu:qemu_rdma_post_send_control CONTROL: sending %s..
qemu_rdma_post_send_control CONTROL: sending %s..
head->len <= RDMA_CONTROL_MAX_BUFFER - sizeof(*head)
Failed to use post IB SEND for control
rdma migration: send polling control error
%d@%zu.%06zu:qemu_rdma_cleanup_disconnect 
qemu_rdma_cleanup_disconnect 
%d@%zu.%06zu:rdma_delete_block Deleted Block: %p, addr: %lu, offset: %lu length: %lu end: %lu bits %lu chunks %d
rdma_delete_block Deleted Block: %p, addr: %lu, offset: %lu length: %lu end: %lu bits %lu chunks %d
%d@%zu.%06zu:qemu_rdma_connect_pin_all_requested 
qemu_rdma_connect_pin_all_requested 
RDMA ERROR: connecting to destination!
RDMA ERROR: poll cm event timeout
RDMA ERROR: failed to poll cm event, errno=%i
RDMA ERROR: failed to get cm event
RDMA ERROR: no POLLIN event, revent=%x
RDMA: Server cannot support pinning all memory. Will register memory dynamically.
%d@%zu.%06zu:qemu_rdma_connect_pin_all_outcome %d
qemu_rdma_connect_pin_all_outcome %d
rdma migration: recv polling control error!
%d@%zu.%06zu:qemu_rdma_exchange_get_response_start CONTROL: %s receiving...
qemu_rdma_exchange_get_response_start CONTROL: %s receiving...
%d@%zu.%06zu:qemu_rdma_exchange_get_response_none Surprise: got %s (%d)
qemu_rdma_exchange_get_response_none Surprise: got %s (%d)
Was expecting a %s (%d) control message, but got: %s (%d), length: %d
Malformed length: %d byte_len %d
%d@%zu.%06zu:qemu_rdma_exchange_send_issue_callback 
qemu_rdma_exchange_send_issue_callback 
%d@%zu.%06zu:qemu_rdma_exchange_send_waiting Waiting for response %s
qemu_rdma_exchange_send_waiting Waiting for response %s
%d@%zu.%06zu:qemu_rdma_exchange_send_received Response %s received.
qemu_rdma_exchange_send_received Response %s received.
%d@%zu.%06zu:qemu_rdma_write_one_top Writing %lu chunks, (%lu MB)
qemu_rdma_write_one_top Writing %lu chunks, (%lu MB)
%d@%zu.%06zu:qemu_rdma_write_one_block (%d) Not clobbering: block: %d chunk %lu current %lu len %lu %d %d
qemu_rdma_write_one_block (%d) Not clobbering: block: %d chunk %lu current %lu len %lu %d %d
Failed to Wait for previous write to complete block %d chunk %lu current %lu len %lu %d
%d@%zu.%06zu:qemu_rdma_write_one_zero Entire chunk is zero, sending compress: %lu for %d bytes, index: %d, offset: %ld
qemu_rdma_write_one_zero Entire chunk is zero, sending compress: %lu for %d bytes, index: %d, offset: %ld
%d@%zu.%06zu:qemu_rdma_write_one_sendreg Sending registration request chunk %lu for %d bytes, index: %d, offset: %ld
qemu_rdma_write_one_sendreg Sending registration request chunk %lu for %d bytes, index: %d, offset: %ld
%d@%zu.%06zu:qemu_rdma_write_one_recvregres Received registration result: my key: 0x%x their key 0x%x, chunk %lu
qemu_rdma_write_one_recvregres Received registration result: my key: 0x%x their key 0x%x, chunk %lu
%d@%zu.%06zu:qemu_rdma_write_one_post Posting chunk: %lu, addr: 0x%lx remote: 0x%lx, bytes %u
qemu_rdma_write_one_post Posting chunk: %lu, addr: 0x%lx remote: 0x%lx, bytes %u
%d@%zu.%06zu:qemu_rdma_write_one_queue_full 
qemu_rdma_write_one_queue_full 
rdma migration: failed to make room in full send queue!
rdma migration: post rdma write failed
%d@%zu.%06zu:qemu_rdma_write_flush sent total: %d
qemu_rdma_write_flush sent total: %d
%d@%zu.%06zu:qemu_rdma_close 
%d@%zu.%06zu:qemu_rdma_dump_id_failed %s RDMA Device opened, but can't query port information
qemu_rdma_dump_id_failed %s RDMA Device opened, but can't query port information
%d@%zu.%06zu:qemu_rdma_dump_id %s RDMA Device opened: kernel name %s uverbs device name %s, infiniband_verbs class device path %s, infiniband class device path %s, transport: (%d) %s
qemu_rdma_dump_id %s RDMA Device opened: kernel name %s uverbs device name %s, infiniband_verbs class device path %s, infiniband class device path %s, transport: (%d) %s
could not open RDMA device context
RDMA ERROR: Could not query initial IB port
migrations may fail: IPv6 over RoCE / iWARP in linux is broken. But since you appear to have a mixed RoCE / IB environment, be sure to only migrate over the IB fabric until the kernel  fixes the bug.
RDMA ERROR: You only have RoCE / iWARP devices in your systems and your management software has specified '[::]', but IPv6 over RoCE / iWARP is not supported in Linux.
RDMA ERROR: Linux kernel's RoCE / iWARP does not support IPv6 (but patches on linux-rdma in progress)
RDMA ERROR: RDMA hostname has not been set
RDMA ERROR: could not create CM channel
RDMA ERROR: could not create channel id
RDMA ERROR: could not rdma_getaddrinfo address %s
%d@%zu.%06zu:qemu_rdma_resolve_host_trying Trying %s => %s
qemu_rdma_resolve_host_trying Trying %s => %s
RDMA ERROR: could not resolve address %s
RDMA ERROR: could not perform event_addr_resolved
RDMA ERROR: result not equal to event_addr_resolved %s
RDMA ERROR: could not resolve rdma route
RDMA ERROR: could not perform event_route_resolved
RDMA ERROR: result not equal to event_route_resolved: %s
RDMA ERROR: rdma migration: error allocating qp!
RDMA ERROR: rdma migration: error registering %d control!
%d@%zu.%06zu:qemu_rdma_accept_incoming_migration 
qemu_rdma_accept_incoming_migration 
Unknown source RDMA version: %d, bailing...
%d@%zu.%06zu:qemu_rdma_accept_pin_state %d
qemu_rdma_accept_pin_state %d
%d@%zu.%06zu:qemu_rdma_accept_pin_verbsc Verbs context after listen: %p
qemu_rdma_accept_pin_verbsc Verbs context after listen: %p
ibv context not matching %p, %p!
rdma migration: error allocating qp!
rdma: error registering %d control
rdma_accept get_cm_event failed
rdma_accept not event established
RDMA ERROR: Migration initialization failed
%d@%zu.%06zu:qemu_rdma_accept_incoming_migration_accepted 
qemu_rdma_accept_incoming_migration_accepted 
RDMA ERROR: could not open RDMA for input
Failed to register local dest ram block!
RDMAContext is NULL when check Gsource
RDMAContext is NULL when prepare Gsource
RDMAContext is NULL when dispatch Gsource
RDMA control channel output is not set
RDMA is in an error state waiting migration to abort!
RDMA control channel input is not set
%d@%zu.%06zu:qemu_rdma_fill RDMA %zd of %zd bytes already in buffer
qemu_rdma_fill RDMA %zd of %zd bytes already in buffer
(current_addr + length) <= (block->offset + block->length)
%d@%zu.%06zu:rdma_registration_handle_wait 
rdma_registration_handle_wait 
rdma: Too many requests in this message (%d).Bailing.
%d@%zu.%06zu:rdma_registration_handle_compress Zapping zero chunk: %ld bytes, index %d, offset %ld
rdma_registration_handle_compress Zapping zero chunk: %ld bytes, index %d, offset %ld
rdma: 'compress' bad block index %u (vs %d)
rdma: Zero page with non-zero (%d) value
%d@%zu.%06zu:rdma_registration_handle_finished 
rdma_registration_handle_finished 
%d@%zu.%06zu:rdma_registration_handle_ram_blocks 
rdma_registration_handle_ram_blocks 
%d@%zu.%06zu:rdma_registration_handle_ram_blocks_loop %s: @0x%lx/%lu host:@%p src_index: %u
rdma_registration_handle_ram_blocks_loop %s: @0x%lx/%lu host:@%p src_index: %u
%d@%zu.%06zu:rdma_registration_handle_register %d requests
rdma_registration_handle_register %d requests
%d@%zu.%06zu:rdma_registration_handle_register_loop Registration request (%d): index %d, current_addr %lu chunks: %lu
rdma_registration_handle_register_loop Registration request (%d): index %d, current_addr %lu chunks: %lu
rdma: 'register' bad block index %u (vs %d)
rdma: bad register address for block %s offset: %lx current_addr: %lx
rdma: bad chunk for block %s chunk: %lx
%d@%zu.%06zu:rdma_registration_handle_register_rkey 0x%x
rdma_registration_handle_register_rkey 0x%x
%d@%zu.%06zu:rdma_registration_handle_unregister %d requests
rdma_registration_handle_unregister %d requests
%d@%zu.%06zu:rdma_registration_handle_unregister_loop Unregistration request (%d): index %d, chunk %lu
rdma_registration_handle_unregister_loop Unregistration request (%d): index %d, chunk %lu
rdma unregistration chunk failed: %s
%d@%zu.%06zu:rdma_registration_handle_unregister_success %lu
rdma_registration_handle_unregister_success %lu
Invalid RESULT message at dest.
RAMBlock '%s' not found on destination
%d@%zu.%06zu:rdma_block_notification_handle %s at %d
rdma_block_notification_handle %s at %d
%d@%zu.%06zu:rdma_registration_start %lu
rdma migration: complete polling error!
%d@%zu.%06zu:qemu_rdma_unregister_waiting_proc Processing unregister for chunk: %lu at position %d
qemu_rdma_unregister_waiting_proc Processing unregister for chunk: %lu at position %d
%d@%zu.%06zu:qemu_rdma_unregister_waiting_inflight Cannot unregister inflight chunk: %lu
qemu_rdma_unregister_waiting_inflight Cannot unregister inflight chunk: %lu
%d@%zu.%06zu:qemu_rdma_unregister_waiting_send Sending unregister for chunk: %lu
qemu_rdma_unregister_waiting_send Sending unregister for chunk: %lu
unregistration chunk failed: %s
%d@%zu.%06zu:qemu_rdma_unregister_waiting_complete Unregister for chunk: %lu complete.
qemu_rdma_unregister_waiting_complete Unregister for chunk: %lu complete.
%d@%zu.%06zu:rdma_registration_stop_ram 
ram blocks mismatch (Number of blocks %d vs %d)
Your QEMU command line parameters are probably not identical on both the source and destination.
Block %s/%d has a different length %luvs %lu
%d@%zu.%06zu:rdma_registration_stop %lu
%d@%zu.%06zu:rdma_start_incoming_migration 
rdma_start_incoming_migration 
RDMA: cannot disable RAM discard
RDMA ERROR: RDMA host is not set!
RDMA ERROR: could not create rdma event channel
RDMA ERROR: could not create cm_id!
RDMA ERROR: Error: could not set REUSEADDR option
%d@%zu.%06zu:qemu_rdma_dest_init_trying %s => %s
qemu_rdma_dest_init_trying %s => %s
RDMA ERROR: Error: could not rdma_bind_addr!
%d@%zu.%06zu:rdma_start_incoming_migration_after_dest_init 
rdma_start_incoming_migration_after_dest_init 
RDMA ERROR: listening on socket!
%d@%zu.%06zu:rdma_start_incoming_migration_after_rdma_listen 
rdma_start_incoming_migration_after_rdma_listen 
%d@%zu.%06zu:rdma_start_outgoing_migration_after_rdma_source_init 
rdma_start_outgoing_migration_after_rdma_source_init 
%d@%zu.%06zu:rdma_start_outgoing_migration_after_rdma_connect 
rdma_start_outgoing_migration_after_rdma_connect 
multifd %u: decompressStream buffer too small
multifd %u: decompressStream returned %s
multifd %u: zstd createDStream failed
multifd %u: initDStream failed with error %s
multifd %u: compressStream buffer too small
multifd %u: compressStream error %s
multifd %u: zstd createCStream failed
multifd %u: initCStream failed with error %s
No file descriptor supplied via SCM_RIGHTS
a name not starting with a digit
File descriptor named '%s' not found
File descriptor named '%s' has not been found
Failed to read file status flags for fd=%d
Failed to find file descriptor with matching flags=0x%x
Failed to dup() given file descriptor fd=%d
Failed to find fdset /dev/fdset/%ld
Invalid file descriptor number '%s'
invalid parameter '%s', expecting 'on', 'off', or 'reset'
Could not open gdbserver on device '%s'
Waiting for gdb connection on device '%s'
boot device list now set to %s
QEMU %s monitor - type 'help' for more information
unsupported escape code: '\%c'
missing terminating ' character
invalid char '%c' in expression
%s: block device name expected
%s: extraneous characters at the end of line
Command '%.*s' not available until machine initialization has completed.
terminal does not support password prompting
trace:PATTERN   enable trace events
Use "log trace:help" to get a list of trace events.
%d@%zu.%06zu:handle_hmp_command mon %p cmdline: %s
handle_hmp_command mon %p cmdline: %s
Command "%.*s" is not available.
Try "help %.*s" for more information
Resetting the Virtual Machine is required
Migration is not finalized yet
parameter @fdname must name a socket
%d@%zu.%06zu:qemu_announce_self_iter %s:%s:%s skip: %d
qemu_announce_self_iter %s:%s:%s skip: %d
%d@%zu.%06zu:qemu_announce_timer_del free named: %d free timer: %d id: %s
qemu_announce_timer_del free named: %d free timer: %d id: %s
/home/virus/AMD/AMD/include/net/filter.h
network dump write error - stopping dump
dump filter needs 'file' property set!
%s: probably not GSO frame, unknown L3 protocol: 0x%04x
bytes_read == sizeof(*dst_addr)
padded_buflen && *padded_buflen >= ETH_ZLEN
Property '%s.%s' requires a positive value
filter redirector needs 'indev' or 'outdev' at least one property set
'indev' and 'outdev' could not be same for filter redirector
filter mirror needs 'outdev' property set
filter-mirror parameter 'outdev' cannot be empty
filter redirector send failed(%s)
Invalid value for netfilter insert, should be 'before' or 'behind'
Invalid value for netfilter status, should be 'on' or 'off'
Parameter 'netdev' is required
filter '%s' belongs to a different netdev
netdev->type == NET_CLIENT_DRIVER_HUBPORT
hub %d is not connected to host network
network backend '%s' is not compiled into this binary
network backend '%s' is only supported with -netdev/-nic
Device '%s' could not be initialized
parameter 'ipv6-net' expects a number after '/'
host address '%s' is not a valid IPv4 address
can't resolve host address '%s'
host address '%s' doesn't contain ':' separating host from port
model=%s,macaddr=%02x:%02x:%02x:%02x:%02x:%02x
netdev->type == NET_CLIENT_DRIVER_NIC
invalid syntax for ethernet address
NIC cannot have multicast MAC address (odd 1st byte)
info->size >= sizeof(NetClientState)
info->type == NET_CLIENT_DRIVER_NIC
info->size >= sizeof(NICState)
len == sizeof(struct virtio_net_hdr_mrg_rxbuf) || len == sizeof(struct virtio_net_hdr) || len == sizeof(struct virtio_net_hdr_v1_hash)
nc->info->type != NET_CLIENT_DRIVER_NIC
Available netdev backend types:
Available NIC models (use -nic model=help for a filtered list):
no more on-board/default NIC slots available
NIC cannot have multicast MAC address
net client(%s) doesn't support rx-filter querying
Available NIC models for this configuration:
requested NIC (%s, model %s) was not created (not supported by this machine?)
serious error: oversized packet received,connection terminated.
specified mcastaddr %s (0x%08x) does not contain a multicast address
can't set socket option SO_REUSEADDR
can't add socket to multicast group %s
can't force multicast message to loopback
can't set the default network send interface
can't setup multicast destination address
socket: fd=%d (cloned mcast=%s:%d)
netdev->type == NET_CLIENT_DRIVER_SOCKET
exactly one of listen=, connect=, mcast= or udp= is required
localaddr= is only valid with mcast= or udp=
can't get socket option SO_TYPE
socket type=%d for fd=%d must be either SOCK_DGRAM or SOCK_STREAM
%s: Can't use file descriptor %d
localaddr '%s' is not a valid IPv4 address
localaddr= is mandatory with udp=
can't use file descriptor %s (errno %d)
netdev->type == NET_CLIENT_DRIVER_STREAM
'reconnect' and 'reconnect-ms' are mutually exclusive
'reconnect' and 'reconnect-ms' options are incompatible with socket in server mode
netdev->type == NET_CLIENT_DRIVER_DGRAM
multicast only support inet type
only support inet or fd type for local
dgram requires local= parameter
don't set remote with local.fd
remote and local types must be the same
type=inet or type=unix requires remote parameter
UNIX socket path '%s' is too long
Path must be less than %zu bytes
%d@%zu.%06zu:colo_compare_ip_info ppkt size = %d, ip_src = %s, ip_dst = %s, spkt size = %d, ip_src = %s, ip_dst = %s
colo_compare_ip_info ppkt size = %d, ip_src = %s, ip_dst = %s, spkt size = %d, ip_src = %s, ip_dst = %s
chardev "%s" is not reconnectable
chardev "%s" cannot switch context
%d@%zu.%06zu:colo_old_packet_check_found %ld
colo_old_packet_check_found %ld
queue size too big, drop packet
%d@%zu.%06zu:colo_compare_drop_packet : %s: %s
colo_compare_drop_packet : %s: %s
Notify Xen COLO-frame INIT failed
COLO compare got unsupported instruction
colo-compare secondary_in error
colo compare needs 'primary_in' ,'secondary_in','outdev','iothread' property set
'indev' and 'outdev' could not be same for compare module
colo send primary packet failed
packet same and release packet
%d@%zu.%06zu:colo_compare_main : %s
UDP: payload size of packets are different
%d@%zu.%06zu:colo_compare_udp_miscompare : %s = %d
colo_compare_udp_miscompare : %s = %d
%d@%zu.%06zu:colo_compare_tcp_info %s: seq/ack= %u/%u hdlen= %d pdlen= %d offset= %d flags=%d
colo_compare_tcp_info %s: seq/ack= %u/%u hdlen= %d pdlen= %d offset= %d flags=%d
secondary: unsupported packet in
primary: unsupported packet in
Other: payload size of packets are different
ICMP: payload size of packets are different
%d@%zu.%06zu:colo_compare_icmp_miscompare : %s = %d
colo_compare_icmp_miscompare : %s = %d
This received packet load wrong 
%d@%zu.%06zu:colo_proxy_main_vnet_info : %s pkt->vnet_hdr_len = %u, pkt->size = %d
colo_proxy_main_vnet_info : %s pkt->vnet_hdr_len = %u, pkt->size = %d
%d@%zu.%06zu:colo_proxy_main : %s
pkt->size < network_header + network_length
colo proxy connection hashtable full, clear it
%d@%zu.%06zu:colo_filter_rewriter_pkt_info %s: src/dst: %s/%s p: seq/ack=%u/%u  flags=0x%x
colo_filter_rewriter_pkt_info %s: src/dst: %s/%s p: seq/ack=%u/%u  flags=0x%x
%d@%zu.%06zu:colo_filter_rewriter_conn_offset : offset=%u
colo_filter_rewriter_conn_offset : offset=%u
l2tpv3 header verification failed
iovec too long %d > %d, change l2tpv3.h
netdev->type == NET_CLIENT_DRIVER_L2TPV3
offset must be less than 256 bytes
require both 'rxcookie' and 'txcookie' or neither
need both src and dst port for udp
could not resolve src, errno = %s
socket creation failed, errno = %d
could not resolve dst, error = %s
user mode network stack not in use
Could not set up host forwarding rule '%s'
Invalid host forwarding rule '%s' (%s)
IPv4 disabled but netmask/host/dns provided
IPv6 disabled but prefix/host6/dns6 provided
Failed to parse netmask (trailing chars)
Invalid netmask provided (must be in range 4-32)
Host doesn't belong to network
DNS must be different from host
Failed to parse DHCP start address
DHCP doesn't belong to network
DHCP must be different from host and DNS
Invalid IPv6 prefix provided (IPv6 prefix length must be between 0 and 126)
IPv6 Host doesn't belong to network
IPv6 DNS doesn't belong to network
'domainname' parameter cannot be empty
'domainname' parameter cannot exceed 255 bytes
'vhostname' parameter cannot exceed 255 bytes
'tftp-server-name' parameter cannot exceed 255 bytes
Conflicting/invalid host:port in guest forwarding rule '%s'
Could not open guest forwarding device '%s'
Invalid guest forwarding rule '%s'
Could not find '%s', please install it
Error accessing shared directory '%s': %s
Could not create samba server dir
Could not create samba server configuration file '%s'
[global]
private dir=%s
interfaces=127.0.0.1
bind interfaces only=yes
pid directory=%s
lock directory=%s
state directory=%s
cache directory=%s
ncalrpc dir=%s/ncalrpc
log file=%s/log.smbd
smb passwd file=%s/smbpasswd
security = user
map to guest = Bad User
load printers = no
printing = bsd
disable spoolss = yes
usershare max shares = 0
[qemu]
path=%s
read only=no
guest ok=yes
force user=%s
Conflicting/invalid smbserver address
host forwarding rule for %s %s
netdev->type == NET_CLIENT_DRIVER_USER
vhost-user requires frontend driver virtio-net-*
Vhost user backend fails to broadcast fake RARP
nc->info->type == NET_CLIENT_DRIVER_VHOST_USER
%d@%zu.%06zu:vhost_user_event chr: %s got event: %d
vhost_user_event chr: %s got event: %d
ncs[i]->info->type == NET_CLIENT_DRIVER_VHOST_USER
failed to init vhost_net for queue %d
netdev->type == NET_CLIENT_DRIVER_VHOST_USER
chardev "%s" does not support FD passing
vhost-user number of queues must be in range [1, %d]
could not launch network script %s
network script %s failed with status %d
/usr/libexec/qemu-bridge-helper
failed to recv file descriptor
nc->info->type == NET_CLIENT_DRIVER_TAP
ifname=%s,script=%s,downscript=%s
tap: open vhost char device failed
vhost-net requested but could not be initialized
vhostfd(s)= is not valid without vhost
netdev->type == NET_CLIENT_DRIVER_BRIDGE
netdev->type == NET_CLIENT_DRIVER_TAP
Multiqueue tap cannot be used with hubs
ifname=, script=, downscript=, vnet_hdr=, helper=, queues=, fds=, and vhostfds= are invalid with fd=
ifname=, script=, downscript=, vnet_hdr=, helper=, queues=, and vhostfd= are invalid with fds=
The number of fds passed does not match the number of vhostfds passed
vnet_hdr not consistent across given tap fds
ifname=, script=, downscript=, vnet_hdr=, queues=, and vhostfds= are invalid with helper=
vhostfds= is invalid if fds= wasn't specified
vnet_hdr=1 requested, but no kernel support for IFF_VNET_HDR available
multiqueue required, but no kernel support for IFF_MULTI_QUEUE available
Unable to query TUNGETIFF on FD %d
TUNSETVNETHDRSZ ioctl() failed: %s. Exiting.
TUNSETVNETLE ioctl() failed: %s.
TUNSETVNETBE ioctl() failed: %s.
TUNSETOFFLOAD ioctl() failed: %s
Issue while setting TUNSETSTEERINGEBPF: %s with fd: %d, prog_fd: %d
vhost-vdpa requires frontend driver virtio-net-*
nc->info->type == NET_CLIENT_DRIVER_VHOST_VDPA
unable to start vhost net: %s(%d)
data_size < vhost_vdpa_net_cvq_cmd_page_len() - sizeof(ctrl)
%d@%zu.%06zu:vhost_vdpa_net_load_cmd vdpa state: %p class: %u cmd: %u sg_num: %d size: %d
vhost_vdpa_net_load_cmd vdpa state: %p class: %u cmd: %u sg_num: %d size: %d
%d@%zu.%06zu:vhost_vdpa_net_load_cmd_retval vdpa state: %p class: %u cmd: %u retval: %d
vhost_vdpa_net_load_cmd_retval vdpa state: %p class: %u cmd: %u retval: %d
fake_cvq_size < vhost_vdpa_net_cvq_cmd_page_len()
Insufficient written data (%zu)
vdpa svq does not work with features 0x%lx
%d@%zu.%06zu:vhost_vdpa_set_address_space_id vhost_vdpa: %p vq_group: %u asid: %u
vhost_vdpa_set_address_space_id vhost_vdpa: %p vq_group: %u asid: %u
Can't set vq group %u asid %u, errno=%d (%s)
Cannot get vdpa backend_features
ncs->info->type == NET_CLIENT_DRIVER_VHOST_VDPA
failed to init vhost_net for queue
%d@%zu.%06zu:vhost_vdpa_net_load_mq vdpa state: %p current_qpairs: %d
vhost_vdpa_net_load_mq vdpa state: %p current_qpairs: %d
netdev->type == NET_CLIENT_DRIVER_VHOST_VDPA
vhost-vdpa: neither vhostdev= nor vhostfd= was specified
vhost-vdpa: vhostdev= and vhostfd= are mutually exclusive
vhost-vdpa: unable to parse vhostfd: 
Fail to query features from vhost-vDPA device
Fail to get config from vhost-vDPA device
vhost-vdpa: get iova range failed: %s
/home/virus/AMD/AMD/include/net/can_host.h
failed to create CAN_RAW socket
SocketCAN host interface %s not available
SocketCAN host interface %s SIOCGIFMTU failed
SocketCAN host interface %s enabling CAN FD failed
failed to bind to host interface %s
[cansocketcan]: write message to host returns zero
[cansocketcan]: write to host failed (%s)
[cansocketcan]: write to host truncated
CAN interface name longer than %zd characters
CAN interface already connected
replay_state.data_kind == EVENT_INSTRUCTION
replay_break_icount >= current
EVENT_CHECKPOINT + checkpoint <= EVENT_CHECKPOINT_LAST
SHUTDOWN_CAUSE_SUBSYSTEM_RESET
SHUTDOWN_CAUSE_HOST_QMP_SYSTEM_RESET
%s (insn total %ld/%d left, event %d is %s)
File name not specified for replay
Replay: invalid input log file version
Please enable icount to use record/replay
Record/replay is not supported with %s
replay file is over or something goes wrong
Replay: invalid async event ID (%d) in the queue
event_kind < REPLAY_ASYNC_COUNT
event->event_kind < REPLAY_ASYNC_COUNT
Unknown ID %ld of replay event
replay_file && replay_mutex_locked()
Replay: cannot find char driver
Missing character write event in the replay log
Missing character read all event in the replay log
Could not create snapshot for icount record
Could not load snapshot for icount replay
event->id < network_filters_count
Missing audio out event in the replay log
Missing audio in event in the replay log
Missing random event in the replay log
replay_mode == REPLAY_MODE_PLAY
replay_break_icount >= replay_get_current_icount()
replay must be enabled to seek
cannot seek to the specified instruction count
%s execution '%s': instruction count = %ld
cannot set breakpoint at the instruction in the past
setting the breakpoint is allowed only in play mode
replay breakpoints are allowed only in play mode
failed to find schema list for %s
failed to find schema entry for %s
fatal: could not load module for type '%s'
/home/virus/AMD/AMD/include/system/accel-ops.h
icount sleep disabled and no active timers
Please specify shift option when using align
align=on and sleep=off are incompatible
shift=auto and align=on are incompatible
shift=auto and sleep=off are incompatible
JIT information is only available with accel=tcg
TB avg target size  %zu max=%zu bytes
TB avg host size    %zu bytes (expansion ratio: %0.1f)
cross page TB count %zu (%zu%%)
direct jump count   %zu (%zu%%) (2 jumps=%zu %zu%%)
TB hash buckets     %zu/%zu (%0.2f%% head buckets used)
TB hash occupancy   %0.2f%% avg chain occ. Histogram: %s
TB hash avg chain   %0.3f buckets. Histogram: %s
Opcode count information is only available with accel=tcg
../accel/tcg/tcg-accel-ops-icount.c
cpu->neg.icount_decr.u16.low == 0
Raised interrupt while not in I/O function
../accel/tcg/tcg-accel-ops-mttcg.c
../accel/tcg/tcg-accel-ops-rr.c
invalid use of qemu_plugin_get_hwaddr
TCG plugin time control does not support migration
Could not convert 0x%04x from UCS-2 to a multibyte character: %s
Could not convert 0x%04x from a multibyte character to wchar_t: %s
Could not convert font glyphs from UCS-2: '%s'
Could not convert font glyphs to UCS-2: '%s'
Could not convert font glyphs from %s: '%s'
Could not convert font glyph 0x%02x from %s to a multibyte character: %s
Could not convert font glyph 0x%02x from a multibyte character to wchar_t: %s
Could not convert 0x%04lx from wchar_t to a multibyte character: %s
Could not convert 0x%04lx from a multibyte character to UCS-2 : %s
QEMU_IS_ALIGNED(surface_stride(surface), surface_bytes_per_pixel(surface))
egl: eglBindAPI failed (%s mode): %s
egl: eglChooseConfig failed (%s mode): %s
surface_width(dst) == src->width
surface_height(dst) == src->height
surface_format(dst) == PIXMAN_x8r8g8b8
egl: eglCreateWindowSurface failed
egl: turning off GL doesn't make sense
egl: not available on this platform
egl: eglMakeCurrent failed: %s
surface_format(edpy->ds) == PIXMAN_x8r8g8b8
swapped-signal::handle-send-break
swapped-signal::handle-register
%d@%zu.%06zu:dbus_clipboard_qemu_request type=%d
dbus_clipboard_qemu_request type=%d
Failed to request clipboard: %s
Clipboard peer already registered!
%d@%zu.%06zu:dbus_clipboard_register peer %s
dbus_clipboard_register peer %s
swapped-signal::notify::g-name-owner
%d@%zu.%06zu:dbus_clipboard_unregister peer %s
dbus_clipboard_unregister peer %s
Invalid clipboard selection: %d
Unhandled MIME types requested
%d@%zu.%06zu:dbus_clipboard_grab selection=%d serial=%u
dbus_clipboard_grab selection=%d serial=%u
%d@%zu.%06zu:dbus_clipboard_grab_failed 
swapped-signal::handle-unregister
swapped-signal::handle-request
swapped-signal::handle-release
%d@%zu.%06zu:dbus_touch_send_event kind=%u, num_slot=%u, x=%d, y=%d
dbus_touch_send_event kind=%u, num_slot=%u, x=%d, y=%d
%d@%zu.%06zu:dbus_mouse_release button %u
%d@%zu.%06zu:dbus_mouse_press button %u
%d@%zu.%06zu:dbus_kbd_release keycode %u
%d@%zu.%06zu:dbus_kbd_press keycode %u
%d@%zu.%06zu:dbus_listener_vanished peer %s
dbus_listener_vanished peer %s
Failed to setup peer connection: %s
%d@%zu.%06zu:dbus_registered_listener peer %s
dbus_registered_listener peer %s
%d@%zu.%06zu:dbus_mouse_rel_motion dx=%d, dy=%d
dbus_mouse_rel_motion dx=%d, dy=%d
%d@%zu.%06zu:dbus_mouse_set_pos x=%u, y=%u
dbus_mouse_set_pos x=%u, y=%u
swapped-signal::handle-set-uiinfo
swapped-signal::handle-register-listener
swapped-signal::handle-rel-motion
swapped-signal::handle-set-abs-position
swapped-signal::handle-send-event
org.qemu.Display1.Error.Failed
org.qemu.Display1.Error.Invalid
org.qemu.Display1.Error.Unsupported
%d@%zu.%06zu:dbus_update_gl x=%d, y=%d, w=%d, h=%d
dbus_update_gl x=%d, y=%d, w=%d, h=%d
%d@%zu.%06zu:dbus_gl_gfx_switch surf: %p
%d@%zu.%06zu:dbus_scanout_texture tex_id:%u y0top:%d back:%ux%u %u+%u-%ux%u
dbus_scanout_texture tex_id:%u y0top:%d back:%ux%u %u+%u-%ux%u
%d@%zu.%06zu:dbus_update x=%d, y=%d, w=%d, h=%d
dbus_update x=%d, y=%d, w=%d, h=%d
Failed to setup scanout map fdlist: %s
%d@%zu.%06zu:dbus_filter serial=%u (<= %u)
dbus_filter serial=%u (<= %u)
org.qemu.Display1.Listener.Unix.Map
Display listener does not implement: `%s`
Failed to setup Unix map proxy: %s
%d@%zu.%06zu:dbus_can_share_map can_share_map: %d
dbus_can_share_map can_share_map: %d
dbus: can't accept both addr=X and p2p=yes options
p2p connections not accepted in bus mode
Failed to setup D-Bus socket: %s
Failed to accept D-Bus client: %s
Audiodev '%s' is not compatible with DBus
gtk: unexpected touch event type
%d@%zu.%06zu:gd_key_event tab=%s, translated GDK keycode %d to QKeyCode %d (%s)
gd_key_event tab=%s, translated GDK keycode %d to QKeyCode %d (%s)
%d@%zu.%06zu:gd_motion_event ww=%d, wh=%d, ws=%d, x=%d, y=%d
gd_motion_event ww=%d, wh=%d, ws=%d, x=%d, y=%d
 - Press Ctrl+Alt+G to release grab
%d@%zu.%06zu:gd_update tab=%s, x=%d, y=%d, w=%d, h=%d
gd_update tab=%s, x=%d, y=%d, w=%d, h=%d
GtkGLArea console lacks DMABUF support.
Maximum number of consoles reached
opts->type == DISPLAY_TYPE_GTK
%d@%zu.%06zu:gd_ungrab tab=%s, dev=%s
%d@%zu.%06zu:gd_grab tab=%s, dev=%s, reason=%s
gd_grab tab=%s, dev=%s, reason=%s
%d@%zu.%06zu:gd_keymap_windowing backend=%s
gd_keymap_windowing backend=%s
Unsupported GDK Windowing platform.
Disabling extended keycode tables.
Please report to qemu-devel@nongnu.org
including the following information:
  - Operating system
  - GDK Windowing system build
experimental: using broadway, x11 virtual keysym
mapping - with very limited support. See also
https://bugzilla.gnome.org/show_bug.cgi?id=700105
%d@%zu.%06zu:gd_switch tab=%s, width=%d, height=%d
gd_switch tab=%s, width=%d, height=%d
%d@%zu.%06zu:xkeymap_keycodes keycodes '%s'
xkeymap_keycodes keycodes '%s'
%d@%zu.%06zu:xkeymap_vendor vendor '%s'
%d@%zu.%06zu:xkeymap_keymap keymap '%s'
%d@%zu.%06zu:xkeymap_extension extension '%s'
xkeymap_extension extension '%s'
Unknown X11 keycode mapping '%s'.
Please report to qemu-devel@nongnu.org
including the following information:
  - Operating system
  - X11 Server
  - xprop -root
  - xdpyinfo
Create gdk gl context failed: %s
Realize gdk gl context failed: %s
%d@%zu.%06zu:gd_gl_area_create_context ctx=%p, major=%d, minor=%d
gd_gl_area_create_context ctx=%p, major=%d, minor=%d
%d@%zu.%06zu:gd_gl_area_destroy_context ctx=%p, current_ctx=%p
gd_gl_area_destroy_context ctx=%p, current_ctx=%p
%d@%zu.%06zu:sdl2_process_key translated SDL scancode %d to QKeyCode %d (%s)
sdl2_process_key translated SDL scancode %d to QKeyCode %d (%s)
Failed to make rgb surface from %p
Failed to make color cursor from %p
 - Press Ctrl-Alt-Shift-G to exit grab
 - Press Right-Ctrl-G to exit grab
 - Press Ctrl-Alt-G to exit grab
Could not initialize SDL(%s) - exiting
SDL_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR
SDL_ALLOW_ALT_TAB_WHILE_GRABBED
SDL_WINDOWS_NO_CLOSE_ON_ALT_F4
/usr/share/icons/hicolor/32x32/apps/qemu.bmp
Oops: spice configured but not active
spice: %s, extended address is expected
item->info->flags & SPICE_CHANNEL_EVENT_FLAG_ADDR_EXT
spice: tried to setup tls-channel without specifying a TLS port
spice: failed to set channel security for %s
spice tls-port is out of range
failed to initialize spice server
%d@%zu.%06zu:qemu_spice_create_update lr %d -> %d,  tb -> %d -> %d
qemu_spice_create_update lr %d -> %d,  tb -> %d -> %d
%d@%zu.%06zu:qemu_spice_ui_info %d %dx%d
%d@%zu.%06zu:qemu_spice_add_memslot %d %u: host virt 0x%lx - 0x%lx async=%d
qemu_spice_add_memslot %d %u: host virt 0x%lx - 0x%lx async=%d
%d@%zu.%06zu:qemu_spice_del_memslot %d gid=%u sid=%u
qemu_spice_del_memslot %d gid=%u sid=%u
%d@%zu.%06zu:qemu_spice_create_primary_surface %d sid=%u surface=%p async=%d
qemu_spice_create_primary_surface %d sid=%u surface=%p async=%d
%d@%zu.%06zu:qemu_spice_destroy_primary_surface %d sid=%u async=%d
qemu_spice_destroy_primary_surface %d sid=%u async=%d
%d@%zu.%06zu:qemu_spice_wakeup %d
%d@%zu.%06zu:qemu_spice_display_update %d +%d+%d %dx%d
qemu_spice_display_update %d +%d+%d %dx%d
%d@%zu.%06zu:qemu_spice_display_surface %d %dx%d, fast %d
qemu_spice_display_surface %d %dx%d, fast %d
%d@%zu.%06zu:qemu_spice_display_refresh %d notify %d
qemu_spice_display_refresh %d notify %d
Launching display with URI: %s
You need a capable Spice client, such as virt-viewer 8.0
spice-app full-screen isn't supported yet.
spice-app window-close isn't supported yet.
Failed to create directory %s: %s
Failed to create temporary directory: %s
spice-app missing spice support
%d@%zu.%06zu:qxl_interface_get_init_info %d
qxl_interface_get_init_info %d
%d@%zu.%06zu:qxl_interface_attach_worker %d
qxl_interface_attach_worker %d
%d@%zu.%06zu:qxl_io_read_unexpected %d
%d@%zu.%06zu:qxl_spice_destroy_surface_wait_complete %d sid=%d
qxl_spice_destroy_surface_wait_complete %d sid=%d
%d@%zu.%06zu:qxl_spice_destroy_surfaces_complete %d
qxl_spice_destroy_surfaces_complete %d
%d@%zu.%06zu:qxl_send_events %d %d
%s: spice-server bug: guest stopped, ignoring
%d@%zu.%06zu:qxl_send_events_vm_stopped %d %d
qxl_send_events_vm_stopped %d %d
%d@%zu.%06zu:qxl_set_client_capabilities_unsupported_by_revision %d revision=%d
qxl_set_client_capabilities_unsupported_by_revision %d revision=%d
%d@%zu.%06zu:qxl_interface_async_complete_io %d current=%d cookie=%p
qxl_interface_async_complete_io %d current=%d cookie=%p
qxl: %s: error: current_async = %d != %ld = cookie->io
qxl: %s: unexpected current_async %u
qxl: %s: unexpected cookie type %d
!spice_display_running || SPICE_RING_IS_EMPTY(&ram->cmd_ring)
!spice_display_running || SPICE_RING_IS_EMPTY(&ram->cursor_ring)
%d@%zu.%06zu:qxl_interface_set_compression_level %d %ld
qxl_interface_set_compression_level %d %ld
qxl->rom->compression_level == cpu_to_le32(level)
%d@%zu.%06zu:qxl_enter_vga_mode %d
%d@%zu.%06zu:qxl_soft_reset %d
%d@%zu.%06zu:qxl_client_monitors_config_unsupported_by_device %d revision=%d
qxl_client_monitors_config_unsupported_by_device %d revision=%d
%d@%zu.%06zu:qxl_client_monitors_config_unsupported_by_guest %d 0x%X %p
qxl_client_monitors_config_unsupported_by_guest %d 0x%X %p
%d@%zu.%06zu:qxl_client_monitors_config_capped %d %d %d
qxl_client_monitors_config_capped %d %d %d
%d@%zu.%06zu:qxl_client_monitors_config_crc %d %u %u
qxl_client_monitors_config_crc %d %u %u
%d@%zu.%06zu:qxl_interrupt_client_monitors_config %d %d %p
qxl_interrupt_client_monitors_config %d %d %p
Spice QXL GPU (primary, vga compatible)
prod < ARRAY_SIZE(ring->items)
%d@%zu.%06zu:qxl_interface_update_area_complete %d surface=%d [%d,%d,%d,%d]
qxl_interface_update_area_complete %d surface=%d [%d,%d,%d,%d]
%d@%zu.%06zu:qxl_interface_update_area_complete_rest %d #=%d
qxl_interface_update_area_complete_rest %d #=%d
%d@%zu.%06zu:qxl_interface_update_area_complete_overflow %d max=%d
qxl_interface_update_area_complete_overflow %d max=%d
%d@%zu.%06zu:qxl_interface_update_area_complete_schedule_bh %d #dirty=%d
qxl_interface_update_area_complete_schedule_bh %d #dirty=%d
%d@%zu.%06zu:qxl_ring_cursor_req_notification %d
qxl_ring_cursor_req_notification %d
%d@%zu.%06zu:qxl_ring_command_req_notification %d
qxl_ring_command_req_notification %d
ram_header_size + surface0_area_size <= d->vga.vram_size
Invalid revision %d for qxl device (max %d)
qxl interface %d.%d not supported by spice-server
primary qxl-vga device must be console 0 (first display device on the command line)
%d@%zu.%06zu:qxl_set_guest_bug %d
slot %d offset %lu < delta %lu
slot %d offset %lu > size %lu
slot %d offset %lu > region size %lu
slot %d offset %lu size %zu: overrun by %lu bytes
%d@%zu.%06zu:qxl_surfaces_dirty %d offset=0x%lx size=0x%lx
qxl_surfaces_dirty %d offset=0x%lx size=0x%lx
%d@%zu.%06zu:qxl_ring_res_push %d %s s#=%d res#=%d last=%p notify=%s
qxl_ring_res_push %d %s s#=%d res#=%d last=%p notify=%s
%d@%zu.%06zu:qxl_ring_res_push_rest %d ring %d/%d [%d,%d]
qxl_ring_res_push_rest %d ring %d/%d [%d,%d]
SPICE_RING_PROD_ITEM indices mismatch %u >= %zu
cmdext->cmd.type == QXL_CMD_DRAW
%d@%zu.%06zu:qxl_ring_res_put %d #res=%d
%d@%zu.%06zu:qxl_memslot_add_guest %d %u: guest phys 0x%lx - 0x%lx
qxl_memslot_add_guest %d %u: guest phys 0x%lx - 0x%lx
%s: guest_start > guest_end 0x%lx > 0x%lx
guest_end - pci_start <= memory_region_size(mr)
%s: finished loop without match
%d@%zu.%06zu:qxl_spice_update_area %d sid=%d [%d,%d,%d,%d]
qxl_spice_update_area %d sid=%d [%d,%d,%d,%d]
%d@%zu.%06zu:qxl_spice_update_area_rest %d #d=%d clear=%d
qxl_spice_update_area_rest %d #d=%d clear=%d
%d@%zu.%06zu:qxl_spice_loadvm_commands %d ext=%p count=%d
qxl_spice_loadvm_commands %d ext=%p count=%d
%d@%zu.%06zu:qxl_spice_oom %d
%d@%zu.%06zu:qxl_spice_reset_memslots %d
%d@%zu.%06zu:qxl_spice_reset_image_cache %d
qxl_spice_reset_image_cache %d
%d@%zu.%06zu:qxl_spice_reset_cursor %d
%d@%zu.%06zu:qxl_hard_reset %d loadvm=%ld
%d@%zu.%06zu:qxl_reset_surfaces %d
%d@%zu.%06zu:qxl_spice_destroy_surfaces %d async=%d
qxl_spice_destroy_surfaces %d async=%d
%d@%zu.%06zu:qxl_destroy_primary %d
%d@%zu.%06zu:qxl_exit_vga_mode %d
%s: requested primary larger than framebuffer stride %d x height %u > %u
%s: nop since already in QXL_MODE_NATIVE
%d@%zu.%06zu:qxl_create_guest_primary %d %ux%u mem=0x%lx %u,%u
qxl_create_guest_primary %d %ux%u mem=0x%lx %u,%u
%d@%zu.%06zu:qxl_create_guest_primary_rest %d %d,%d,%d
qxl_create_guest_primary_rest %d %d,%d,%d
primary surface stride = %d %% 4 != 0
%d@%zu.%06zu:qxl_set_mode %d mode=%d [ x=%d y=%d @ bpp=%d devmem=0x%lx ]
qxl_set_mode %d mode=%d [ x=%d y=%d @ bpp=%d devmem=0x%lx ]
cmd->type == QXL_SURFACE_CMD_CREATE
%d@%zu.%06zu:qxl_spice_monitors_config %d
unsupported io %d for revision %d
%d@%zu.%06zu:qxl_io_unexpected_vga_mode %d 0x%lx=%lu (%s)
qxl_io_unexpected_vga_mode %d 0x%lx=%lu (%s)
%d async started before last (%d) complete
%d@%zu.%06zu:qxl_io_write %d %s addr=%lu (%s) val=%lu size=%u async=%d
qxl_io_write %d %s addr=%lu (%s) val=%lu size=%u async=%d
QXL_IO_UPDATE_AREA: invalid surface id %d
QXL_IO_UPDATE_AREA: invalid area (%ux%u)x(%ux%u)
%d@%zu.%06zu:qxl_io_log %d %s
QXL_IO_MEMSLOT_ADD: val out of range
QXL_IO_MEMSLOT_ADD: memory slot already active
QXL_IO_MEMSLOT_DEL: val out of range
QXL_IO_CREATE_PRIMARY (async=%d): val != 0
QXL_IO_DESTROY_PRIMARY (async=%d): val != 0
%d@%zu.%06zu:qxl_io_destroy_primary_ignored %d %s
qxl_io_destroy_primary_ignored %d %s
QXL_IO_DESTROY_SURFACE (async=%d):%lu >= NUM_SURFACES
%d@%zu.%06zu:qxl_spice_destroy_surface_wait %d sid=%d async=%d
qxl_spice_destroy_surface_wait %d sid=%d async=%d
ERROR: no flush, full release ring [p%d,%dc]
%d@%zu.%06zu:qxl_spice_flush_surfaces_async %d s#=%d, res#=%d
qxl_spice_flush_surfaces_async %d s#=%d, res#=%d
d->last_release_offset < d->vga.vram_size
%d@%zu.%06zu:qxl_post_load %d %s
QXL_CMD_SURFACE stride = %d %% 4 != 0
%d@%zu.%06zu:qxl_ring_command_check %d %s
%d@%zu.%06zu:qxl_ring_command_get %d %s
SPICE_RING_CONS_ITEM indices mismatch %u >= %zu
%d@%zu.%06zu:qxl_ring_cursor_check %d %s
%d@%zu.%06zu:qxl_ring_cursor_get %d %s
QXL_IO_DESTROY_ALL_SURFACES_ASYNC
 (id %lx type %d flags %d width %d height %d
, fmt %d flags %d x %d y %d stride %d palette %lx data %lx
 +%d+%d visible %s, shape @ 0x%lx
 type %s size %dx%d hot-spot +%d+%d unique 0x%lx data-size %d
: surface_id %d type %s effect %s
 size %dx%d stride %d format %s (count %u, max %u)
%d@%zu.%06zu:qxl_render_guest_primary_resized %dx%d, stride %d, bpp %d, depth %d
qxl_render_guest_primary_resized %dx%d, stride %d, bpp %d, depth %d
%d@%zu.%06zu:qxl_render_blit stride=%d [%d, %d, %d, %d]
qxl_render_blit stride=%d [%d, %d, %d, %d]
%d@%zu.%06zu:qxl_render_update_area_done %p
qxl_render_update_area_done %p
%s: bad monochrome cursor %ux%u with size %u
%d@%zu.%06zu:virtio_gpu_features virgl %d
../hw/display/virtio-gpu-base.c
/home/virus/AMD/AMD/include/hw/virtio/virtio-gpu.h
%s: invalid resource specified %d
need rutabaga or udmabuf for blob resources
%s: %s resource_destroyfor resource_id = %u failed.
%d@%zu.%06zu:virtio_gpu_update_cursor scanout %d, x %d, y %d, %s, res 0x%x
virtio_gpu_update_cursor scanout %d, x %d, y %d, %s, res 0x%x
%s: cursor size incorrect %zu vs %zu
%s: response size incorrect %zu vs %zu
%d@%zu.%06zu:virtio_gpu_cmd_get_display_info 
virtio_gpu_cmd_get_display_info 
%s: command size incorrect %zu vs %zu
%d@%zu.%06zu:virtio_gpu_cmd_get_edid scanout %d
virtio_gpu_cmd_get_edid scanout %d
%s: illegal scanout %d bounds for resource %d, rect (%d,%d)+%d,%d, fb %d %d
%s: host couldn't handle guest format %d
%s: nr_entries is too big (%d > 16384)
%s: command data size incorrect %zu vs %zu
%s: failed to map MMIO memory for element %d
%d@%zu.%06zu:virtio_gpu_cmd_res_create_2d res 0x%x, fmt 0x%x, w %d, h %d
virtio_gpu_cmd_res_create_2d res 0x%x, fmt 0x%x, w %d, h %d
%s: resource id 0 is not allowed
%s: resource already exists %d
%s: resource creation failed %d %d %d
%d@%zu.%06zu:virtio_gpu_cmd_res_create_blob res 0x%x, size %ld
virtio_gpu_cmd_res_create_blob res 0x%x, size %ld
%d@%zu.%06zu:virtio_gpu_cmd_res_unref res 0x%x
virtio_gpu_cmd_res_unref res 0x%x
%s: illegal resource specified %d
%d@%zu.%06zu:virtio_gpu_cmd_res_flush res 0x%x, w %d, h %d, x %d, y %d
virtio_gpu_cmd_res_flush res 0x%x, w %d, h %d, x %d, y %d
%s: flush bounds outside scanouts bounds for flush %d: %d %d %d %d
%s: flush bounds outside resource bounds for resource %d: %d %d %d %d vs %d %d
%d@%zu.%06zu:virtio_gpu_cmd_res_xfer_toh_2d res 0x%x
virtio_gpu_cmd_res_xfer_toh_2d res 0x%x
%s: transfer bounds outside resource bounds for resource %d: %d %d %d %d vs %d %d
%d@%zu.%06zu:virtio_gpu_cmd_set_scanout id %d, res 0x%x, w %d, h %d, x %d, y %d
virtio_gpu_cmd_set_scanout id %d, res 0x%x, w %d, h %d, x %d, y %d
%s: illegal scanout id specified %d
%d@%zu.%06zu:virtio_gpu_cmd_set_scanout_blob id %d, res 0x%x, w %d, h %d, x %d, y %d
virtio_gpu_cmd_set_scanout_blob id %d, res 0x%x, w %d, h %d, x %d, y %d
%d@%zu.%06zu:virtio_gpu_cmd_res_back_attach res 0x%x
virtio_gpu_cmd_res_back_attach res 0x%x
%d@%zu.%06zu:virtio_gpu_cmd_res_back_detach res 0x%x
virtio_gpu_cmd_res_back_detach res 0x%x
%d@%zu.%06zu:virtio_gpu_cmd_suspended cmd 0x%x
virtio_gpu_cmd_suspended cmd 0x%x
%d@%zu.%06zu:virtio_gpu_inc_inflight_fences in-flight+ %u
virtio_gpu_inc_inflight_fences in-flight+ %u
%d@%zu.%06zu:virtio_gpu_dec_inflight_fences in-flight- %u
virtio_gpu_dec_inflight_fences in-flight- %u
%d@%zu.%06zu:virtio_gpu_fence_resp fence 0x%lx
virtio_gpu_fence_resp fence 0x%lx
vhost-user-gpu: unhandled backend config change
EDID requested but the backend doesn't support it.
vhost-user-gpu: set device config space failed
../hw/display/vhost-user-gpu.c
Failed to set vhost-user-gpu socket
failed to read msg header: %d, %d
failed to read msg payload %d != %d
/home/virus/AMD/AMD/include/hw/virtio/virtio-gpu-pci.h
../hw/display/virtio-gpu-pci.c
../hw/display/vhost-user-gpu-pci.c
../hw/display/vhost-user-vga.c
%d@%zu.%06zu:uefi_reg_read addr 0x%lx, size %u
uefi_reg_read addr 0x%lx, size %u
%d@%zu.%06zu:uefi_event event %s
%d@%zu.%06zu:uefi_reg_write addr 0x%lx, val 0x%lx, size %d
uefi_reg_write addr 0x%lx, val 0x%lx, size %d
%d@%zu.%06zu:uefi_hard_reset 
%d@%zu.%06zu:uefi_vars_security_violation reason %s
uefi_vars_security_violation reason %s
%d@%zu.%06zu:uefi_vars_proto_cmd cmd %s
%s: AUTHENTICATED_WRITE_ACCESS
inconsistent authvar digest state
%d@%zu.%06zu:uefi_variable context %s, name %s, size %lu, uuid %s
uefi_variable context %s, name %s, size %lu, uuid %s
%d@%zu.%06zu:uefi_status context %s, status %s
uefi_status context %s, status %s
%d@%zu.%06zu:uefi_vars_policy_deny reason %s
uefi_vars_policy_deny reason %s
%d@%zu.%06zu:uefi_vars_policy_cmd cmd %s
../hw/uefi/var-service-sysbus.c
../hw/uefi/var-service-pkcs7.c
gnutls_x509_trust_list_init error: %s
gnutls_x509_crt_init error: %s
gnutls_x509_crt_import error: %s
gnutls_pkcs7_get_crt_raw2(0) error: %s
gnutls_pkcs7_get_crt_raw2(%d) error: %s
gnutls_x509_crt_get_dn_by_oid error #1: %s
gnutls_x509_crt_get_dn_by_oid error #2: %s
gnutls_x509_crt_get_fingerprint error: %s
../hw/uefi/var-service-siglist.c
../hw/usb/ccid-card-emulated.c
event->p.data.len <= MAX_ATR_SIZE
ccid-card-emul: %s: unexpected event
ccid-card-emul: %s: got back apdu of length %d
ccid-card-emul: %s: reader is NULL
ccid-card-emul: %s: unexpected message in handle_apdu_thread
ERROR: wrong reader: quitting event_thread
ccid-card-emul: %s: READER INSERT - replacing %s with %s
ccid-card-emul: %s: READER INSERT %s
ccid-card-emul: %s:  READER REMOVE: %s
ccid-card-emul: %s:  CARD INSERT
ccid-card-emul: %s:  CARD REMOVE
ccid-card-emul: event notifier creation failed
db="%s" use_hw=no soft=(,Virtual Reader,CAC,,%s,%s,%s)
%s: warning: not using certificates due to initialization error
%s: warning: running emulated with certificates and emulated side by side is not supported
%s: you must provide all three certs for certificates backend
%s: bad backend specified. The options are:%s (default), %s.
%s: unexpected cert parameters to nss emulated backend
%s: failed to initialize vcard
ccid-card-passthru: %s: CHR_EVENT_OPENED
../hw/usb/ccid-card-passthru.c
ccid-passthru: no chardev, discarding apdu length %u
ccid-card-passthru: ccid-card-passthru: initing chardev
no room for data: pos %u +  size %d > %ld. dropping connection.
card->vscard_in_pos < VSCARD_IN_SIZE
card->vscard_in_hdr < VSCARD_IN_SIZE
ccid-card-passthru: VSC_ATR %d
ATR size exceeds spec, ignoring
ccid-card-passthru: atr's T0 is 0x%X, not in {0x3b, 0x3f}
ccid-card-passthru: atr too short: len %d, but historical_len %d, T1 0x%X
ccid-card-passthru: atr too long: len %d, but hist/opt %d/%d, T1 0x%X
ccid-card-passthru: atr passes check: %d total length, %d historical, %d optional
ccid-card-passthru: VSC_CardRemove
ccid-card-passthru: got version %d, have %d
usb-ccid: chardev: unexpected message of type %X
usb-redir: bulk recv status %d ep %02X id %lu
usb-redir: bulk receiving stopped by peer ep %02X
usb-redir: interrupt recv status %d ep %02X id %lu
usb-redir: interrupt receiving stopped by peer ep %02X
usb-redir: iso status %d ep %02X id %lu
usb-redir: iso stream stopped by peer ep %02X
usb-redir: put_packet_id_q %s size %d
usb-redir: adding packet id %lu to %s queue
usb-redir: get_packet_id_q %s size %d
usb-redir: put_bufpq %d/%d len %d status %d
usbredir_get_bufpq: out of memory
usb-redir: get_bufpq %d/%d len %d status %d
usbredirparser_serialize failed
usb-redir: bufpq overflow, dropping packets ep %02X
usb-redir: iso-in status %d ep %02X len %d id %lu
usb-redir error: received iso packet for non iso endpoint %02X
usb-redir: received iso packet for non started stream ep %02X
usb-redir: removing packet id %lu from %s queue
usb-redir: removing %d packet-ids from %s queue
chardev_can_read called on non open chardev!
usb-redir: creating usbredirparser
usbredirparser_create() failed
usb-redir connection broken during migration
usb-redir: buffered-bulk-in status %d ep %02X len %d id %lu
usb-redir error: received buffered-bulk packet for non bulk ep %02X
usb-redir: received buffered-bulk packet on not started ep %02X
usb-redir: bulk-token-in ep %02X status %d len %d id %lu
usb-redir: interrupt-in status %d ep %02X len %d id %lu
usb-redir error: received int packet for non interrupt endpoint %02X
usb-redir: received int packet while not started ep %02X
interrupt output failed status %d ep %02X id %lu
usb-redir: usbredir_write recursion
usb-redir error: could not find packet with id %lu
got invalid param error from usb-host?
malformed ftdi bulk in packet
usb-redir: alt status %d intf %d alt %d id: %lu
usb-redir: set config status %d config %d id %lu
usb-redir: bulk-in status %d ep %02X stream %u len %d id %lu
usb-redir error: bulk got more data then requested (%d > %zd)
usb-redir: ctrl-in status %d len %d id %lu
usb-redir error: ctrl buffer too small (%d > %zu)
usb-redir: Removed remote wake %04X:%04X
usb-redir: destroying usbredirparser
dev->endpoint[i].pending_async_packet == p
usb-redir error: peer does not support streams
usb-redir error: request to allocate 0 streams
usb-redir error: streams are not available, disconnecting
usb-redir: bulk receiving stopped ep %02X
usb-redir: iso stream stopped ep %02X
usb-redir: interrupt recv stopped ep %02X
usb-redir: set config %d id %lu
usb-redir: set interface %d alt %d id %lu
usb-redir: get interface %d id %lu
usb-redir: ctrl-out type 0x%x req 0x%x val 0x%x index %d len %d id %lu
usb-redir error: handle_data called for control transfer on ep %02X
usb-redir: bulk receiving started bytes/transfer %u count %d ep %02X
usb-redir: bulk-token-in ep %02X, no bulkp
dev->endpoint[EP2I(ep)].pending_async_packet == NULL
bulk recv invalid size %zd ep %02x, disabling
usb-redir: bulk-out ep %02X stream %u len %zd id %lu
bulk_packet.length_high == 0 || usbredirparser_peer_has_cap(dev->parser, usb_redir_cap_32bits_bulk_length)
usb-redir: iso stream started pkts/sec %d pkts/urb %d urbs %d ep %02X
usb-redir: iso-token-in ep %02X, no isop, iso_error: %d
usb-redir: iso-token-in ep %02X status %d len %d queue-size: %d
usb-redir error: received iso data is larger then packet ep %02X (%d > %d)
usb-redir: iso-token-out ep %02X status %d len %zd
usb-redir: interrupt recv started ep %02X
usb-redir: interrupt-token-in ep %02X, no intp, buffered %d
usb-redir: interrupt-token-in ep %02X fragment status %d len %d
usb-redir error: received int data is larger then packet ep %02X
usb-redir: interrupt-token-in ep %02X summary status %d len %d
usb-redir: interrupt-out ep %02X len %zd id %lu
usb-redir error: handle_data ep %02X has unknown type %d
usb-redir: bulk streams status %d eps %08x
usb-redir error: bulk streams %s failed status %d eps %08x
usb-redir error: usb-redir-host does not provide streams, disconnecting
usb-redir error: usb-redir-host lacks capabilities needed for use with XHCI
rejecting device due to speed mismatch
usb-redir error: No interface info for device
usb-redir error: Device filter specified and peer does not have the connect_device_version capability
usb-redir error: Device no longer matches filter after interface info change, disconnecting!
usb-redir error: Received device connect while already connected
usb-redir: attaching %s device %04x:%04x version %d.%d class %02x
usb-redir: attaching %s device %04x:%04x class %02x
Device %04x:%04x rejected by device filter, not attaching
usb-redir error: Received 0 interval for isoc or irq endpoint
usb-redir: ep: %02X type: %d interface: %d
usb-redir error: Received invalid endpoint type
usb-redir error: Device no longer matches speed after endpoint info change, disconnecting!
%d@%zu.%06zu:usb_host_attach_kernel dev %d:%d, if %d
usb_host_attach_kernel dev %d:%d, if %d
%d@%zu.%06zu:usb_host_iso_stop dev %d:%d, ep %d
usb_host_iso_stop dev %d:%d, ep %d
  Bus %d, Addr %d, Port %s, Speed %s Mb/s
%d@%zu.%06zu:usb_host_reset dev %d:%d
%d@%zu.%06zu:usb_host_req_canceled dev %d:%d, packet %p
usb_host_req_canceled dev %d:%d, packet %p
%d@%zu.%06zu:usb_host_release_interface dev %d:%d, if %d
usb_host_release_interface dev %d:%d, if %d
%d@%zu.%06zu:usb_host_detach_kernel dev %d:%d, if %d
usb_host_detach_kernel dev %d:%d, if %d
%d@%zu.%06zu:usb_host_parse_config dev %d:%d, value %d, active %d
usb_host_parse_config dev %d:%d, value %d, active %d
alt < conf->interface[i].num_altsetting
%d@%zu.%06zu:usb_host_parse_interface dev %d:%d, num %d, alt %d, active %d
usb_host_parse_interface dev %d:%d, num %d, alt %d, active %d
%d@%zu.%06zu:usb_host_parse_error dev %d:%d, msg %s
usb_host_parse_error dev %d:%d, msg %s
%d@%zu.%06zu:usb_host_parse_endpoint dev %d:%d, ep %d, %s, %s, active %d
usb_host_parse_endpoint dev %d:%d, ep %d, %s, %s, active %d
%d@%zu.%06zu:usb_host_open_started dev %d:%d
usb_host_open_started dev %d:%d
%d@%zu.%06zu:usb_host_open_hostfd hostfd %d
usb_host_open_hostfd hostfd %d
%d@%zu.%06zu:usb_host_open_success dev %d:%d
usb_host_open_success dev %d:%d
%d@%zu.%06zu:usb_host_open_failure dev %d:%d
usb_host_open_failure dev %d:%d
libusb_alloc_streams: got less streams then requested %d < %d
%d@%zu.%06zu:usb_host_req_complete dev %d:%d, packet %p, status %d, length %d
usb_host_req_complete dev %d:%d, packet %p, status %d, length %d
%d@%zu.%06zu:usb_host_close dev %d:%d
%d@%zu.%06zu:usb_host_auto_scan_enabled 
failed to open host usb device %s
failed to find host usb device %d:%d
failed to open host usb device %d:%d
%d@%zu.%06zu:usb_host_remote_wakeup_removed dev %d:%d
usb_host_remote_wakeup_removed dev %d:%d
%d@%zu.%06zu:usb_host_req_control dev %d:%d, packet %p, req 0x%x, value %d, index %d
usb_host_req_control dev %d:%d, packet %p, req 0x%x, value %d, index %d
%d@%zu.%06zu:usb_host_req_emulated dev %d:%d, packet %p, status %d
usb_host_req_emulated dev %d:%d, packet %p, status %d
%d@%zu.%06zu:usb_host_set_address dev %d:%d, address %d
usb_host_set_address dev %d:%d, address %d
%d@%zu.%06zu:usb_host_set_config dev %d:%d, config %d
usb_host_set_config dev %d:%d, config %d
%d@%zu.%06zu:usb_host_claim_interface dev %d:%d, config %d, if %d
usb_host_claim_interface dev %d:%d, config %d, if %d
%d@%zu.%06zu:usb_host_set_interface dev %d:%d, interface %d, alt %d
usb_host_set_interface dev %d:%d, interface %d, alt %d
libusb_set_interface_alt_setting
%d@%zu.%06zu:usb_host_req_data dev %d:%d, packet %p, in %d, ep %d, size %d
usb_host_req_data dev %d:%d, packet %p, in %d, ep %d, size %d
%d@%zu.%06zu:usb_host_iso_start dev %d:%d, ep %d
usb_host_iso_start dev %d:%d, ep %d
%d@%zu.%06zu:usb_host_iso_out_of_bufs dev %d:%d, ep %d
usb_host_iso_out_of_bufs dev %d:%d, ep %d
Internal logic error: Bad audio format %d
Could not initialize poll mode
Invalid number of poll descriptors %d
Could not initialize poll mode
Could not obtain poll descriptors
%d@%zu.%06zu:alsa_pollout i = %d fd = %d
%d@%zu.%06zu:alsa_set_handler events=0x%x index=%d fd=%d err=%d
alsa_set_handler events=0x%x index=%d fd=%d err=%d
Could not fully initialize DAC
Failed to get current software parameters
Failed to set software threshold to %ld
Failed to set software parameters
Failed to initialize hardware parameters
Failed to set number of channels %d
Failed to set buffer time to %d
Requested buffer time %d was rejected, using %u
Failed to set period time to %d
Requested period time %d was rejected, using %d
Failed to apply audio parameters
Invalid format was returned %d
parameter | requested value | obtained value
format    |      %10d |     %10d
channels  |      %10d |     %10d
frequency |      %10d |     %10d
============================================
requested: buffer len %d period len %d
Failed to close PCM handle %p
dev->driver == AUDIODEV_DRIVER_ALSA
Could not prepare handle for %s
Could not start handle for %s
%d@%zu.%06zu:alsa_read_zero Failed to read %ld frames (read zero)
alsa_read_zero Failed to read %ld frames (read zero)
%d@%zu.%06zu:alsa_xrun_in Recovering from capture xrun
alsa_xrun_in Recovering from capture xrun
Failed to read %zu frames to %p
Could not obtain number of available frames
%d@%zu.%06zu:alsa_wrote_zero Failed to write %d frames (wrote zero)
alsa_wrote_zero Failed to write %d frames (wrote zero)
%d@%zu.%06zu:alsa_xrun_out Recovering from playback xrun
alsa_xrun_out Recovering from playback xrun
%d@%zu.%06zu:alsa_resume_out Resuming suspended output stream
alsa_resume_out Resuming suspended output stream
Failed to write %zu frames from %p
snd_pcm_poll_descriptors_revents
%d@%zu.%06zu:alsa_revents revents = %d
ALSA http://www.alsa-project.org
Failed to read %zu bytes of audio (to %p)
Failed to set non-blocking mode
Failed to set buffer length (%d, %d)
Returned bogus buffer information(%d, %d) for %s
SNDCTL_DSP_SETTRIGGER PCM_ENABLE_OUTPUT failed
SNDCTL_DSP_SETTRIGGER 0 failed
warning: Misaligned DAC buffer, size %d, alignment %d
Failed to map %zu bytes of DAC
Failed to unmap buffer %p size %zu
dev->driver == AUDIODEV_DRIVER_OSS
buf == hw->buf_emul + hw->pos_emul && size < hw->size_emul
Failed to unmap buffer %p, size %zu
warning: Misaligned ADC buffer, size %d, alignment %d
set_source_output_volume() failed
set_source_output_mute() failed
Internal logic error: Bad pa_sample_format %d
pa_threaded_mainloop_lock failed
buf == p->read_data && size <= p->read_length
Internal error: unsupported channel count %d
pa_simple_new for capture failed
pa_simple_new for playback failed
set_sink_input_volume() failed
pa_stream_writable_size failed
dev->driver == AUDIODEV_DRIVER_PA
Failed to initialize PA context
could not connect to PulseAudio server
SDL failed to initialize audio subsystem
SDL_OpenAudioDevice for %s failed
sdl_open: sigfillset failed: %s
sdl_open: pthread_sigmask failed: %s
sdl_open: pthread_sigmask (restore) failed: %s
Unrecognized SDL audio format %d
buf == out->frame + out->fpos && out->fpos <= out->fsize
Cannot use spice audio without -spice
vol->channels < sizeof(vol->vol)
%d@%zu.%06zu:dbus_audio_read len = %zu
buf == vo->buf + vo->buf_pos && vo->buf_pos + size <= vo->buf_size
%d@%zu.%06zu:dbus_audio_put_buffer_out buf_pos = %zu, buf_size = %zu
dbus_audio_put_buffer_out buf_pos = %zu, buf_size = %zu
swapped-signal::handle-register-out-listener
swapped-signal::handle-register-in-listener
%d@%zu.%06zu:dbus_audio_register sender = %s, dir = %s
dbus_audio_register sender = %s, dir = %s
/org/qemu/Display1/AudioOutListener
/org/qemu/Display1/AudioInListener
Timer based audio exposed with DBus interface
%d@%zu.%06zu:spice_vmc_read spice read %d of requested %d
spice_vmc_read spice read %d of requested %d
%d@%zu.%06zu:spice_vmc_write spice wrote %zd of requested %d
spice_vmc_write spice wrote %zd of requested %d
chardev: spice port: no name given
chardev: spice channel: no name given
%d@%zu.%06zu:spice_vmc_register_interface spice vmc registered interface %p
spice_vmc_register_interface spice vmc registered interface %p
%d@%zu.%06zu:spice_vmc_unregister_interface spice vmc unregistered interface %p
spice_vmc_unregister_interface spice vmc unregistered interface %p
/home/virus/AMD/AMD/include/chardev/spice.h
%d@%zu.%06zu:spice_vmc_event spice vmc event %d
spice_vmc_event spice vmc event %d
allowed spice char type names: %s
%d@%zu.%06zu:spice_chr_discard_write spice chr write discarded %d
spice_chr_discard_write spice chr write discarded %d
spice virtual channel char device
prop_id != 0 && prop_id - 1 < 4
prop_id != 0 && prop_id - 1 < 7
prop_id != 0 && prop_id - 1 < 2
prop_id != 0 && prop_id - 1 < 5
org.freedesktop.DBus.Properties.Set
prop_id != 0 && prop_id - 1 < 1
org.qemu.Display1.AudioOutListener
org.qemu.Display1.AudioInListener
Error setting property '%s' on interface org.qemu.Display1.VM: %s (%s, %d)
Error setting property '%s' on interface org.qemu.Display1.Console: %s (%s, %d)
Error setting property '%s' on interface org.qemu.Display1.Keyboard: %s (%s, %d)
Error setting property '%s' on interface org.qemu.Display1.Mouse: %s (%s, %d)
Error setting property '%s' on interface org.qemu.Display1.MultiTouch: %s (%s, %d)
Error setting property '%s' on interface org.qemu.Display1.Listener: %s (%s, %d)
Error setting property '%s' on interface org.qemu.Display1.Clipboard: %s (%s, %d)
Error setting property '%s' on interface org.qemu.Display1.Audio: %s (%s, %d)
Error setting property '%s' on interface org.qemu.Display1.AudioOutListener: %s (%s, %d)
Error setting property '%s' on interface org.qemu.Display1.AudioInListener: %s (%s, %d)
Error setting property '%s' on interface org.qemu.Display1.Chardev: %s (%s, %d)
G_VALUE_TYPE (a) == G_VALUE_TYPE (b)
_g_value_equal() does not handle type %s
org.freedesktop.DBus.Properties
[generated] _qemu_dbus_display1_vm_emit_changed
[generated] _qemu_dbus_display1_console_emit_changed
[generated] _qemu_dbus_display1_keyboard_emit_changed
[generated] _qemu_dbus_display1_mouse_emit_changed
[generated] _qemu_dbus_display1_multi_touch_emit_changed
[generated] _qemu_dbus_display1_listener_emit_changed
[generated] _qemu_dbus_display1_clipboard_emit_changed
[generated] _qemu_dbus_display1_audio_emit_changed
[generated] _qemu_dbus_display1_audio_out_listener_emit_changed
[generated] _qemu_dbus_display1_audio_in_listener_emit_changed
[generated] _qemu_dbus_display1_chardev_emit_changed
Method %s is not implemented on interface %s
QEMU_DBUS_IS_DISPLAY1_VM (object)
QemuDBusDisplay1ConsoleSkeleton
QEMU_DBUS_IS_DISPLAY1_CONSOLE (object)
QemuDBusDisplay1KeyboardSkeleton
QEMU_DBUS_IS_DISPLAY1_KEYBOARD (object)
QEMU_DBUS_IS_DISPLAY1_MOUSE (object)
QemuDBusDisplay1MultiTouchProxy
QemuDBusDisplay1MultiTouchSkeleton
QEMU_DBUS_IS_DISPLAY1_MULTI_TOUCH (object)
QemuDBusDisplay1ListenerSkeleton
QEMU_DBUS_IS_DISPLAY1_LISTENER (object)
QemuDBusDisplay1ListenerUnixMap
QemuDBusDisplay1ListenerUnixMapProxy
QemuDBusDisplay1ListenerUnixMapSkeleton
QemuDBusDisplay1ListenerWin32D3d11
QemuDBusDisplay1ListenerWin32D3d11Proxy
QemuDBusDisplay1ListenerWin32D3d11Skeleton
org.qemu.Display1.Listener.Win32.D3d11
QemuDBusDisplay1ClipboardProxy
QemuDBusDisplay1ClipboardSkeleton
QEMU_DBUS_IS_DISPLAY1_CLIPBOARD (object)
QEMU_DBUS_IS_DISPLAY1_AUDIO (object)
QemuDBusDisplay1AudioOutListener
QemuDBusDisplay1AudioOutListenerProxy
QemuDBusDisplay1AudioOutListenerSkeleton
QEMU_DBUS_IS_DISPLAY1_AUDIO_OUT_LISTENER (object)
QemuDBusDisplay1AudioInListener
QemuDBusDisplay1AudioInListenerProxy
QemuDBusDisplay1AudioInListenerSkeleton
QEMU_DBUS_IS_DISPLAY1_AUDIO_IN_LISTENER (object)
QemuDBusDisplay1ChardevSkeleton
QEMU_DBUS_IS_DISPLAY1_CHARDEV (object)
org.freedesktop.DBus.Property.EmitsChangedSignal
Received nested state when kernel cannot restore it
Received nested state size less than min: len=%d, min=%d
Received unsupported nested state size: nested_state->size=%d, max=%d
Received invalid nested state format: %d
Guest maybe enabled nested virtualization but kernel does not support required capabilities to save vCPU nested state
Mismatch between user-specified TSC frequency and migrated TSC frequency
Unsupported old non-softfloat CPU state
vCPU set in guest-mode inconsistent with migrated kernel nested state
Guest enabled re-enlightenment notifications, 'tsc-frequency=' has to be specified
cpu/kvm_nested_state/vmx/shadow_vmcs12
cpu/kvm_nested_state/vmx/vmcs12
cpu/msr_hyperv_reenlightenment
env.msr_hv_reenlightenment_control
env.msr_hv_tsc_emulation_control
env.msr_hv_tsc_emulation_status
%016lx: %016lx %c%c%c%c%c%c%c%c%c
KVM does not support userspace APIC
/home/virus/AMD/AMD/include/hw/i386/apic_internal.h
../target/i386/confidential-guest.h
/home/virus/AMD/AMD/include/system/confidential-guest-support.h
add kernel hashes to guest firmware for measured Linux boot
%d@%zu.%06zu:kvm_memcrypt_unregister_region addr %p len 0x%zx
kvm_memcrypt_unregister_region addr %p len 0x%zx
%s: failed to unregister region (%p+%#zx)
%d@%zu.%06zu:kvm_memcrypt_register_region addr %p len 0x%zx
kvm_memcrypt_register_region addr %p len 0x%zx
%s: failed to register region (%p+%#zx) error '%s'
%d@%zu.%06zu:kvm_sev_change_state %s -> %s
kvm_sev_change_state %s -> %s
%s: cannot disable RAM discard
sizeof(snp_cpuid_info) <= cpuid_len
SEV-SNP: unable to query CPUID values for CPU: '%s'
SEV-SNP: CPUID entry count (%d) exceeds max (%d)
SEV-SNP: failed to generate CPUID table information
guest owners DH certificate (encoded with base64)
guest owners session parameters (encoded with base64)
use legacy VM type to maintain measurement compatibility with older QEMU or kernel versions.
parameter length:ID_AUTH %lu exceeds max of %u
parameter length of %lu not equal to %u
parameter length of %lu not equal to %zu
parameter length of %lu exceeds max of %zu
SEV: host kernel does not support requested %s VM type, which is required for the set of options specified. To allow use of the legacy KVM_X86_DEFAULT_VM VM type, please disable any options that are not compatible with the legacy VM type, or upgrade your kernel.
SEV: host kernel does not support requested %s VM type. To allow use of the legacy KVM_X86_DEFAULT_VM VM type, the 'legacy-vm-type' argument must be set to 'on' or 'auto' for the sev-guest object.
SNP_LAUNCH_UPDATE called with invalid address/ length: %p / %zx
SEV-SNP: failed to configure initialprivate guest memory
%d@%zu.%06zu:kvm_sev_snp_launch_update src 0x%lx gpa 0x%lx len 0x%lx (%s page)
kvm_sev_snp_launch_update src 0x%lx gpa 0x%lx len 0x%lx (%s page)
SNP_LAUNCH_UPDATE ret=%d fw_error=%d '%s'
SEV-SNP: CPUID validation failed due to count mismatch, provided: %d, expected: %d
SEV-SNP: CPUID validation failed for function 0x%x, index: 0x%x, provided: eax:0x%08x, ebx: 0x%08x, ecx: 0x%08x, edx: 0x%08x, expected: eax:0x%08x, ebx: 0x%08x, ecx: 0x%08x, edx: 0x%08x
SEV-SNP: failed update CPUID page
SEV-SNP: expected update of GPA range %lx-%lx,got GPA range %lx-%llx
%d@%zu.%06zu:kvm_sev_launch_finish 
%s: LAUNCH_FINISH ret=%d fw_error=%d '%s'
SEV: Migration is not implemented
%s: Failed to locate SEV metadata header
%s: Failed to get HVA for GPA 0x%x sz 0x%x
(sev_snp->kernel_hashes_offset + sizeof(*sev_snp->kernel_hashes_data)) <= len
%s: Failed to add metadata page gpa 0x%x+%x type %d
%d@%zu.%06zu:kvm_sev_snp_launch_finish id_block %s id_auth %s host_data %s
kvm_sev_snp_launch_finish id_block %s id_auth %s host_data %s
SNP_LAUNCH_FINISH ret=%d fw_error=%d '%s'
SEV-SNP: Migration is not implemented
%d@%zu.%06zu:kvm_sev_launch_update_data addr %p len 0x%zx
kvm_sev_launch_update_data addr %p len 0x%zx
%s: LAUNCH_UPDATE ret=%d fw_error=%d '%s'
%d@%zu.%06zu:kvm_sev_launch_start policy 0x%x session %p pdh %p
kvm_sev_launch_start policy 0x%x session %p pdh %p
%s: LAUNCH_START ret=%d fw_error=%d '%s'
%d@%zu.%06zu:kvm_sev_snp_launch_start policy 0x%lx gosvw %s
kvm_sev_snp_launch_start policy 0x%lx gosvw %s
%s: SNP_LAUNCH_START ret=%d fw_error=%d '%s'
%s: LAUNCH_UPDATE_VMSA ret=%d fw_error=%d '%s'
%s: LAUNCH_MEASURE ret=%d fw_error=%d '%s'
%d@%zu.%06zu:kvm_sev_launch_measurement data %s
kvm_sev_launch_measurement data %s
%s: cbitpos check failed, host '%d' requested '%d'
%s: reduced_phys_bits check failed, it should be in the range of 1 to 63, requested '%d'
%s: failed to get platform status ret=%d fw_error='%d: %s'
%s: SEV-ES guests require in-kernel irqchipsupport
%s: guest policy requires SEV-ES, but host SEV-ES support unavailable
%s: host kernel does not support the requested SEV configuration.
%s: failed to initialize ret=%d fw_error=%d '%s'
%s: failed to create encryption context
SEV: Failed to export PDH cert ret=%d fw_err=%d (%s)
SEV: Failed to get ID ret=%d fw_err=%d (%s)
dc886566-984a-4798-A75e-5585a7bf67cc
SEV: failed to decode mnonce input
SEV: mnonce must be %zu bytes (got %lu)
SEV: Failed to query the attestation report length ret=%d fw_err=%d (%s)
SEV: Failed to get attestation report ret=%d fw_err=%d (%s)
%d@%zu.%06zu:kvm_sev_attestation_report mnonce %s data %s
kvm_sev_attestation_report mnonce %s data %s
SEV launch measurement is not available
SEV: Failed to encrypt pflash rom
SEV: cannot map hashes table guest memory area
SEV: Not in correct state. (LSECRET) %x
SEV: Failed to decode sequence header
SEV: Failed to calculate guest address: 
%d@%zu.%06zu:kvm_sev_launch_secret hpa 0x%lx hva 0x%lx data 0x%lx len %d
kvm_sev_launch_secret hpa 0x%lx hva 0x%lx data 0x%lx len %d
SEV: failed to inject secret ret=%d fw_error=%d '%s'
4c2eb361-7d9b-4cc3-8081-127c90d3d294
SEV: no secret area found in OVMF, gpa must be specified.
00f771de-1a7e-4fcb-890e-68c77e2fb44e
SEV information block/Firmware GUID Table block not found in pflash rom
7255371f-3a3b-4b04-927b-1da6efa8d454
SEV: kernel specified but guest firmware has no hashes table GUID
SEV: guest firmware hashes table area is invalid (base=0x%x size=0x%x)
Platform configuration is invalid
Required firmware resource depleted
Part-specific integrity check failure
error: failed to set MSR 0x%x to 0x%lx
ret == cpu->kvm_msr_buf->nmsrs
%d@%zu.%06zu:kvm_x86_update_msi_routes Updated %d MSI routes
kvm_x86_update_msi_routes Updated %d MSI routes
/home/virus/AMD/AMD/include/system/kvm.h
Cannot set properties after the accelerator has been initialized
/home/virus/AMD/AMD/include/hw/i386/topology.h
TSC frequency mismatch between VM (%ld kHz) and host (%d kHz), and TSC scaling unavailable
KVM_GET_SUPPORTED_HV_CPUID failed: %s
kvm_hyperv_properties[feature].flags[0].func
configuration type %s not supported for x86 guests
../target/i386/kvm/../confidential-guest.h
vm-type %s not supported by KVM
KVM_GET_SUPPORTED_CPUID failed: %s
KVM_GET_DEVICE_ATTR(0, KVM_X86_XCOMP_GUEST_SUPP) error: %d
KVM get MSR (index=0x%x) feature failed, %s
code == BUS_MCEERR_AR || code == BUS_MCEERR_AO
Guest MCE Memory Error at QEMU addr %p and GUEST addr 0x%lx of type %s injected
QEMU got Hardware memory error at addr %p
Hardware memory error at addr %p of type %s for memory used by QEMU itself instead of guest system!
Hyper-V %s is not supported by kernel
Hyper-V %s requires Hyper-V %s
synthetic interrupt controller (hv-synic)
'hv-passthrough' CPU flag prevents migration, use explicit set of hv-* flags instead
'hv-no-nonarch-coresharing=auto' CPU flag prevents migration use explicit 'hv-no-nonarch-coresharing=on' instead (but make sure SMT is disabled and/or that vCPUs are properly pinned)
kernel's vp_index != QEMU's vp_index
failed to turn on HyperV SynIC in KVM: %s
failed to create HyperV SynIC: %s
eVMCS version range [%d..%d] is not supported by kernel (supported: [%d..%d])
failed to enable KVM_CAP_HYPERV_ENFORCE_CPUID: %s
failed to enable KVM_CAP_ENFORCE_PV_FEATURE_CPUID: %s
cpuid_data is full, no space for cpuid(eax:0x%x,ecx:0x%x)
kvm: Unsupported MCE bank count (QEMU = %d, KVM = %d)
Unsupported MCG_CAP bits: 0x%lx
State blocked by non-migratable CPU device (invtsc flag)
kvm_arch_get_supported_cpuid(kvm_state, 0xd, 0, R_ECX) <= env->xsave_buf_len
max_nested_state_len >= offsetof(struct kvm_nested_state, data)
parked vCPU %lu TSC reset failed: %d
kvm: Failed to enable exception payload cap: %s
kvm: Failed to enable triple fault event cap: %s
kvm: Xen support only available in PC machine
Fetch KVM feature MSR list failed: %s
kvm: guest stopping CPU not supported: %s
kvm: bus lock detection unsupported
kvm: Failed to enable bus lock detection cap: %s
kvm: Failed to enable notify vmexit cap: %s
Could not enable user space MSRs: %s
Could not install MSR_CORE_THREAD_COUNT handler: %s
Could not install MSR_RAPL_POWER_UNIT handler: %s
Could not install MSR_PKG_POWER_LIMIT handler: %s
Could not install MSR_PKG_POWER_INFO handler: %s
Could not install MSR_PKG_ENERGY_STATUS handler: %s
The RAPL feature can only be enabled on hosts with Intel CPU models
cpu per packages = 0 on package_%d
kvm : error RAPL feature requirement not met
cpu_is_stopped(cpu) || qemu_cpu_is_self(cpu)
Failed to set feature control MSR
Failed to set special registers
env->nested_state->size <= max_nested_state_len
Failed to set general purpose registers
Failed to set TSC deadline MSR
cpu_is_stopped(cs) || qemu_cpu_is_self(cs)
Failed to get general purpose registers
Failed to get special registers
cpu->phys_bits <= TARGET_PHYS_ADDR_SPACE_BITS
KVM: injection failed, NMI lost (%s)
KVM: injection failed, SMI lost (%s)
KVM: injection failed, interrupt lost (%s)
/home/virus/AMD/AMD/include/qemu/ratelimit.h
Could not enable SGX PROVISIONKEY: %s
KVM: entry failed, hardware error 0x%lx
If you're running a guest on an Intel machine without unrestricted mode
support, the failure can be most likely due to the guest entering an invalid
state for Intel VT. For example, the guest maybe running in big real mode
which is not supported on less recent Intel processors.
KVM: exception %d exit (error code 0x%x)
KVM internal error: Encountered a notify exit with invalid context in guest.
KVM: Encountered a notify exit with valid context in guest. The guest could be misbehaving.
run->msr.reason == KVM_MSR_EXIT_REASON_FILTER
%d@%zu.%06zu:kvm_hc_map_gpa_range gpa 0x%lx size 0x%lx attributes 0x%lx flags 0x%lx
kvm_hc_map_gpa_range gpa 0x%lx size 0x%lx attributes 0x%lx flags 0x%lx
Could not enable split IRQ mode.
Could not enable split irqchip mode: %s
/home/virus/AMD/AMD/include/hw/i386/x86-iommu.h
%d@%zu.%06zu:kvm_x86_fixup_msi_error VT-d failed to remap interrupt for GSI %u
kvm_x86_fixup_msi_error VT-d failed to remap interrupt for GSI %u
%d@%zu.%06zu:kvm_x86_add_msi_route Adding route entry for virq %d
kvm_x86_add_msi_route Adding route entry for virq %d
%d@%zu.%06zu:kvm_x86_remove_msi_route Removing route entry for virq %d
kvm_x86_remove_msi_route Removing route entry for virq %d
prctl(ARCH_REQ_XCOMP_GUEST_PERM) failure for feature bit %d
Clock cycles without an event window after which a notification VM exit occurs
Xen version to be emulated (in XENVER_version form e.g. 0x4000a for 4.10)
Maximum number of grant table frames
frequency MSRs (hv-frequencies)
reenlightenment MSRs (hv-reenlightenment)
paravirtualized TLB flush (hv-tlbflush)
direct mode synthetic timers (hv-stimer-direct)
AVIC/APICv support (hv-avic/hv-apicv)
Enable synthetic kernel debugger channel (hv-syndbg)
enlightened MSR-Bitmap (hv-emsr-bitmap)
XMM fast hypercall input (hv-xmm-input)
Extended gva ranges for TLB flush hypercalls (hv-tlbflush-ext)
direct TLB flush (hv-tlbflush-direct)
/home/virus/AMD/AMD/include/accel/accel-cpu-target.h
/sys/class/powercap/intel-rapl/enabled
Error opening physical_package_id file
/sys/devices/system/cpu/cpu%d/topology/physical_package_id
%*d (%*[^)]) %*c %*d %*d %*d %*d %*d %*u %*u %*u %*u %*u %llu %llu %*d %*d %*d %*d %*d %*d %*u %*u %*d %*u %*u %*u %*u %*u %*u %*u %*u %*u %*u %*u %*d %*u %*u %u
Error fscanf did not report the right amount of items
%d@%zu.%06zu:kvm_xen_set_vcpu_attr vcpu attr cpu %d type %d gpa 0x%lx
kvm_xen_set_vcpu_attr vcpu attr cpu %d type %d gpa 0x%lx
%d@%zu.%06zu:kvm_xen_set_shared_info shared info at gfn 0x%lx
kvm_xen_set_shared_info shared info at gfn 0x%lx
%d@%zu.%06zu:kvm_xen_set_vcpu_callback callback vcpu %d vector %d
kvm_xen_set_vcpu_callback callback vcpu %d vector %d
kvm: Xen HVM guest support not present or insufficient
kvm: Failed to enable Xen HVM support: %s
kvm: Xen support requires kernel-irqchip=split
kvm: Failed to set Xen vCPU ID attribute: %s
%d@%zu.%06zu:kvm_xen_soft_reset 
Unimplemented Xen hypercall %ld (0x%lx 0x%lx 0x%lx)
%d@%zu.%06zu:kvm_xen_hypercall xen_hypercall: cpu %d cpl %d input %lu a0 0x%lx a1 0x%lx a2 0x%lx ret 0x%lx
kvm_xen_hypercall xen_hypercall: cpu %d cpl %d input %lu a0 0x%lx a1 0x%lx a2 0x%lx ret 0x%lx
../target/i386/tcg/system/excp_helper.c
inout->ptw_idx == MMU_NESTED_IDX
../target/i386/tcg/system/misc_helper.c
../target/i386/tcg/system/fpu_helper.c
vmexit(%08x, %016lx, %016lx, %016lx)!
../target/i386/tcg/system/seg_helper.c
Servicing hardware INT=0x%02x
Servicing virtual hardware INT=0x%02x
/home/virus/AMD/AMD/include/hw/i386/pc.h
../hw/i386/e820_memory_layout.c
Cannot load x86-64 image, give a 32bit one.
Error while loading elf kernel
Error while fetching elf kernel from rom
kernel does not fit in address space
s->mb_mods_count < s->mb_mods_avail
cpu_index < possible_cpus->len
Override the default value of field OEMID in ACPI table header.The string may be up to 6 bytes in size
Override the default value of field OEM Table ID in ACPI table header.The string may be up to 8 bytes in size
Set the ratelimit for the bus locks acquired in VMs
User specified x-oem-table-id value is bigger than 8 bytes in size
User specified x-oem-id value is bigger than 6 bytes in size
ms->possible_cpus->len == max_cpus
System Management Mode not supported by this hypervisor.
/home/virus/AMD/AMD/target/i386/cpu-qom.h
%d@%zu.%06zu:x86_pic_interrupt PIC interrupt #%d level:%d
x86_pic_interrupt PIC interrupt #%d level:%d
Machine-type '%s' not supported by IOMMU
Interrupt Remapping cannot work with kernel-irqchip=on, please use 'split|off'.
%d@%zu.%06zu:x86_iommu_iec_notify Notify IEC invalidation: global=%d index=%u mask=%u
x86_iommu_iec_notify Notify IEC invalidation: global=%d index=%u mask=%u
AMD IOMMU (AMD-Vi) DMA Remapping device
device %02x.%02x.%x requires iommu notifier which is not currently supported
%d@%zu.%06zu:amdvi_iotlb_reset IOTLB exceed size limit - reset 
amdvi_iotlb_reset IOTLB exceed size limit - reset 
%d@%zu.%06zu:amdvi_command_error error: Executing commands with command buffer disabled 0x%lx
amdvi_command_error error: Executing commands with command buffer disabled 0x%lx
%d@%zu.%06zu:amdvi_command_exec command buffer head at 0x%x command buffer tail at 0x%x command buffer base at 0x%lx
amdvi_command_exec command buffer head at 0x%x command buffer tail at 0x%x command buffer base at 0x%lx
%d@%zu.%06zu:amdvi_command_read_fail error: fail to access memory at 0x%lx + 0x%x
amdvi_command_read_fail error: fail to access memory at 0x%lx + 0x%x
%d@%zu.%06zu:amdvi_completion_wait_fail error: fail to write at address 0x%lx
amdvi_completion_wait_fail error: fail to write at address 0x%lx
%d@%zu.%06zu:amdvi_completion_wait completion wait requested with store address 0x%lx and store data 0x%lx
amdvi_completion_wait completion wait requested with store address 0x%lx and store data 0x%lx
%d@%zu.%06zu:amdvi_devtab_inval device table entry for devid: %02x:%02x.%x invalidated
amdvi_devtab_inval device table entry for devid: %02x:%02x.%x invalidated
%d@%zu.%06zu:amdvi_pages_inval AMD-Vi pages for domain 0x%x invalidated
amdvi_pages_inval AMD-Vi pages for domain 0x%x invalidated
%d@%zu.%06zu:amdvi_iotlb_inval IOTLB pages invalidated
amdvi_iotlb_inval IOTLB pages invalidated
%d@%zu.%06zu:amdvi_intr_inval Interrupt table invalidated
amdvi_intr_inval Interrupt table invalidated
%d@%zu.%06zu:amdvi_prefetch_pages Pre-fetch of AMD-Vi pages requested
amdvi_prefetch_pages Pre-fetch of AMD-Vi pages requested
%d@%zu.%06zu:amdvi_ppr_exec Execution of PPR queue requested 
amdvi_ppr_exec Execution of PPR queue requested 
%d@%zu.%06zu:amdvi_all_inval Invalidation of all AMD-Vi cache requested 
amdvi_all_inval Invalidation of all AMD-Vi cache requested 
%d@%zu.%06zu:amdvi_unhandled_command unhandled command 0x%x
amdvi_unhandled_command unhandled command 0x%x
%d@%zu.%06zu:amdvi_dte_get_fail error: failed to access Device Entry devtab 0x%lx offset 0x%x
amdvi_dte_get_fail error: failed to access Device Entry devtab 0x%lx offset 0x%x
%d@%zu.%06zu:amdvi_invalid_dte PTE entry at 0x%lx is invalid 
amdvi_invalid_dte PTE entry at 0x%lx is invalid 
%d@%zu.%06zu:amdvi_iotlb_hit hit iotlb devid %02x:%02x.%x gpa 0x%lx hpa 0x%lx
amdvi_iotlb_hit hit iotlb devid %02x:%02x.%x gpa 0x%lx hpa 0x%lx
%d@%zu.%06zu:amdvi_mode_invalid error: translation level 0x%x translating addr 0x%lx
amdvi_mode_invalid error: translation level 0x%x translating addr 0x%lx
%d@%zu.%06zu:amdvi_page_fault error: page fault accessing guest physical address 0x%lx
amdvi_page_fault error: page fault accessing guest physical address 0x%lx
%d@%zu.%06zu:amdvi_get_pte_hwerror hardware error eccessing PTE at addr 0x%lx
amdvi_get_pte_hwerror hardware error eccessing PTE at addr 0x%lx
%d@%zu.%06zu:amdvi_cache_update  update iotlb domid 0x%x devid: %02x:%02x.%x gpa 0x%lx hpa 0x%lx
amdvi_cache_update  update iotlb domid 0x%x devid: %02x:%02x.%x gpa 0x%lx hpa 0x%lx
%d@%zu.%06zu:amdvi_translation_result devid: %02x:%02x.%x gpa 0x%lx hpa 0x%lx
amdvi_translation_result devid: %02x:%02x.%x gpa 0x%lx hpa 0x%lx
AMD IOMMU with x2APIC configuration requires xtsup=on
%d@%zu.%06zu:amdvi_mmio_read %s read addr 0x%lx, size %u offset 0x%lx
amdvi_mmio_read %s read addr 0x%lx, size %u offset 0x%lx
%d@%zu.%06zu:amdvi_mmio_read_invalid error: addr outside region (max 0x%x): read addr 0x%lx, size %u
amdvi_mmio_read_invalid error: addr outside region (max 0x%x): read addr 0x%lx, size %u
error: addr outside region: max 
%d@%zu.%06zu:amdvi_mmio_write %s write addr 0x%lx, size %u, val 0x%lx, offset 0x%lx
amdvi_mmio_write %s write addr 0x%lx, size %u, val 0x%lx, offset 0x%lx
%d@%zu.%06zu:amdvi_control_status MMIO_STATUS state 0x%lx
amdvi_control_status MMIO_STATUS state 0x%lx
%d@%zu.%06zu:amdvi_ir_remap_msi_req addr 0x%lx data 0x%lx devid 0x%x
amdvi_ir_remap_msi_req addr 0x%lx data 0x%lx devid 0x%x
Interrupt remapping is enabled in the guest but not in the host. Use intremap=on to enable interrupt remapping in amd-iommu.
%d@%zu.%06zu:amdvi_ir_delivery_mode %s
%d@%zu.%06zu:amdvi_ir_intctl int_ctl 0x%x
%d@%zu.%06zu:amdvi_ir_target_abort %s
%d@%zu.%06zu:amdvi_ir_irte addr 0x%lx offset 0x%lx
amdvi_ir_irte addr 0x%lx offset 0x%lx
%d@%zu.%06zu:amdvi_ir_irte_ga_val hi 0x%lx lo 0x%lx
amdvi_ir_irte_ga_val hi 0x%lx lo 0x%lx
%d@%zu.%06zu:amdvi_ir_irte_val data 0x%x
%d@%zu.%06zu:amdvi_ir_remap_msi (addr 0x%lx, data 0x%lx) -> (addr 0x%lx, data 0x%lx)
amdvi_ir_remap_msi (addr 0x%lx, data 0x%lx) -> (addr 0x%lx, data 0x%lx)
%d@%zu.%06zu:amdvi_mem_ir_write_req addr 0x%lx data 0x%lx size 0x%x
amdvi_mem_ir_write_req addr 0x%lx data 0x%lx size 0x%x
failed to remap interrupt from devid 0x%x
%d@%zu.%06zu:amdvi_mem_ir_write addr 0x%lx data 0x%lx
amdvi_mem_ir_write addr 0x%lx data 0x%lx
Standard PC (i440FX + PIIX, 1996)
Use a different south bridge than PIIX3
Invalid south bridge value set
machines more than 3 years old are subject to deletion after 6 years
Large machine and max_ram_below_4g (%lu) not a multiple of 1G; possible bad performance.
current -smp configuration requires kernel irqchip and X2APIC API support.
CPU hot unplug not supported without ACPI
Invalid CPU type, expected cpu type: '%s'
Invalid CPU socket-id: %u must be in range 0:%u
Invalid CPU die-id: %u must be in range 0:%u
Invalid CPU module-id: %u must be in range 0:%u
Invalid CPU core-id: %u must be in range 0:%u
Invalid CPU thread-id: %u must be in range 0:%u
Invalid CPU [socket: %u, die: %u, module: %u, core: %u, thread: %u] with APIC ID %u, valid index range 0:%d
CPU[%d] with APIC ID %u exists
property socket-id: %u doesn't match set apic-id: 0x%x (socket-id: %u)
property die-id: %u doesn't match set apic-id: 0x%x (die-id: %u)
property module-id: %u doesn't match set apic-id: 0x%x (module-id: %u)
property core-id: %u doesn't match set apic-id: 0x%x (core-id: %u)
property thread-id: %u doesn't match set apic-id: 0x%x (thread-id: %u)
kernel doesn't allow setting HyperV VP_INDEX
%d@%zu.%06zu:x86_gsi_interrupt GSI interrupt #%d level:%d
x86_gsi_interrupt GSI interrupt #%d level:%d
qemu: could not open kernel file '%s': %s
qemu: could not load kernel '%s': %s
elfboot unsupported flags = %x
Error loading uncompressed kernel without PVH ELF Note
qemu: error reading initrd %s: %s
qemu: initrd is too large, cannot support.(max: %u, need %ld)
qemu: invalid 'vga=' kernel parameter.
qemu: linux kernel too old to load a ram disk
qemu: Linux kernel too old to load a dtb
qemu: error reading dtb %s: %s
qemu: error reading shim %s: %s
qemu: could not load PC BIOS '%s'
unplug not supported by microvm
/home/virus/AMD/AMD/include/hw/i386/microvm.h
Set off to disable the instantiation an ISA serial port
Set off to disable loading option ROMs
Set off to disable adding virtio-mmio devices to the kernel cmdline
 virtio_mmio.device=512@0x%lx:%ld
There is possibly poor performance as the ram size  (0x%lx) is more then twice the size of max-ram-below-4g (%lu) and max-ram-below-4g is not a multiple of 1G.
MAX_SATA_PORTS == ich9->ahci.ports
Standard PC (Q35 + ICH9, 2009)
vmmouse needs a machine with vmport
%d@%zu.%06zu:vmmouse_mouse_event event: x=%d y=%d dz=%d state=%d
vmmouse_mouse_event event: x=%d y=%d dz=%d state=%d
%d@%zu.%06zu:vmmouse_disable 
%d@%zu.%06zu:vmmouse_get_status 
%d@%zu.%06zu:vmmouse_read_id 
%d@%zu.%06zu:vmmouse_request_relative 
%d@%zu.%06zu:vmmouse_request_absolute 
%d@%zu.%06zu:vmmouse_data data: size=%u
vmmouse: driver requested too much data %d
%d@%zu.%06zu:vmport_command command: 0x%02x
vmport_command command: 0x%02x
%d@%zu.%06zu:vmport_register command: 0x%02x func: %p opaque: %p
vmport_register command: 0x%02x func: %p opaque: %p
%d@%zu.%06zu:vtd_fsts_ppf FSTS PPF bit set to %d
vtd_fsts_ppf FSTS PPF bit set to %d
%d@%zu.%06zu:vtd_reg_read addr 0x%lx size 0x%lx
vtd_reg_read addr 0x%lx size 0x%lx
%s: MMIO over range: addr=0x%lx size=0x%x
%d@%zu.%06zu:vtd_irq_generate addr 0x%lx data 0x%lx
vtd_irq_generate addr 0x%lx data 0x%lx
Intel IOMMU (VT-d) DMA Remapping device
%d@%zu.%06zu:vtd_context_cache_reset 
%d@%zu.%06zu:vtd_as_unmap_whole Device %02x:%02x.%x start 0x%lx size 0x%lx
vtd_as_unmap_whole Device %02x:%02x.%x start 0x%lx size 0x%lx
There are previous interrupt conditions to be serviced by software, fault event is not generated
Interrupt Mask set, irq is not generated
%s: invalid %s desc val[3]: 0x%lx val[2]: 0x%lx val[1]=0x%lx val[0]=0x%lx (reserved nonzero)
%s: 256-bit %s desc in 128-bit invalidation queue
%s: invalid %s desc: hi=%lx, lo=%lx (reserved nonzero)
/home/virus/AMD/AMD/include/hw/i386/intel_iommu.h
We need to set caching-mode=on for intel-iommu to enable device assignment with IOMMU protection.
New fault is not recorded due to Primary Fault Overflow
New fault is not recorded due to compression of faults
Next Fault Recording Reg is used, new fault is not recorded, set PFO field
%d@%zu.%06zu:vtd_frr_new index %d high 0x%lx low 0x%lx
vtd_frr_new index %d high 0x%lx low 0x%lx
There are pending faults already, fault event is not generated
%d@%zu.%06zu:vtd_fault_disabled Fault processing disabled for context entry
vtd_fault_disabled Fault processing disabled for context entry
%d@%zu.%06zu:vtd_dmar_fault sid 0x%x fault %d addr 0x%lx write %d
vtd_dmar_fault sid 0x%x fault %d addr 0x%lx write %d
Snoop Control with vhost or VFIO is not supported
device %02x.%02x.%x requires caching mode
device %02x.%02x.%x requires device IOTLB mode
%d@%zu.%06zu:vtd_re_not_present Root entry bus %u not present
vtd_re_not_present Root entry bus %u not present
%s: invalid root entry: hi=0x%lx, lo=0x%lx
%d@%zu.%06zu:vtd_ce_not_present Context entry bus %u devfn %u not present
vtd_ce_not_present Context entry bus %u devfn %u not present
%s: invalid context entry: hi=%lx, lo=%lx (reserved nonzero)
%s: invalid context entry: val[3]=%lx, val[2]=%lx, val[1]=%lx, val[0]=%lx (reserved nonzero)
%s: invalid context entry: hi=%lx, lo=%lx (level %d not supported)
%s: DT specified but not supported
%s: PT specified but not supported
s->intr_eim != ON_OFF_AUTO_AUTO
%d@%zu.%06zu:vtd_switch_address_space Device %02x:%02x.%x switching address space (iommu enabled=%d)
vtd_switch_address_space Device %02x:%02x.%x switching address space (iommu enabled=%d)
Host IOMMU device already exist
host device is uncompatible with stage-1 translation
%d@%zu.%06zu:vtd_ir_remap_msi_req addr 0x%lx data 0x%lx
vtd_ir_remap_msi_req addr 0x%lx data 0x%lx
%s: MSI address high 32 bits non-zero detected: address=0x%lx
%s: MSI address low 32 bit invalid: 0x%x
%s: read failed: ind=0x%x addr=0x%lx
%d@%zu.%06zu:vtd_ir_irte_get index %d low 0x%lx high 0x%lx
vtd_ir_irte_get index %d low 0x%lx high 0x%lx
%s: detected non-present IRTE (index=%u, high=0x%lx, low=0x%lx)
%s: detected non-zero reserved IRTE (index=%u, high=0x%lx, low=0x%lx)
%s: invalid IRTE SID (index=%u, sid=%u, source_id=%u)
%s: invalid SVT_BUS (index=%u, bus=%u, min=%u, max=%u)
%s: detected invalid IRTE SVT (index=%u, type=%d)
%d@%zu.%06zu:vtd_ir_remap index %d trigger %d vector %d deliver %d dest 0x%x mode %d
vtd_ir_remap index %d trigger %d vector %d deliver %d dest 0x%x mode %d
%d@%zu.%06zu:vtd_ir_remap_type %s
%s: invalid IR MSI (sid=%u, address=0x%lx, data=0x%x)
%d@%zu.%06zu:vtd_warn_ir_vector sid 0x%x index %d vec %d (should be: %d)
vtd_warn_ir_vector sid 0x%x index %d vec %d (should be: %d)
%d@%zu.%06zu:vtd_warn_ir_trigger sid 0x%x index %d trigger %d (should be: %d)
vtd_warn_ir_trigger sid 0x%x index %d trigger %d (should be: %d)
%d@%zu.%06zu:vtd_ir_remap_msi (addr 0x%lx, data 0x%lx) -> (addr 0x%lx, data 0x%lx)
vtd_ir_remap_msi (addr 0x%lx, data 0x%lx) -> (addr 0x%lx, data 0x%lx)
%d@%zu.%06zu:vtd_page_walk_level walk (base=0x%lx, level=%u) iova range 0x%lx - 0x%lx
vtd_page_walk_level walk (base=0x%lx, level=%u) iova range 0x%lx - 0x%lx
%d@%zu.%06zu:vtd_page_walk_skip_read Page walk skip iova 0x%lx - 0x%lx due to unable to read
vtd_page_walk_skip_read Page walk skip iova 0x%lx - 0x%lx due to unable to read
%d@%zu.%06zu:vtd_page_walk_skip_reserve Page walk skip iova 0x%lx - 0x%lx due to rsrv set
vtd_page_walk_skip_reserve Page walk skip iova 0x%lx - 0x%lx due to rsrv set
%d@%zu.%06zu:vtd_page_walk_one_skip_unmap iova 0x%lx mask 0x%lx
vtd_page_walk_one_skip_unmap iova 0x%lx mask 0x%lx
%d@%zu.%06zu:vtd_page_walk_one_skip_map iova 0x%lx mask 0x%lx translated 0x%lx
vtd_page_walk_one_skip_map iova 0x%lx mask 0x%lx translated 0x%lx
%d@%zu.%06zu:vtd_page_walk_one domain 0x%x iova 0x%lx -> gpa 0x%lx mask 0x%lx perm %d
vtd_page_walk_one domain 0x%x iova 0x%lx -> gpa 0x%lx mask 0x%lx perm %d
%d@%zu.%06zu:vtd_inv_desc_cc_global context invalidate globally
vtd_inv_desc_cc_global context invalidate globally
%d@%zu.%06zu:vtd_inv_desc_iotlb_domain iotlb invalidate whole domain 0x%x
vtd_inv_desc_iotlb_domain iotlb invalidate whole domain 0x%x
%d@%zu.%06zu:vtd_inv_desc_cc_devices context invalidate devices sid 0x%x fmask 0x%x
vtd_inv_desc_cc_devices context invalidate devices sid 0x%x fmask 0x%x
%d@%zu.%06zu:vtd_inv_desc_cc_device context invalidate device %02x:%02x.%02x
vtd_inv_desc_cc_device context invalidate device %02x:%02x.%02x
Queued Invalidation enabled, should not use register-based invalidation
%d@%zu.%06zu:vtd_inv_desc_iotlb_global iotlb invalidate global
vtd_inv_desc_iotlb_global iotlb invalidate global
%d@%zu.%06zu:vtd_inv_desc_iotlb_pages iotlb invalidate domain 0x%x addr 0x%lx mask 0x%x
vtd_inv_desc_iotlb_pages iotlb invalidate domain 0x%x addr 0x%lx mask 0x%x
%s: address mask overflow: 0x%lx
%s: invalid granularity: 0x%lx
%d@%zu.%06zu:vtd_replay_ce_valid %s: replay valid context device %02x:%02x.%02x domain 0x%x hi 0x%lx lo 0x%lx
vtd_replay_ce_valid %s: replay valid context device %02x:%02x.%02x domain 0x%x hi 0x%lx lo 0x%lx
%d@%zu.%06zu:vtd_replay_ce_invalid replay invalid context device %02x:%02x.%02x
vtd_replay_ce_invalid replay invalid context device %02x:%02x.%02x
%d@%zu.%06zu:vtd_iotlb_page_hit IOTLB page hit sid 0x%x iova 0x%lx slpte 0x%lx domain 0x%x
vtd_iotlb_page_hit IOTLB page hit sid 0x%x iova 0x%lx slpte 0x%lx domain 0x%x
%d@%zu.%06zu:vtd_iotlb_cc_hit IOTLB context hit bus 0x%x devfn 0x%x high 0x%lx low 0x%lx gen %u
vtd_iotlb_cc_hit IOTLB context hit bus 0x%x devfn 0x%x high 0x%lx low 0x%lx gen %u
%d@%zu.%06zu:vtd_iotlb_cc_update IOTLB context update bus 0x%x devfn 0x%x high 0x%lx low 0x%lx gen %u -> gen %u
vtd_iotlb_cc_update IOTLB context update bus 0x%x devfn 0x%x high 0x%lx low 0x%lx gen %u -> gen %u
%d@%zu.%06zu:vtd_translate_pt source id 0x%x, iova 0x%lx
vtd_translate_pt source id 0x%x, iova 0x%lx
%d@%zu.%06zu:vtd_pt_enable_fast_path sid 0x%x %d
vtd_pt_enable_fast_path sid 0x%x %d
%s: detected non canonical IOVA (iova=0x%lx,pasid=0x%x)
%s: detected flpte reserved non-zero iova=0x%lx, level=0x%xflpte=0x%lx, pasid=0x%X)
%s: detected IOVA overflow (iova=0x%lx,pasid=0x%x)
%s: detected read error on DMAR slpte (iova=0x%lx, pasid=0x%x)
%s: detected slpte permission error (iova=0x%lx, level=0x%x, slpte=0x%lx, write=%d, pasid=0x%x)
%s: detected splte reserve non-zero iova=0x%lx, level=0x%xslpte=0x%lx, pasid=0x%X)
%s: xlat address is in interrupt range (iova=0x%lx, level=0x%x, pte=0x%lx, write=%d, xlat=0x%lx, size=0x%lx, pasid=0x%x)
%d@%zu.%06zu:vtd_iotlb_page_update IOTLB page update sid 0x%x iova 0x%lx slpte 0x%lx domain 0x%x
vtd_iotlb_page_update IOTLB page update sid 0x%x iova 0x%lx slpte 0x%lx domain 0x%x
%d@%zu.%06zu:vtd_iotlb_reset IOTLB reset (reason: %s)
vtd_iotlb_reset IOTLB reset (reason: %s)
%s: detected translation failure (dev=%02x:%02x:%02x, iova=0x%lx)
%d@%zu.%06zu:vtd_dmar_translate dev %02x:%02x.%02x iova 0x%lx -> gpa 0x%lx mask 0x%lx
vtd_dmar_translate dev %02x:%02x.%02x iova 0x%lx -> gpa 0x%lx mask 0x%lx
%d@%zu.%06zu:vtd_inv_qi_fetch 
%s: detected invalid QI tail (tail=0x%x, size=0x%x)
%d@%zu.%06zu:vtd_inv_qi_head read head %d
%d@%zu.%06zu:vtd_inv_desc invalidate desc type %s high 0x%lx low 0x%lx
vtd_inv_desc invalidate desc type %s high 0x%lx low 0x%lx
%d@%zu.%06zu:vtd_inv_desc_cc_domain context invalidate domain 0x%x
vtd_inv_desc_cc_domain context invalidate domain 0x%x
%s: invalid cc inv desc: hi=%lx, lo=%lx (invalid type)
%s: invalid iotlb inv desc: hi=0x%lx, lo=0x%lx (am=%u > VTD_MAMV=%u)
%s: invalid iotlb inv desc: hi=0x%lx, lo=0x%lx (type mismatch: 0x%llx)
%s: invalid piotlb inv desc: hi=0x%lx, lo=0x%lx (type mismatch: 0x%llx)
!(inv_desc->lo & VTD_INV_DESC_WAIT_IF)
%d@%zu.%06zu:vtd_inv_desc_wait_sw wait invalidate status write addr 0x%lx data 0x%x
vtd_inv_desc_wait_sw wait invalidate status write addr 0x%lx data 0x%x
%d@%zu.%06zu:vtd_inv_desc_wait_write_fail write fail for wait desc hi 0x%lx lo 0x%lx
vtd_inv_desc_wait_write_fail write fail for wait desc hi 0x%lx lo 0x%lx
%d@%zu.%06zu:vtd_inv_desc_wait_irq %s
IM in IECTL_REG is set, new event not generated
%s: invalid wait desc: hi=%lx, lo=%lx (unknown type)
%d@%zu.%06zu:vtd_inv_desc_iec granularity 0x%x index 0x%x mask 0x%x
vtd_inv_desc_iec granularity 0x%x index 0x%x mask 0x%x
%s: invalid inv desc: hi=%lx, lo=%lx (unknown type)
%d@%zu.%06zu:vtd_reg_write addr 0x%lx size 0x%lx value 0x%lx
vtd_reg_write addr 0x%lx size 0x%lx value 0x%lx
%d@%zu.%06zu:vtd_reg_write_gcmd status 0x%x value 0x%x
vtd_reg_write_gcmd status 0x%x value 0x%x
%d@%zu.%06zu:vtd_dmar_enable enable %d
%d@%zu.%06zu:vtd_reg_dmar_root addr 0x%lx scalable %d
vtd_reg_dmar_root addr 0x%lx scalable %d
%d@%zu.%06zu:vtd_inv_qi_enable enabled %d
%d@%zu.%06zu:vtd_inv_qi_setup addr 0x%lx size %d
vtd_inv_qi_setup addr 0x%lx size %d
%d@%zu.%06zu:vtd_warn_invalid_qi_tail tail 0x%x
vtd_warn_invalid_qi_tail tail 0x%x
%s: detected improper state when disable QI (head=0x%x, tail=0x%x, last_type=%d)
%d@%zu.%06zu:vtd_reg_ir_root addr 0x%lx size 0x%x
vtd_reg_ir_root addr 0x%lx size 0x%x
%d@%zu.%06zu:vtd_ir_enable enable %d
%d@%zu.%06zu:vtd_fsts_clear_ip 
%d@%zu.%06zu:vtd_reg_write_fectl value 0x%x
vtd_reg_write_fectl value 0x%x
%d@%zu.%06zu:vtd_inv_qi_tail write tail %d
vtd_inv_qi_tail write tail %d
%d@%zu.%06zu:vtd_reg_ics_clear_ip 
%d@%zu.%06zu:vtd_reg_write_iectl value 0x%x
vtd_reg_write_iectl value 0x%x
intel-iommu-iommu-memory-region
PASID based device IOTLB is not supported
eim=on cannot be selected without intremap=on
eim=on requires support on the KVM side(X2APIC_API, first shipped in v4.7)
x-flts is only available in scalable mode
%s: supported values for aw-bits are: %d, %d
Scalable mode(flts=on): supported value for aw-bits is: %d
Need to set dma_drain for scalable mode
Need to set scalable mode for PASID
'sgx-epc' can't be created after vCPUs,e.g. via -device
kernel does not support SGX_IOC_VEPC_REMOVE_ALL
SGX might operate incorrectly in the guest after reset
SGX is only supported on PC machines
No EPC regions defined, SGX not available
Size of all 'sgx-epc' =0x%lx causes EPC to wrap
Invalid boot device for PC: '%c'
Maximum ram below the 4G boundary (32bit boundary)
Enable/disable system management bus
Enable/disable high precision event timer emulation
Enable/disable Intel 8042 PS/2 controller emulation
Maximum combined firmware size
SMBIOS Entry Point type [32, 64]
Device assignment is not allowed without enabling caching-mode=on for Intel IOMMU.
/home/virus/AMD/AMD/include/hw/i386/sgx-epc.h
sgx_epc != NULL && sgx_epc->base >= 0x100000000ULL
User specified max allowed firmware size %lu is greater than 16MiB. If combined firmware size exceeds 16MiB the system may not boot, or experience intermittentstability issues.
Machine option 'max-ram-below-4g=%lu' expects size less than or equal to 4G
Only %lu bytes of RAM below the 4GiB boundary,BIOS may not work with less than 1MiB
multiple floppy disk controllers with iobase=0x3f0 have been found
the one being picked for CMOS setup might not reflect your intent
memory hotplug is not enabled: missing acpi device or acpi disabled
nvdimm device hot unplug is not supported yet.
/home/virus/AMD/AMD/include/hw/virtio/virtio-md-pci.h
nvdimm is not enabled: missing 'nvdimm' in '-M'
QEMU does not support multiple vIOMMUs for x86 yet.
MACHINE(pcms)->kernel_filename != NULL
!strcmp(option_rom[i].name, "linuxboot.bin") || !strcmp(option_rom[i].name, "linuxboot_dma.bin") || !strcmp(option_rom[i].name, "pvh.bin") || !strcmp(option_rom[i].name, "multiboot.bin") || !strcmp(option_rom[i].name, "multiboot_dma.bin")
machine->ram_size == x86ms->below_4g_mem_size + x86ms->above_4g_mem_size
Address space limit 0x%lx < 0x%lx phys-bits too low (%u)
"-memory 'slots|maxmem'" is not supported by: %s
unsupported amount of memory slots: %lu
maximum memory size must by aligned to multiple of %d bytes
unsupported amount of maximum memory: %lx
vmport requires the i8042 controller to be enabled
maximum number of ISA NE2000 devices exceeded
Skylake-Server-IBRS-x86_64-cpu
Skylake-Client-IBRS-x86_64-cpu
PC_MACHINE_GET_CLASS(pcms)->pci_enabled
failed to locate and/or save reset vector
pflash with kvm requires KVM readonly memory support
can't get size of block device %s: %s
system firmware block device %s has invalid size %ld
its size must be a non-zero multiple of 0x%x
combined size of system firmware exceeds %lu bytes
/home/virus/AMD/AMD/include/hw/hyperv/vmbus-bridge.h
/home/virus/AMD/AMD/hw/i386/amd_iommu.h
%d@%zu.%06zu:port92_read port92: read 0x%02x
port92_read port92: read 0x%02x
%d@%zu.%06zu:port92_write port92: write 0x%02x
port92_write port92: write 0x%02x
96b582de-1fb2-45f7-baea-a366c55a082d
OVMF table has invalid size %d
time.tsc_timestamp <= migration_tsc
KVM: injection failed, MSI lost (%s)
KVM: setting VAPIC address failed (%s)
kvm_apic_get_reg(kapic, 0x2) == s->initial_apic_id
Create kernel PIC irqchip failed: %s
Can't disable in-kernel PIT reinjection: %s
Lost tick policy not supported.
Xen overlay page support is for Xen emulation
Failed to unbind kernel port %d: %s
Inconsistent state for interdomain unbind
%d@%zu.%06zu:kvm_xen_bind_pirq pirq %d port %d
kvm_xen_bind_pirq pirq %d port %d
%d@%zu.%06zu:kvm_xen_unmask_pirq pirq %d dev %s vector %d
kvm_xen_unmask_pirq pirq %d dev %s vector %d
xc->be_port == interdomain->remote_port
%d@%zu.%06zu:kvm_xen_map_pirq pirq %d gsi %d
kvm_xen_map_pirq pirq %d gsi %d
%d@%zu.%06zu:kvm_xen_unmap_pirq pirq %d gsi %d
kvm_xen_unmap_pirq pirq %d gsi %d
%d@%zu.%06zu:kvm_xen_get_free_pirq pirq %d type %d
kvm_xen_get_free_pirq pirq %d type %d
Xen event channel emulation not enabled
Xen shared info page not allocated
Xen grant table support is for Xen emulation
%d@%zu.%06zu:xenstore_watch_event path %s token %s
xenstore_watch_event path %s token %s
rsp->len + len < XENSTORE_PAYLOAD_MAX
%d@%zu.%06zu:xenstore_error req %u tx %u err %s
xenstore_error req %u tx %u err %s
%d@%zu.%06zu:xenstore_mkdir tx %u path %s
%d@%zu.%06zu:xenstore_read tx %u path %s
%d@%zu.%06zu:xenstore_write tx %u path %s
%d@%zu.%06zu:xenstore_directory tx %u path %s
xenstore_directory tx %u path %s
Xen xenstore support is for Xen emulation
Xenstore evtchn port init failed
control/platform-feature-xs_reset_watches
control/platform-feature-multiprocessor-suspend
%d@%zu.%06zu:xenstore_directory_part tx %u path %s offset %u
xenstore_directory_part tx %u path %s offset %u
%d@%zu.%06zu:xenstore_transaction_start new_tx %u
xenstore_transaction_start new_tx %u
%d@%zu.%06zu:xenstore_get_perms tx %u path %s
xenstore_get_perms tx %u path %s
s->rsp_offset < XENSTORE_HEADER_SIZE + rsp->len
%d@%zu.%06zu:xenstore_unwatch path %s token %s
xenstore_unwatch path %s token %s
%d@%zu.%06zu:xenstore_watch path %s token %s
xenstore_watch path %s token %s
%d@%zu.%06zu:xenstore_rm tx %u path %s
%d@%zu.%06zu:xenstore_set_perms tx %u path %s
xenstore_set_perms tx %u path %s
%d@%zu.%06zu:xenstore_reset_watches 
%d@%zu.%06zu:xenstore_transaction_end tx %u commit %d
xenstore_transaction_end tx %u commit %d
../hw/i386/kvm/xen_primary_console.c
Xen primary console support is for Xen emulation
%d@%zu.%06zu:xen_primary_console_create 
%d@%zu.%06zu:xen_primary_console_reset port %u
xen_primary_console_reset port %u
abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-/_
../hw/i386/kvm/xenstore_impl.c
strlen(op->path) > w->rel_prefix
key_len + path_len + 2 <= sizeof(op->path)
unit || idedev == idebus->master
xen-platform device requires a Xen guest
%d@%zu.%06zu:xen_platform_log xen platform: %s
xen_platform_log xen platform: %s
feature_word_info[w].type == CPUID_FEATURE_WORD
g_str_has_suffix(class_name, X86_CPU_TYPE_SUFFIX)
Ambiguous CPU model string. Don't mix both "+%s" and "%s=%s"
Ambiguous CPU model string. Don't mix both "-%s" and "%s=%s"
Compatibility of ambiguous CPU model strings won't be kept on future QEMU versions
f->type == CPUID_FEATURE_WORD || f->type == MSR_FEATURE_WORD
bitnr < 32 || !(name && feature_word_info[w].type == CPUID_FEATURE_WORD)
base CPU model type with no features enabled
Enables all features supported by the accelerator in the current host
!(def->features[FEAT_8000_0001_EDX] & CPUID_EXT2_AMD_ALIASES)
def->model_id && strlen(def->model_id) <= 48
parameter '%s' can be at most %ld
parameter '%s' can be at most %lu
value of property 'vendor' must consist of exactly 12 characters
cache->size == cache->line_size * cache->associativity * cache->partitions * cache->sets
cache->associativity < cache->sets
host doesn't support requested feature
TCG doesn't support requested feature
%s: avx10.%d. Adjust to avx10.%d
This feature depends on other features that were not requested
Intel PT need CPUID leaf 0x14, please set by "-cpu ...,intel-pt=on,min-level=0x14"
Host doesn't support requested features
TCG doesn't support requested features
apic-id property was not initialized properly
hv-vendor-id truncated to 12 characters
vPMU: LBR is unsupported without pmu=on
vPMU: the lbr-fmt value (0x%x) does not match the host value (0x%x).
CPU model '%s' requires KVM or HVF
This family of AMD CPU doesn't support hyperthreading(%d). Please configure -smp options properly or try enabling topoext feature.
phys-bits should be between 32 and %u  (but is %u)
guest-phys-bits should be between 32 and %u  (but is %u)
phys-bits is not user-configurable in 32 bit
guest-phys-bits is not user-configurable in 32 bit
CPU model '%s' doesn't support legacy-cache=off
count <= CPU_TOPOLOGY_LEVEL_SOCKET
 CPU
AMD Phenom(tm) 9550 Quad-Core Processor
Intel(R) Core(TM)2 Duo CPU     T7700  @ 2.40GHz
Genuine Intel(R) CPU           T2600  @ 2.16GHz
Intel(R) Atom(TM) CPU N270   @ 1.60GHz
Intel Celeron_4x0 (Conroe/Merom Class Core 2)
Intel Core 2 Duo P9xxx (Penryn Class Core 2)
Intel Core i7 9xx (Nehalem Class Core i7)
Westmere E56xx/L56xx/X56xx (Nehalem-C)
Intel Xeon E312xx (Sandy Bridge)
Intel Xeon E3-12xx v2 (Ivy Bridge)
Intel Core Processor (Haswell)
Intel Core Processor (Broadwell)
Intel Core Processor (Skylake)
Intel Xeon Processor (Skylake)
Intel Xeon Processor (Cascadelake)
Intel Xeon Processor (Cooperlake)
Intel Xeon Processor (Icelake)
Intel Xeon Processor (SapphireRapids)
Intel Xeon Processor (GraniteRapids)
Intel Xeon Processor (SierraForest)
Intel Xeon Processor (ClearwaterForest)
Intel Atom Processor (Denverton)
Intel Atom Processor (SnowRidge)
Intel Xeon Phi Processor (Knights Mill)
AMD Opteron 240 (Gen 1 Class Opteron)
AMD Opteron 22xx (Gen 2 Class Opteron)
AMD Opteron 23xx (Gen 3 Class Opteron)
AMD Ryzen 5 2600 Six-Core Processor
AMD EPYC-Rome-v4 Processor (no XSAVES)
AMD EPYC Processor (with IBPB)
no split lock detect, no core-capability
Intel Atom Processor (Snowridge, no MPX)
ARCH_CAPABILITIES, EPT switching, no TSX
ARCH_CAPABILITIES, EPT switching, XSAVES, no TSX
IBRS, XSAVES, EPT switching, no TSX
Intel Xeon Processor (Skylake, IBRS, no TSX)
Intel Xeon Processor (Skylake, IBRS)
Intel Core Processor (Skylake, IBRS, no TSX)
Intel Core Processor (Skylake, IBRS)
Intel Core Processor (Broadwell, no TSX, IBRS)
Intel Core Processor (Broadwell, IBRS)
Intel Core Processor (Broadwell, no TSX)
Intel Core Processor (Haswell, no TSX, IBRS)
Intel Core Processor (Haswell, IBRS)
Intel Core Processor (Haswell, no TSX)
Intel Xeon E3-12xx v2 (Ivy Bridge, IBRS)
Intel Xeon E312xx (Sandy Bridge, IBRS update)
Westmere E56xx/L56xx/X56xx (IBRS update)
Intel Core i7 9xx (Nehalem Core i7, IBRS update)
vmx-exit-load-perf-global-ctrl
vmx-exit-save-preemption-timer
vmx-entry-load-perf-global-ctrl
vmx-invept-single-context-noglobals
CPU %d: Uncorrected error reporting disabled
CPU %d: Uncorrected error reporting disabled for bank %d
CPU %d: MCE capability is not enabled, raising triple fault
CPU %d: Previous MCE still in progress, raising triple fault
Guest CPU does not support MCA broadcast
%s	 0x%08x %s %-5s %-6s %-7s %-12s %-6s
local apic state not available
dumping local APIC state for CPU %-2u
Timer	 DCR=0x%x (divide by %u) initial_count = %u current_count = %u
SPIV	 0x%08x APIC %s, focus=%s, spurious vec %u
 cluster %u mask %s (X2APIC ID)
 cluster %u mask %s (APIC ID)
APR 0x%02x TPR 0x%02x DFR 0x%02x LDR 0x%02x
RAX=%016lx RBX=%016lx RCX=%016lx RDX=%016lx
RSI=%016lx RDI=%016lx RBP=%016lx RSP=%016lx
R8 =%016lx R9 =%016lx R10=%016lx R11=%016lx
R12=%016lx R13=%016lx R14=%016lx R15=%016lx
RIP=%016lx RFL=%08x [%c%c%c%c%c%c%c] CPL=%d II=%d A20=%d SMM=%d HLT=%d
EAX=%08x EBX=%08x ECX=%08x EDX=%08x
ESI=%08x EDI=%08x EBP=%08x ESP=%08x
EIP=%08x EFL=%08x [%c%c%c%c%c%c%c] CPL=%d II=%d A20=%d SMM=%d HLT=%d
CR0=%08x CR2=%016lx CR3=%016lx CR4=%08x
CR0=%08x CR2=%08x CR3=%08x CR4=%08x
FCW=%04x FSW=%04x [ST=%d] FTW=%02x MXCSR=%08x
ZMM%02d=%016lx %016lx %016lx %016lx %016lx %016lx %016lx %016lx
YMM%02d=%016lx %016lx %016lx %016lx
processor with all supported host features 
Host physical bits (%u) does not match phys-bits property (%u)
size > 0 && size <= TARGET_PAGE_SIZE
op >= CC_OP_FIRST_BWLQ && op <= CC_OP_LAST_BWLQ
check_exception old: 0x%x new 0x%x
%6d: v=%02x e=%04x i=%d cpl=%d IP=%04x:%016lx pc=%016lx SP=%04x:%016lx
../target/i386/tcg/seg_helper.c
../target/i386/tcg/decode-new.c.inc
../target/i386/tcg/translate.c
op->unit == X86_OP_MMX || op->unit == X86_OP_SSE
(decode->mem.index) >= 0 && (decode->mem.index) <= 15
decode->op[2].unit == X86_OP_INT && decode->op[2].ot != MO_8
op >= 0 && op < ARRAY_SIZE(cc_op_live_)
!!mmx == !!(decode->e.special == X86_SPECIAL_MMX)
e->op3 == X86_TYPE_I && e->s3 == X86_SIZE_b
decode.op[0].unit == X86_OP_INT
decode.op[2].unit == X86_OP_INT
decode.op[1].unit == X86_OP_INT
e->vex_class == 1 || e->vex_class == 2 || e->vex_class == 4
decode.op[0].has_ea && !decode.op[2].has_ea
!!decode.cc_dst == !!(cc_live & USES_CC_DST)
!!decode.cc_src == !!(cc_live & USES_CC_SRC)
!!decode.cc_src2 == !!(cc_live & USES_CC_SRC2)
dc->cc_op_dirty == orig_cc_op_dirty
Failed to encode VirtFS reply type %d
The guest sent a VirtFS request without space for the reply
The guest sent a malformed VirtFS request: header size is %zd, should be 7
VirtFS request type %d needs %zu bytes, buffer has %zu
VirtFS reply type %d needs %zu bytes, buffer has %zu
Failed to decode VirtFS request type %d
/home/virus/AMD/AMD/include/hw/virtio/virtio-blk.h
Invalid virtqueue index in request list: %#x
virtio-blk failed to set guest notifier (%d), ensure -accel kvm is set.
virtio-blk failed to set host notifier (%d)
num-queues property must be larger than 0
invalid queue-size property (%u), must be > 2
invalid queue-size property (%u), must be a power of 2 (max %d)
invalid max-discard-sectors property (%u), must be between 1 and %d
invalid max-write-zeroes-sectors property (%u), must be between 1 and %d
%d@%zu.%06zu:virtio_blk_submit_multireq vdev %p mrb %p start %d num_reqs %d offset %lu size %zu is_write %d
virtio_blk_submit_multireq vdev %p mrb %p start %d num_reqs %d offset %lu size %zu is_write %d
%d@%zu.%06zu:virtio_blk_req_complete vdev %p req %p status %d
virtio_blk_req_complete vdev %p req %p status %d
%d@%zu.%06zu:virtio_blk_zone_report_complete vdev %p req %p nr_zones %u ret %d
virtio_blk_zone_report_complete vdev %p req %p nr_zones %u ret %d
Driver provided input buffer that is too small!
Driver provided input buffer for descriptors that is too small!
%d@%zu.%06zu:virtio_blk_zone_mgmt_complete vdev %p req %p ret %d
virtio_blk_zone_mgmt_complete vdev %p req %p ret %d
Driver provided input buffer less than size of append_sector
%d@%zu.%06zu:virtio_blk_zone_append_complete vdev %p req %p, append sector 0x%lx ret %d
virtio_blk_zone_append_complete vdev %p req %p, append sector 0x%lx ret %d
%d@%zu.%06zu:virtio_blk_rw_complete vdev %p req %p ret %d
virtio_blk_rw_complete vdev %p req %p ret %d
%d@%zu.%06zu:virtio_blk_handle_zone_reset_all vdev %p req %p sector 0x%lx cap 0x%lx
virtio_blk_handle_zone_reset_all vdev %p req %p sector 0x%lx cap 0x%lx
%d@%zu.%06zu:virtio_blk_handle_zone_mgmt vdev %p req %p op 0x%x sector 0x%lx len 0x%lx
virtio_blk_handle_zone_mgmt vdev %p req %p op 0x%x sector 0x%lx len 0x%lx
virtio-blk request outhdr too short
virtio-blk request inhdr too short
%d@%zu.%06zu:virtio_blk_handle_write vdev %p req %p sector %lu nsectors %zu
virtio_blk_handle_write vdev %p req %p sector %lu nsectors %zu
%d@%zu.%06zu:virtio_blk_handle_read vdev %p req %p sector %lu nsectors %zu
virtio_blk_handle_read vdev %p req %p sector %lu nsectors %zu
mrb->num_reqs < VIRTIO_BLK_MAX_MERGE_REQS
in buffer too small for zone report
%d@%zu.%06zu:virtio_blk_handle_zone_report vdev %p req %p sector 0x%lx nr_zones %u
virtio_blk_handle_zone_report vdev %p req %p sector 0x%lx nr_zones %u
%d@%zu.%06zu:virtio_blk_handle_zone_append vdev %p req %p, append sector 0x%lx
virtio_blk_handle_zone_append vdev %p req %p, append sector 0x%lx
virtio-blk discard/write_zeroes header too short
/home/virus/AMD/AMD/include/hw/virtio/vhost-user-blk.h
vhost-user-blk: vhost start failed: 
error: write req for ro device
error: access beyond end of file
../hw/block/dataplane/xen-block.c
%*sport %d, guest %s, host %s, throttle %s
Maximum number of serial ports not specified
../hw/char/virtio-serial-bus.c
%d@%zu.%06zu:virtio_serial_send_control_event port %u, event %u, value %u
virtio_serial_send_control_event port %u, event %u, value %u
%d@%zu.%06zu:virtio_serial_handle_control_message event %u, value %u
virtio_serial_handle_control_message event %u, value %u
virtio-serial-bus: Guest failure in adding device %s
virtio-serial-bus: Unexpected port id %u for device %s
%d@%zu.%06zu:virtio_serial_handle_control_message_port port %u
virtio_serial_handle_control_message_port port %u
virtio-serial-bus: Guest failure in adding port %u for device %s
virtio-serial-bus: Maximum port limit for this device reached
virtio-serial-bus: Out-of-range port id specified, max. allowed: %u
virtio-serial-bus: A port already exists by name %s
virtio-serial-bus: A port already exists at id %u
%d@%zu.%06zu:virtio_serial_throttle_port port %u, throttle %d
virtio_serial_throttle_port port %u, throttle %d
staged_msg->state == HV_STAGED_MSG_BUSY
QLIST_EMPTY(&synic->sint_routes)
hyperv_vp_index(cs) == vp_index
Hyper-V event signaling is not supported by this kernel; using slower userspace hypercall processing
msg->payload_size < sizeof(conn->msg.payload)
!hyperv_post_msg(conn->sint_route, &conn->msg)
!hyperv_set_event_flag(conn->sint_route, conn->conn_id)
!hyperv_set_msg_handler(conn->conn_id, msg_handler, conn)
!event_notifier_init(&conn->notifier, false)
!hyperv_set_event_flag_handler(conn_id, &conn->notifier)
%d@%zu.%06zu:vmbus_signal_event 
map_start_in_page < io_end_in_page
%d@%zu.%06zu:vmbus_recv_message type %d size %d
vmbus_recv_message type %d size %d
vmbus: unknown message type %#x
vmbus->state < VMBUS_STATE_MAX
state_runner[vmbus->state].run
%d@%zu.%06zu:vmbus_channel_notify_guest channel #%d
vmbus_channel_notify_guest channel #%d
/home/virus/AMD/AMD/include/hw/hyperv/vmbus.h
hyperv set message handler failed: %d
event notifier failed to init with %d
hyperv set event handler failed with %d
%d@%zu.%06zu:vmbus_post_msg type %d size %d
vmbus_post_msg type %d size %d
message delivery fatal failure: %d; aborting vmbus
%d@%zu.%06zu:vmbus_gpadl_torndown gpadl #%d
vmbus_gpadl_torndown gpadl #%d
%d@%zu.%06zu:vmbus_gpadl_created gpadl #%d
vmbus_gpadl_created gpadl #%d
%d@%zu.%06zu:vmbus_send_offer channel #%d dev %p
vmbus_send_offer channel #%d dev %p
%d@%zu.%06zu:vmbus_terminate_offers 
%d@%zu.%06zu:vmbus_channel_open channel #%d status %d
vmbus_channel_open channel #%d status %d
there can be at most one %s in the system
VMBus requires usable Hyper-V SynIC and VP_INDEX
VMBus enabled without the recommended set of Hyper-V features: hv-stimer, hv-vapic and hv-runtime. Some Windows versions might not boot or enable the VMBus device
%d@%zu.%06zu:vmbus_msg_cb message status %d
vmbus_msg_cb message status %d
!qemu_uuid_is_null(&vdev->instanceid)
duplicate vmbus device instance id %s
%d@%zu.%06zu:vmbus_process_incoming_message type %d
vmbus_process_incoming_message type %d
%d@%zu.%06zu:vmbus_initiate_contact version %d.%d target vp %d mon pages 0x%lx,0x%lx int page 0x%lx
vmbus_initiate_contact version %d.%d target vp %d mon pages 0x%lx,0x%lx int page 0x%lx
failed to init vmbus; aborting
%d@%zu.%06zu:vmbus_gpadl_header gpadl #%d gfns %d
vmbus_gpadl_header gpadl #%d gfns %d
%d@%zu.%06zu:vmbus_gpadl_body gpadl #%d
%d@%zu.%06zu:vmbus_gpadl_teardown gpadl #%d
vmbus_gpadl_teardown gpadl #%d
%d@%zu.%06zu:vmbus_open_channel channel #%d gpadl #%d target vp %d
vmbus_open_channel channel #%d gpadl #%d target vp %d
%d@%zu.%06zu:vmbus_close_channel channel #%d
vmbus_close_channel channel #%d
%s: failed to convert GPA ranges to SGL
vmbus/hyperv_post_message_input
%s device requires vmbus-bridge device
%s failed to resolve host name %s
%s failed to connect to socket
%d@%zu.%06zu:hv_balloon_remove_response processing remove response range %lu @ 0x%lx, both %u
hv_balloon_remove_response processing remove response range %lu @ 0x%lx, both %u
%d@%zu.%06zu:hv_balloon_remove_response_hole response range hole %lu @ 0x%lx from range %lu @ 0x%lx, before our start 0x%lx, both %u
hv_balloon_remove_response_hole response range hole %lu @ 0x%lx from range %lu @ 0x%lx, before our start 0x%lx, both %u
%d@%zu.%06zu:hv_balloon_remove_response_common response common range %lu @ 0x%lx from range %lu @ 0x%lx with our %lu @ 0x%lx, removed %lu, both %u
hv_balloon_remove_response_common response common range %lu @ 0x%lx from range %lu @ 0x%lx with our %lu @ 0x%lx, removed %lu, both %u
%d@%zu.%06zu:hv_balloon_remove_response_remainder remove response remaining range %lu @ 0x%lx, both %u
hv_balloon_remove_response_remainder remove response remaining range %lu @ 0x%lx, both %u
guest reported removed page backed by unsupported page size %zu
guest reported removed page failed discard
/home/virus/AMD/AMD/include/hw/hyperv/hv-balloon.h
Only one balloon device is supported
'%s' property specifies a busy memdev: %s
'%s' property memdev size has to be a multiple of 0x%lx
'%s' property must not be set without a memdev
525074DC-8985-46e2-8057-A307DC18A502
balloon->state == S_BALLOON_RB_WAIT
balloon->state == S_HOT_ADD_RB_WAIT
balloon->state == S_UNBALLOON_RB_WAIT
balloon->state == S_BALLOON_POSTING
%d@%zu.%06zu:hv_balloon_outgoing_balloon posting balloon %u for %lu, remaining %lu
hv_balloon_outgoing_balloon posting balloon %u for %lu, remaining %lu
error %zd when posting balloon msg, expect problems
balloon->state == S_HOT_ADD_POSTING
%d@%zu.%06zu:hv_balloon_outgoing_hot_add posting hot add %u for %lu @ 0x%lx
hv_balloon_outgoing_hot_add posting hot add %u for %lu @ 0x%lx
error %zd when posting hot add msg, expect problems
balloon->state == S_HOT_ADD_SETUP
QEMU_IS_ALIGNED(balloon->addr, align)
some parts of the memory backend were already returned by the guest. this should not happen, please reboot the guest and try again
%d@%zu.%06zu:hv_balloon_our_range_add adding our range %lu @ 0x%lx
hv_balloon_our_range_add adding our range %lu @ 0x%lx
QEMU_IS_ALIGNED(hot_add_range->start, align)
balloon->state == S_UNBALLOON_POSTING
trying to unballoon but nothing seems to be ballooned
balloon->our_range || !our_range
%d@%zu.%06zu:hv_balloon_outgoing_unballoon posting unballoon %u for %lu @ 0x%lx, remaining %lu
hv_balloon_outgoing_unballoon posting unballoon %u for %lu @ 0x%lx, remaining %lu
error %zd when posting unballoon msg, expect problems
%d@%zu.%06zu:hv_balloon_state_change -> %s
hv_balloon_state_change -> %s
unexpected DM_VERSION_REQUEST in %d state
%d@%zu.%06zu:hv_balloon_incoming_version incoming proto version %u.%u
hv_balloon_incoming_version incoming proto version %u.%u
%s message too short (%u vs %zu), ignoring
unexpected DM_CAPABILITIES_REPORT in %d state
%d@%zu.%06zu:hv_balloon_incoming_caps incoming caps 0x%x
hv_balloon_incoming_caps incoming caps 0x%x
unexpected DM_HOT_ADD_RESPONSE in %d state
%d@%zu.%06zu:hv_balloon_incoming_hot_add incoming hot add response %u, result %u, count %u
hv_balloon_incoming_hot_add incoming hot add response %u, result %u, count %u
DM_HOT_ADD_RESPONSE page count higher than requested (%u vs %lu)
unexpected DM_UNBALLOON_RESPONSE in %d state
%d@%zu.%06zu:hv_balloon_incoming_unballoon incoming unballoon response %u
hv_balloon_incoming_unballoon incoming unballoon response %u
unexpected DM_BALLOON_RESPONSE in %d state
%d@%zu.%06zu:hv_balloon_incoming_balloon incoming balloon response %u, ranges %u, more %u
hv_balloon_incoming_balloon incoming balloon response %u, ranges %u, more %u
DM_BALLOON_RESPONSE too short for the range count
guest reported removed page %lu not found in RAM
guest reported removed page %lu in a section smaller than page size
guest reported removed pages at an unaligned host addr %p
guest reported removed page %lu in a section that is not an ordinary RAM
guest reported more pages removed than currently pending (%lu vs %lu)
guest trying to open a DM channel in invalid %d state
guest memory status reporting not enabled
no guest memory status report received yet
../hw/hyperv/hv-balloon-page_range_tree.c
!SUM_OVERFLOW_U64(start, count)
../hw/hyperv/hv-balloon-our_range_memslots.c
additional_size <= UINT64_MAX - our_range->added
our_range->added <= UINT64_MAX - our_range->unusable_tail
our_range->added + our_range->unusable_tail <= our_range->range.count
%d@%zu.%06zu:hv_balloon_unmap_slot unmapping memslot %u / %u @ 0x%lx
hv_balloon_unmap_slot unmapping memslot %u / %u @ 0x%lx
memory_region_is_mapped(&memslots->slots[idx])
%d@%zu.%06zu:hv_balloon_map_slot mapping memslot %u / %u @ 0x%lx
hv_balloon_map_slot mapping memslot %u / %u @ 0x%lx
!memory_region_is_mapped(&memslots->slots[idx])
Userspace local APIC is deprecated for KVM.
Do not use kernel-irqchip except for the -M isapc machine type.
%d@%zu.%06zu:apic_register_read register 0x%02x = 0x%lx
apic_register_read register 0x%02x = 0x%lx
%d@%zu.%06zu:apic_local_deliver vector %d delivery mode %d
apic_local_deliver vector %d delivery mode %d
%d@%zu.%06zu:apic_deliver_irq dest %d dest_mode %d delivery_mode %d vector %d trigger_mode %d
apic_deliver_irq dest %d dest_mode %d delivery_mode %d vector %d trigger_mode %d
%d@%zu.%06zu:apic_register_write register 0x%02x = 0x%lx
apic_register_write register 0x%02x = 0x%lx
APIC ID %d requires x2APIC feature in CPU
%d@%zu.%06zu:cpu_set_apic_base 0x%016lx
%d@%zu.%06zu:cpu_get_apic_base 0x%016lx
%d@%zu.%06zu:ioapic_mem_read ioapic mem read addr 0x%x regsel: 0x%x size 0x%x retval 0x%x
ioapic_mem_read ioapic mem read addr 0x%x regsel: 0x%x size 0x%x retval 0x%x
%d@%zu.%06zu:ioapic_set_remote_irr set remote irr for pin %d
ioapic_set_remote_irr set remote irr for pin %d
%d@%zu.%06zu:ioapic_set_irq vector: %d level: %d
ioapic_set_irq vector: %d level: %d
IOAPIC only supports version 0x11 or 0x20 (default: 0x%x).
%d@%zu.%06zu:ioapic_eoi_broadcast EOI broadcast for vector %d
ioapic_eoi_broadcast EOI broadcast for vector %d
%d@%zu.%06zu:ioapic_clear_remote_irr clear remote irr for pin %d vector %d
ioapic_clear_remote_irr clear remote irr for pin %d vector %d
%d@%zu.%06zu:ioapic_eoi_delayed_reassert delayed reassert on EOI broadcast for vector %d
ioapic_eoi_delayed_reassert delayed reassert on EOI broadcast for vector %d
%d@%zu.%06zu:ioapic_mem_write ioapic mem write addr 0x%x regsel: 0x%x size 0x%x val 0x%x
ioapic_mem_write ioapic mem write addr 0x%x regsel: 0x%x size 0x%x val 0x%x
%d@%zu.%06zu:ich9_cc_read addr=0x%lx val=0x%lx len=%u
ich9_cc_read addr=0x%lx val=0x%lx len=%u
ICH9 LPC: SCI IRQ SEL #%u is reserved
%d@%zu.%06zu:ich9_cc_write addr=0x%lx val=0x%lx len=%u
ich9_cc_write addr=0x%lx val=0x%lx len=%u
cpu hot-unplug requires cpu hot-plug
%d@%zu.%06zu:virtio_net_rss_attach_ebpf nic=%p prog-fd=%d
virtio_net_rss_attach_ebpf nic=%p prog-fd=%d
Device with failover_pair_id needs to have id
Cannot attach more than one primary device to '%s': '%s' and '%s'
virtio-net: saved image requires vnet_hdr=on
!virtio_net_get_subqueue(nc)->async_tx.elem
Can't load eBPF RSS - fallback to software RSS
%d@%zu.%06zu:virtio_net_rss_enable nic=%p hashes 0x%x, table of %d, key of %d
virtio_net_rss_enable nic=%p hashes 0x%x, table of %d, key of %d
%d@%zu.%06zu:virtio_net_rss_disable nic=%p
virtio_net_rss_disable nic=%p
virtio-net: saved image requires TUN_F_UFO support
virtio-net: curr_queue_pairs %x > max_queue_pairs %x
couldn't unplug primary device
virtio_net: couldn't find primary bus
unable to restart vhost net virtqueue: %d, when resetting the queue
Error getting vhost back-end of %s device %s: 
Error saving back-end state of %s device %s: 
Error loading  back-end state of %s device %s: 
Zero hardware mac address detected. Ignoring.
%d@%zu.%06zu:virtio_net_announce_timer %d
%d@%zu.%06zu:virtio_net_announce_notify 
Virtio-net failover will not work. Make sure primary device has parameter failover_pair_id=%s
backend does not support %s vnet headers; falling back on userspace virtio
%uBytes MTU not supported by the backend
unable to start vhost net: %d: falling back on userspace virtio
virtio-net header not in first element
n->host_hdr_len <= n->guest_hdr_len
'duplex' must be 'half' or 'full'
'speed' must be between 0 and INT_MAX
Invalid rx_queue_size (= %u), must be a power of 2 between %d and %d.
Invalid tx_queue_size (= %u), must be a power of 2 between %d and %d
Invalid number of queue pairs (= %u), must be a positive integer less than %d.
virtio-net: Unknown option tx=%s, valid options: "timer" "bh"
%d@%zu.%06zu:virtio_net_rss_load nic=%p nfds=%zu fds=%p
virtio_net_rss_load nic=%p nfds=%zu fds=%p
Expected %d file descriptors but got %d
%d@%zu.%06zu:virtio_net_post_load_device 
virtio-net unexpected long buffer chain
virtio-net unexpected empty queue: i %zd mergeable %d offset %zd, size %zd, guest hdr len %zd, host hdr len %zd guest features 0x%lx
virtio-net receive queue contains no in buffers
Invalid size of indirection table
Can't allocate indirections table
Short indirection table buffer
%d@%zu.%06zu:virtio_net_rss_error nic=%p msg=%s, value 0x%08x
virtio_net_rss_error nic=%p msg=%s, value 0x%08x
virtio-net ctrl missing headers
%d@%zu.%06zu:virtio_net_handle_announce %d
virtio_net_handle_announce %d
virtio-net vhost-user backend state
bad data written to virtio-scsi configuration space
wrong size for virtio-scsi headers
%d@%zu.%06zu:virtio_scsi_cmd_resp virtio_scsi_cmd_resp lun=%u tag=0x%x response=%d status=0x%x
virtio_scsi_cmd_resp virtio_scsi_cmd_resp lun=%u tag=0x%x response=%d status=0x%x
%d@%zu.%06zu:virtio_scsi_cmd_req virtio_scsi_cmd_req lun=%u tag=0x%x cmd=0x%x
virtio_scsi_cmd_req virtio_scsi_cmd_req lun=%u tag=0x%x cmd=0x%x
invalid SCSI request migration data
req->sreq->cmd.mode == req->mode
%d@%zu.%06zu:virtio_scsi_tmf_resp virtio_scsi_tmf_resp lun=%u tag=0x%x response=%d
virtio_scsi_tmf_resp virtio_scsi_tmf_resp lun=%u tag=0x%x response=%d
r->ctx == qemu_get_current_aio_context()
%d@%zu.%06zu:virtio_scsi_event virtio_scsi_event lun=%u event=%d reason=%d
virtio_scsi_event virtio_scsi_event lun=%u event=%d reason=%d
%d@%zu.%06zu:virtio_scsi_tmf_req virtio_scsi_tmf_req lun=%u tag=0x%x subtype=%d
virtio_scsi_tmf_req virtio_scsi_tmf_req lun=%u tag=0x%x subtype=%d
virtio_scsi_do_tmf_aio_context
%d@%zu.%06zu:virtio_scsi_an_req virtio_scsi_an_req lun=%u event_requested=0x%x
virtio_scsi_an_req virtio_scsi_an_req lun=%u event_requested=0x%x
%d@%zu.%06zu:virtio_scsi_an_resp virtio_scsi_an_resp lun=%u response=%d
virtio_scsi_an_resp virtio_scsi_an_resp lun=%u response=%d
invalid virtqueue_size property (= %u), must be > 2
../hw/scsi/vhost-scsi-common.c
vhost-scsi does not support changing the sense data and CDB sizes
%d@%zu.%06zu:vfio_reset_handler 
%d@%zu.%06zu:vfio_listener_region_skip SKIPPING %s 0x%lx - 0x%lx
vfio_listener_region_skip SKIPPING %s 0x%lx - 0x%lx
%d@%zu.%06zu:vfio_known_safe_misalignment Region "%s" iova=0x%lx offset_within_region=0x%lx qemu_real_host_page_size=0x%lx
vfio_known_safe_misalignment Region "%s" iova=0x%lx offset_within_region=0x%lx qemu_real_host_page_size=0x%lx
%s received unaligned region %s iova=0x%lx offset_within_region=0x%lx qemu_real_host_page_size=0x%lx
%s: vfio_container_dma_unmap() failed: %s
%s: Failed to stop DMA logging, err %d (%s)
%d@%zu.%06zu:vfio_device_dirty_tracking_start nr_ranges %d 32:[0x%lx - 0x%lx], 64:[0x%lx - 0x%lx], pci64:[0x%lx - 0x%lx]
vfio_device_dirty_tracking_start nr_ranges %d 32:[0x%lx - 0x%lx], 64:[0x%lx - 0x%lx], pci64:[0x%lx - 0x%lx]
%s: Failed to start DMA logging
%d@%zu.%06zu:vfio_device_dirty_tracking_update section 0x%lx - 0x%lx -> update [0x%lx - 0x%lx]
vfio_device_dirty_tracking_update section 0x%lx - 0x%lx -> update [0x%lx - 0x%lx]
%d@%zu.%06zu:vfio_listener_region_del_iommu region_del [iommu] %s
vfio_listener_region_del_iommu region_del [iommu] %s
%d@%zu.%06zu:vfio_listener_region_del region_del 0x%lx - 0x%lx
vfio_listener_region_del region_del 0x%lx - 0x%lx
vfio: Trying to unregister missing RAM discard listener
vfio_container_dma_unmap(%p, 0x%lx, 0x%lx) = %d (%s)
vfio: Could not start dirty page tracking - 
vfio: Could not stop dirty page tracking - 
%d@%zu.%06zu:vfio_listener_region_add_no_dma_map Region "%s" 0x%lx size=0x%lx is not aligned to 0x%lx and cannot be mapped for DMA
vfio_listener_region_add_no_dma_map Region "%s" 0x%lx size=0x%lx is not aligned to 0x%lx and cannot be mapped for DMA
%d@%zu.%06zu:vfio_listener_region_add_iommu region_add [iommu] %s 0x%lx - 0x%lx
vfio_listener_region_add_iommu region_add [iommu] %s 0x%lx - 0x%lx
QEMU_IS_ALIGNED(section->offset_within_region, target_page_size)
QEMU_IS_ALIGNED(section->offset_within_address_space, target_page_size)
QEMU_IS_ALIGNED(int128_get64(section->size), target_page_size)
vrdl->granularity && is_power_of_2(vrdl->granularity)
bcontainer->pgsizes && vrdl->granularity >= 1ULL << ctz64(bcontainer->pgsizes)
%s: possibly running out of DMA mappings. E.g., try increasing the 'block-size' of virtio-mem devies. Maximum possible DMA mappings: %d, Maximum possible memslots: %d
%d@%zu.%06zu:vfio_listener_region_add_ram region_add [ram] 0x%lx - 0x%lx [%p]
vfio_listener_region_add_ram region_add [ram] 0x%lx - 0x%lx [%p]
vfio_container_dma_map(%p, 0x%lx, 0x%lx, %p) = %d (%s)
%s: PCI peer-to-peer transactions on BARs are not supported.
vfio: DMA mapping failed, unable to continue
%d@%zu.%06zu:vfio_iommu_map_notify iommu %s @ 0x%lx - 0x%lx
vfio_iommu_map_notify iommu %s @ 0x%lx - 0x%lx
Using vfio with vIOMMUs and coordinated discarding of RAM (e.g., virtio-mem) works, however, malicious guests can trigger pinning of more memory than intended via an IOMMU. It's possible to mitigate  by setting/adjusting RLIMIT_MEMLOCK.
Multiple VFIO devices migration is supported only if all of them support P2P migration
%s: Failed to get DMA logging report, iova: 0x%lx, size: 0x%lx
Failed to allocate dirty tracking bitmap
%d@%zu.%06zu:vfio_get_dirty_bitmap iova=0x%lx size= 0x%lx bitmap_size=0x%lx start=0x%lx dirty_pages=%lu
vfio_get_dirty_bitmap iova=0x%lx size= 0x%lx bitmap_size=0x%lx start=0x%lx dirty_pages=%lu
vfio: Trying to sync missing RAM discard listener
Failed to sync dirty bitmap with RAM discard listener
%d@%zu.%06zu:vfio_iommu_map_dirty_notify iommu dirty @ 0x%lx - 0x%lx
vfio_iommu_map_dirty_notify iommu dirty @ 0x%lx - 0x%lx
vfio_iommu_map_dirty_notify(%p, 0x%lx, 0x%lx) failed - 
Failed to create KVM VFIO device
Failed to add fd %d to KVM VFIO device
KVM VFIO device isn't created yet
Failed to remove fd %d from KVM VFIO device
%d@%zu.%06zu:vfio_pci_hot_reset_dep_devices 	%04x:%02x:%02x.%x group %d
vfio_pci_hot_reset_dep_devices 	%04x:%02x:%02x.%x group %d
vfio: Cannot reset device %s, depends on group %d which is not owned.
Failed to set dirty tracking flag 0x%x
Failed to get dirty bitmap for iova: 0x%lx size: 0x%lx
UNMAP: Size of bitmap too big 0x%lx
VFIO_UNMAP_DMA with DIRTY_BITMAP : %m
%d@%zu.%06zu:vfio_legacy_dma_unmap_overflow_workaround 
vfio_legacy_dma_unmap_overflow_workaround 
vfio: error disconnecting group %d from container
%d@%zu.%06zu:vfio_disconnect_container close container->fd=%d
vfio_disconnect_container close container->fd=%d
%d@%zu.%06zu:vfio_put_group close group->fd=%d
vfio_put_group close group->fd=%d
%d@%zu.%06zu:vfio_detach_device  (%s) group %d
vfio_detach_device  (%s) group %d
%d@%zu.%06zu:vfio_put_base_device close vdev->fd=%d
vfio_put_base_device close vdev->fd=%d
%d@%zu.%06zu:vfio_attach_device  (%s) group %d
vfio_attach_device  (%s) group %d
group %d used in multiple address spaces
Please ensure all devices within the iommu_group are bound to their vfio bus driver.
supported vfio version: %d, reported version: %d
Failed to set iommu for container
failed to setup container for group %d: 
error getting device from group %d
Verify all devices in group %d are bound to vfio-<bus> or pci-stub and not already in use
Inconsistent setting of support for discarding RAM (e.g., balloon) within group
%d@%zu.%06zu:vfio_get_device Device %s flags: %u, regions: %u, irqs: %u
vfio_get_device Device %s flags: %u, regions: %u, irqs: %u
%d@%zu.%06zu:vfio_quirk_generic_window_address_write %s %s 0x%lx
vfio_quirk_generic_window_address_write %s %s 0x%lx
%d@%zu.%06zu:vfio_quirk_rtl8168_fake_latch %s 0x%lx
vfio_quirk_rtl8168_fake_latch %s 0x%lx
%d@%zu.%06zu:vfio_quirk_generic_window_data_write %s %s 0x%lx
vfio_quirk_generic_window_data_write %s %s 0x%lx
%d@%zu.%06zu:vfio_quirk_generic_mirror_write %s %s 0x%lx: 0x%lx
vfio_quirk_generic_mirror_write %s %s 0x%lx: 0x%lx
%d@%zu.%06zu:vfio_quirk_generic_window_data_read %s %s 0x%lx
vfio_quirk_generic_window_data_read %s %s 0x%lx
%d@%zu.%06zu:vfio_quirk_generic_mirror_read %s %s 0x%lx: 0x%lx
vfio_quirk_generic_mirror_read %s %s 0x%lx: 0x%lx
%d@%zu.%06zu:vfio_quirk_ati_3c3_read %s 0x%lx
vfio_quirk_ati_3c3_read %s 0x%lx
%d@%zu.%06zu:vfio_quirk_nvidia_3d0_read  (%s, @0x%x, len=0x%x) 0x%lx
vfio_quirk_nvidia_3d0_read  (%s, @0x%x, len=0x%x) 0x%lx
%d@%zu.%06zu:vfio_quirk_nvidia_bar5_state %s %s
vfio_quirk_nvidia_bar5_state %s %s
Failed to remove vfio ioeventfd for %s+0x%lx[%d]:0x%lx (%m)
%d@%zu.%06zu:vfio_ioeventfd_exit %s+0x%lx[%d]:0x%lx
vfio_ioeventfd_exit %s+0x%lx[%d]:0x%lx
%d@%zu.%06zu:vfio_quirk_rtl8168_msix_read %s MSI-X table read[0x%x]: 0x%lx
vfio_quirk_rtl8168_msix_read %s MSI-X table read[0x%x]: 0x%lx
%d@%zu.%06zu:vfio_quirk_rtl8168_msix_write %s MSI-X table write[0x%x]: 0x%lx
vfio_quirk_rtl8168_msix_write %s MSI-X table write[0x%x]: 0x%lx
%d@%zu.%06zu:vfio_quirk_ati_bonaire_reset_skipped %s
vfio_quirk_ati_bonaire_reset_skipped %s
%d@%zu.%06zu:vfio_quirk_ati_bonaire_reset_no_smc %s
vfio_quirk_ati_bonaire_reset_no_smc %s
%d@%zu.%06zu:vfio_quirk_ati_bonaire_reset_timeout %s
vfio_quirk_ati_bonaire_reset_timeout %s
%d@%zu.%06zu:vfio_quirk_ati_bonaire_reset_done %s
vfio_quirk_ati_bonaire_reset_done %s
%d@%zu.%06zu:vfio_ioeventfd_handler %s+0x%lx[%d] -> 0x%lx
vfio_ioeventfd_handler %s+0x%lx[%d] -> 0x%lx
%d@%zu.%06zu:vfio_quirk_nvidia_bar0_msi_ack %s
vfio_quirk_nvidia_bar0_msi_ack %s
%d@%zu.%06zu:vfio_ioeventfd_init %s+0x%lx[%d]:0x%lx vfio:%d
vfio_ioeventfd_init %s+0x%lx[%d]:0x%lx vfio:%d
NVIDIA ioeventfd queue full for %s, unable to accelerate 0x%lx, data 0x%lx, size %u
%d@%zu.%06zu:vfio_quirk_nvidia_3d0_state %s %s
vfio_quirk_nvidia_3d0_state %s %s
%d@%zu.%06zu:vfio_quirk_nvidia_3d0_write (%s, @0x%x, 0x%lx, len=0x%x)
vfio_quirk_nvidia_3d0_write (%s, @0x%x, 0x%lx, len=0x%x)
%d@%zu.%06zu:vfio_quirk_rom_in_denylist %s %04x:%04x
vfio_quirk_rom_in_denylist %s %04x:%04x
%d@%zu.%06zu:vfio_quirk_ati_3c3_probe %s
%d@%zu.%06zu:vfio_quirk_nvidia_3d0_probe %s
vfio_quirk_nvidia_3d0_probe %s
vfio-ati-bar4-window-address-quirk
vfio-ati-bar4-window-data-quirk
%d@%zu.%06zu:vfio_quirk_ati_bar4_probe %s
%d@%zu.%06zu:vfio_quirk_ati_bar2_probe %s
vfio-nvidia-bar5-window-address-quirk
vfio-nvidia-bar5-window-data-quirk
%d@%zu.%06zu:vfio_quirk_nvidia_bar5_probe %s
vfio_quirk_nvidia_bar5_probe %s
vfio-nvidia-bar0-88000-mirror-quirk
vfio-nvidia-bar0-1800-mirror-quirk
%d@%zu.%06zu:vfio_quirk_nvidia_bar0_probe %s
vfio_quirk_nvidia_bar0_probe %s
vfio-rtl8168-window-address-quirk
vfio-rtl8168-window-data-quirk
%d@%zu.%06zu:vfio_quirk_rtl8168_probe %s
%d@%zu.%06zu:vfio_quirk_ati_bonaire_reset %s
vfio_quirk_ati_bonaire_reset %s
NVIDIA GPUDirect Clique ID: invalid device vendor
NVIDIA GPUDirect Clique ID: unsupported PCI class
NVIDIA GPUDirect Clique ID: error getting cap list
NVIDIA GPUDirect Clique ID: invalid config space
Failed to add NVIDIA GPUDirect cap: 
VMD %s cannot read MEMBARs (%d)
Failed to add VMD MEMBAR Shadow cap: 
NVIDIA GPUDirect Clique ID (0 - 15)
vfio: unsupported write size, %d bytes
%s(,0x%lx, 0x%lx, %d) failed: %m
%d@%zu.%06zu:vfio_vga_write  (0x%lx, 0x%lx, %d)
vfio_vga_write  (0x%lx, 0x%lx, %d)
vfio: unsupported read size, %d bytes
%d@%zu.%06zu:vfio_vga_read  (0x%lx, %d) = 0x%lx
vfio_vga_read  (0x%lx, %d) = 0x%lx
%d@%zu.%06zu:vfio_msix_pba_enable  (%s)
%d@%zu.%06zu:vfio_msi_interrupt  (%s) vector %d 0x%lx/0x%x
vfio_msi_interrupt  (%s) vector %d 0x%lx/0x%x
event_notifier_init failed eoi
failed to setup resample irqfd
%d@%zu.%06zu:vfio_intx_enable_kvm  (%s) KVM INTx accel enabled
vfio_intx_enable_kvm  (%s) KVM INTx accel enabled
VFIO-based PCI device assignment
Host PCI address [domain:]<bus:slot.function> of assigned device
When EOI is not provided by KVM/QEMU, wait time (milliseconds) to re-enable device direct access after INTx (DEBUG)
Expose VGA address spaces for device
Disable device request notification support (DEBUG)
Disable MMAP for device. Allows to trace MMIO accesses (DEBUG)
Disable direct VFIO->KVM INTx injection. Allows to trace INTx interrupts (DEBUG)
Disable direct VFIO->KVM MSI injection. Allows to trace MSI interrupts (DEBUG)
Disable direct VFIO->KVM MSIx injection. Allows to trace MSIx interrupts (DEBUG)
Override PCI Vendor ID with provided value (DEBUG)
Override PCI device ID with provided value (DEBUG)
Override PCI Subsystem Vendor ID with provided value (DEBUG)
Override PCI Subsystem Device ID with provided value (DEBUG)
Host sysfs path of assigned device
Expose host IGD OpRegion to guest
Override IGD data stolen memory size (32MiB units)
Add NVIDIA GPUDirect capability indicating P2P DMA clique for device [0-15]
Disable GeForce quirks (for NVIDIA Quadro/GRID/Tesla). Improves performance
Enable display support for device, ex. vGPU
Specify MSI-X MMIO relocation to the end of specified existing BAR or new BAR to avoid virtualization overhead due to adjacent device registers
Disable registration of ioeventfds with KVM (DEBUG)
Disable linking of KVM ioeventfds to VFIO ioeventfds (DEBUG)
Override allowing ballooning with device (DEBUG, DANGER)
Set X display resolution the vGPU should use
Set Y display resolution the vGPU should use
Disable dirty pages tracking during iterative phase (DEBUG)
x-pre-copy-dirty-page-tracking
Enale device migration. Also requires a host VFIO PCI variant or mdev driver with migration support enabled
Specify UUID VF token. Required for VF when PF is owned by another VFIO driver
Set host IOMMUFD backend device
Disable device dirty page tracking and use container-based dirty page tracking
Emit VFIO migration QAPI event when a VFIO device changes its migration state. For management applications
Skip config space check for Vendor Specific Capability. Setting to false will enforce strict checking of VSC content (DEBUG)
Transfer this device state via multifd channels when live migrating it
vfio: Error getting ROM info: %m
%d@%zu.%06zu:vfio_pci_load_rom Device '%s' ROM: size: 0x%lx, offset: 0x%lx, flags: 0x%lx
vfio_pci_load_rom Device '%s' ROM: size: 0x%lx, offset: 0x%lx, flags: 0x%lx
vfio-pci: Cannot read device rom at %s
Device option ROM contents are probably invalid (check dmesg).
Skip option ROM probe with rombar=0, or load from file with romfile=
vfio: Error reading device ROM: %m
vfio: unsupported read size, %d bytes
%d@%zu.%06zu:vfio_rom_read  (%s, 0x%lx, 0x%x) = 0x%lx
vfio_rom_read  (%s, 0x%lx, 0x%x) = 0x%lx
vfio: Error: Failed to disable INTx irqfd: %m
%d@%zu.%06zu:vfio_intx_disable_kvm  (%s) KVM INTx accel disabled
vfio_intx_disable_kvm  (%s) KVM INTx accel disabled
%d@%zu.%06zu:vfio_intx_disable  (%s)
%d@%zu.%06zu:vfio_intx_eoi  (%s) EOI
%d@%zu.%06zu:vfio_intx_update  (%s) IRQ moved %d -> %d
vfio_intx_update  (%s) IRQ moved %d -> %d
%d@%zu.%06zu:vfio_intx_interrupt  (%s) Pin %c
vfio_intx_interrupt  (%s) Pin %c
%s(%s) Unrecoverable error detected. Please collect any data possible and then kill the guest
Enable ramfb to provide pre-boot graphics for devices enabling display option
Override default migration support for ramfb support (DEBUG)
%d@%zu.%06zu:vfio_msix_vector_release  (%s) vector %d released
vfio_msix_vector_release  (%s) vector %d released
%d@%zu.%06zu:vfio_pci_read_config  (%s, @0x%x, len=0x%x) 0x%x
vfio_pci_read_config  (%s, @0x%x, len=0x%x) 0x%x
%d@%zu.%06zu:vfio_intx_enable  (%s)
%d@%zu.%06zu:vfio_msix_disable  (%s)
%d@%zu.%06zu:vfio_msi_disable  (%s)
vfio: msix_set_vector_notifiers failed
vfio: failed to enable vectors, %d
vfio: failed to enable MSI-X, %d
%d@%zu.%06zu:vfio_msix_enable  (%s)
vfio: Error: event_notifier_init failed
vfio: Error: Failed to setup MSI fds: %m
vfio: Error: Failed to enable MSI
vfio: Error: Failed to enable %d MSI vectors, retry with %d
%d@%zu.%06zu:vfio_msi_enable  (%s) Enabled %d MSI vectors
vfio_msi_enable  (%s) Enabled %d MSI vectors
%d@%zu.%06zu:vfio_pci_write_config  (%s, @0x%x, 0x%x, len=0x%x)
vfio_pci_write_config  (%s, @0x%x, 0x%x, len=0x%x)
%s(%s, 0x%x, 0x%x, 0x%x) failed: %m
failed reading MSI PCI_CAP_FLAGS
%d@%zu.%06zu:vfio_msi_setup %s PCI MSI CAP @0x%x
vfio_msi_setup %s PCI MSI CAP @0x%x
%d@%zu.%06zu:vfio_check_pcie_flr %s Supports FLR via PCIe cap
vfio_check_pcie_flr %s Supports FLR via PCIe cap
assignment of PCIe type 0x%x devices is not currently supported
%d@%zu.%06zu:vfio_check_pm_reset %s Supports PM reset
vfio_check_pm_reset %s Supports PM reset
%d@%zu.%06zu:vfio_check_af_flr %s Supports FLR via AF cap
vfio_check_af_flr %s Supports FLR via AF cap
failed to add PCI capability 0x%x[0x%x]@0x%x: 
%d@%zu.%06zu:vfio_msix_vector_do_use  (%s) vector %d used
vfio_msix_vector_do_use  (%s) vector %d used
%d@%zu.%06zu:vfio_msix_pba_disable  (%s)
vfio: Unable to power on device, stuck in D%d
%s(%s) reset bar %d failed: %m
%d@%zu.%06zu:vfio_pci_reset  (%s)
%d@%zu.%06zu:vfio_pci_reset_flr %s FLR/VFIO_DEVICE_RESET
vfio_pci_reset_flr %s FLR/VFIO_DEVICE_RESET
%d@%zu.%06zu:vfio_pci_reset_pm %s PCI PM Reset
vfio_pci_reset_pm %s PCI PM Reset
vfio: Cannot reset device %s, no available reset mechanism.
vfio: hot reset info failed: %m
failed getting region info for VGA region index %d
unexpected VGA info, flags 0x%lx, size 0x%lx
Use -device vfio-pci,host=DDDD:BB:DD.F or -device vfio-pci,fd=DEVICE_FD or -device vfio-pci,sysfsdev=PATH_TO_DEVICE
/sys/bus/pci/devices/%04x:%02x:%02x.%01x
%d@%zu.%06zu:vfio_mdev  (%s) is_mdev %d
x-balloon-allowed only potentially compatible with mdev devices
unexpected number of io regions %u
%d@%zu.%06zu:vfio_populate_device_config Device '%s' config: size: 0x%lx, offset: 0x%lx, flags: 0x%lx
vfio_populate_device_config Device '%s' config: size: 0x%lx, offset: 0x%lx, flags: 0x%lx
device does not support requested feature x-vga
%d@%zu.%06zu:vfio_populate_device_get_irq_info_failure VFIO_DEVICE_GET_IRQ_INFO failure: %s
vfio_populate_device_get_irq_info_failure VFIO_DEVICE_GET_IRQ_INFO failure: %s
vfio %s: Could not enable error recovery for the device
failed to read device config space
invalid PCI vendor ID provided
%d@%zu.%06zu:vfio_pci_emulated_vendor_id %s 0x%04x
vfio_pci_emulated_vendor_id %s 0x%04x
invalid PCI device ID provided
%d@%zu.%06zu:vfio_pci_emulated_device_id %s 0x%04x
vfio_pci_emulated_device_id %s 0x%04x
invalid PCI subsystem vendor ID provided
%d@%zu.%06zu:vfio_pci_emulated_sub_vendor_id %s 0x%04x
vfio_pci_emulated_sub_vendor_id %s 0x%04x
invalid PCI subsystem device ID provided
%d@%zu.%06zu:vfio_pci_emulated_sub_device_id %s 0x%04x
vfio_pci_emulated_sub_device_id %s 0x%04x
Device at %s is known to cause system instability issues during option rom execution
Proceeding anyway since user specified romfile
Proceeding anyway since user specified positive value for rombar
Rom loading for device at %s has been disabled due to system instability issues
Specify rombar=1 or romfile to force
%d@%zu.%06zu:vfio_pci_size_rom %s ROM size 0x%x
vfio_pci_size_rom %s ROM size 0x%x
vfio: Failed to read BAR %d (%m)
hardware reports invalid configuration, MSIX PBA outside of specified BAR
%d@%zu.%06zu:vfio_msix_early_setup %s PCI MSI-X CAP @0x%x, BAR %d, offset 0x%lx, entries %d, noresize %d
vfio_msix_early_setup %s PCI MSI-X CAP @0x%x, BAR %d, offset 0x%lx, entries %d, noresize %d
%d@%zu.%06zu:vfio_msix_fixup  (%s) MSI-X region %d mmap fixup [0x%lx - 0x%lx]
vfio_msix_fixup  (%s) MSI-X region %d mmap fixup [0x%lx - 0x%lx]
No automatic MSI-X relocation available for device %04x:%04x
Invalid MSI-X relocation BAR %d, I/O port BAR
Invalid MSI-X relocation BAR %d, consumed by 64-bit BAR %d
Invalid MSI-X relocation BAR %d, no space to extend 32-bit BAR
%d@%zu.%06zu:vfio_msix_relo  (%s) BAR %d offset 0x%lx
vfio_msix_relo  (%s) BAR %d offset 0x%lx
Failed to mmap %s BAR %d. Performance may be slow
%d@%zu.%06zu:vfio_add_ext_cap_dropped %s 0x%x@0x%x
vfio_add_ext_cap_dropped %s 0x%x@0x%x
xres and yres properties require display=on
xres and yres properties need edid support
x-ramfb-migrate=on but ramfb=off. Forcing x-ramfb-migrate to off.
x-ramfb-migrate requires enable-migration
vfio: Unable to init event notifier for error detection
vfio: Unable to init event notifier for device request
VFIO dummy ISA/LPC bridge for IGD assignment
IGD OpRegion is not supported on hotplugged device
Device does not supports IGD OpRegion feature
%d@%zu.%06zu:vfio_pci_igd_opregion_enabled %s
vfio_pci_igd_opregion_enabled %s
VFIO dummy ISA/LPC bridge must have address 1f.0
IGD device %s is unsupported in legacy mode, try SandyBridge or newer
IGD legacy mode enabled, use x-igd-legacy-mode=off to disable it if unwanted.
Machine is not i440fx or assigned BDF is not 00:02.0
IGD LPC is not supported on hotplugged device
Cannot create LPC bridge due to existing device at 1f.0
IGD LPC bridge access is not supported by kernel
IGD host bridge access is not supported by kernel
Failed to create/modify LPC bridge for IGD
%d@%zu.%06zu:vfio_pci_igd_lpc_bridge_enabled %s
vfio_pci_igd_lpc_bridge_enabled %s
%d@%zu.%06zu:vfio_pci_igd_host_bridge_enabled %s
vfio_pci_igd_host_bridge_enabled %s
Failed to modify host bridge for IGD
%d@%zu.%06zu:vfio_pci_igd_bdsm_enabled %s %dMB
vfio_pci_igd_bdsm_enabled %s %dMB
sz >= sizeof(VirtQueueElement)
%d@%zu.%06zu:virtqueue_alloc_element elem %p size %zd in_num %u out_num %u
virtqueue_alloc_element elem %p size %zd in_num %u out_num %u
%d@%zu.%06zu:virtio_notify_irqfd_deferred_fn vdev %p vq %p
virtio_notify_irqfd_deferred_fn vdev %p vq %p
addr < cache->len && len <= cache->len - addr
virtio: error trying to map MMIO memory
virtio: unexpected memory split
%d@%zu.%06zu:virtio_queue_notify vdev %p n %d vq %p
virtio_queue_notify vdev %p n %d vq %p
virtio_set_features_nocheck_bh
/home/virus/AMD/AMD/include/exec/memory_ldst_cached.h.inc
addr < cache->len && 2 <= cache->len - addr
notification_data=on without ioeventfd=off is not supported
%d@%zu.%06zu:virtqueue_fill vq %p elem %p len %u idx %u
virtqueue_fill vq %p elem %p len %u idx %u
%s: %s cannot fill buffer id %u
%d@%zu.%06zu:virtqueue_flush vq %p count %u
virtqueue_flush vq %p count %u
ARRAY_SIZE(data.in_addr) >= data.in_num
ARRAY_SIZE(data.out_addr) >= data.out_num
%d@%zu.%06zu:virtio_set_status vdev %p val %u
virtio_set_status vdev %p val %u
%d@%zu.%06zu:virtio_notify_irqfd vdev %p vq %p
virtio_notify_irqfd vdev %p vq %p
%d@%zu.%06zu:virtio_notify vdev %p vq %p
config_size <= params->max_size
device_id < G_N_ELEMENTS(virtio_device_names)
tried to modify queue alignment for virtio-1 device
k->has_variable_vring_alignment
%s: guest driver for %s has enabled UNUSED(30) feature bit!
Guest says index %u is available
virtio: zero sized buffers are not allowed
virtio: too many write descriptors in indirect table
virtio: bogus descriptor or out of resources
Invalid size for indirect buffer table
Incorrect order for descriptors
%d@%zu.%06zu:virtqueue_pop vq %p elem %p in_num %u out_num %u
virtqueue_pop vq %p elem %p in_num %u out_num %u
Invalid number of virtqueues: 0x%x
VQ %d address 0x0 inconsistent with Host index 0x%x
Features 0x%lx unsupported. Allowed features: 0x%lx
Features 0x%x unsupported. Allowed features: 0x%lx
VQ %d size 0x%x Guest index 0x%x inconsistent with Host index 0x%x: delta 0x%x
VQ %d size 0x%x < last_avail_idx 0x%x - used_idx 0x%x
Guest moved used index from %u to %u
Path %s is not a VirtIO device
VHOST_F_LOG_ALL: Logging write descriptors supported
Path %s is not a realized VirtIODevice
Error: vhost device has not started yet
Invalid vhost virtqueue number %d
VIRTIO_GPIO_F_IRQ: Device supports interrupts on GPIO lines
VHOST_USER_F_PROTOCOL_FEATURES: Vhost-user protocol features negotiation supported
VIRTIO_MEM_F_UNPLUGGED_INACCESSIBLE: Unplugged memory cannot be accessed
VIRTIO_MEM_F_PERSISTENT_SUSPND: Plugged memory will remain plugged when suspending+resuming
VIRTIO_IOMMU_F_INPUT_RANGE: Range of available virtual addrs. available
VIRTIO_IOMMU_F_DOMAIN_RANGE: Number of supported domains available
VIRTIO_IOMMU_F_MAP_UNMAP: Map and unmap requests available
VIRTIO_IOMMU_F_BYPASS: Endpoints not attached to domains are in bypass mode
VIRTIO_IOMMU_F_PROBE: Probe requests available
VIRTIO_IOMMU_F_MMIO: VIRTIO_IOMMU_MAP_F_MMIO flag available
VIRTIO_IOMMU_F_BYPASS_CONFIG: Bypass field of IOMMU config available
VIRTIO_BALLOON_F_MUST_TELL_HOST: Tell host before reclaiming pages
VIRTIO_BALLOON_F_STATS_VQ: Guest memory stats VQ available
VIRTIO_BALLOON_F_DEFLATE_ON_OOM: Deflate balloon when guest OOM
VIRTIO_BALLOON_F_FREE_PAGE_HINT: VQ reporting free pages enabled
VIRTIO_BALLOON_F_PAGE_POISON: Guest page poisoning enabled
VIRTIO_BALLOON_F_REPORTING: Page reporting VQ enabled
VIRTIO_VSOCK_F_SEQPACKET: SOCK_SEQPACKET supported
VIRTIO_SCSI_F_INOUT: Requests including read and writable data buffers supported
VIRTIO_SCSI_F_HOTPLUG: Reporting and handling hot-plug events supported
VIRTIO_SCSI_F_CHANGE: Reporting and handling LUN changes supported
VIRTIO_SCSI_F_T10_PI: T10 info included in request header
VIRTIO_NET_F_CSUM: Device handling packets with partial checksum supported
VIRTIO_NET_F_GUEST_CSUM: Driver handling packets with partial checksum supported
VIRTIO_NET_F_CTRL_GUEST_OFFLOADS: Control channel offloading reconfig. supported
VIRTIO_NET_F_MTU: Device max MTU reporting supported
VIRTIO_NET_F_MAC: Device has given MAC address
VIRTIO_NET_F_GUEST_TSO4: Driver can receive TSOv4
VIRTIO_NET_F_GUEST_TSO6: Driver can receive TSOv6
VIRTIO_NET_F_GUEST_ECN: Driver can receive TSO with ECN
VIRTIO_NET_F_GUEST_UFO: Driver can receive UFO
VIRTIO_NET_F_HOST_TSO4: Device can receive TSOv4
VIRTIO_NET_F_HOST_TSO6: Device can receive TSOv6
VIRTIO_NET_F_HOST_ECN: Device can receive TSO with ECN
VIRTIO_NET_F_HOST_UFO: Device can receive UFO
VIRTIO_NET_F_MRG_RXBUF: Driver can merge receive buffers
VIRTIO_NET_F_STATUS: Configuration status field available
VIRTIO_NET_F_CTRL_VQ: Control channel available
VIRTIO_NET_F_CTRL_RX: Control channel RX mode supported
VIRTIO_NET_F_CTRL_VLAN: Control channel VLAN filtering supported
VIRTIO_NET_F_CTRL_RX_EXTRA: Extra RX mode control supported
VIRTIO_NET_F_GUEST_ANNOUNCE: Driver sending gratuitous packets supported
VIRTIO_NET_F_MQ: Multiqueue with automatic receive steering supported
VIRTIO_NET_F_CTRL_MAC_ADDR: MAC address set through control channel
VIRTIO_NET_F_NOTF_COAL: Device supports coalescing notifications
VIRTIO_NET_F_GUEST_USO4: Driver can receive USOv4
VIRTIO_NET_F_GUEST_USO4: Driver can receive USOv6
VIRTIO_NET_F_HOST_USO: Device can receive USO
VIRTIO_NET_F_HASH_REPORT: Hash reporting supported
VIRTIO_NET_F_RSS: RSS RX steering supported
VIRTIO_NET_F_RSC_EXT: Extended coalescing info supported
VIRTIO_NET_F_STANDBY: Device acting as standby for primary device with same MAC addr. supported
VIRTIO_NET_F_SPEED_DUPLEX: Device set linkspeed and duplex
VIRTIO_NET_F_GSO: Handling GSO-type packets supported
VHOST_NET_F_VIRTIO_NET_HDR: Virtio-net headers for RX and TX packets supported
VIRTIO_GPU_F_VIRGL: Virgl 3D mode supported
VIRTIO_GPU_F_EDID: EDID metadata supported
VIRTIO_GPU_F_RESOURCE_UUID: Resource UUID assigning supported
VIRTIO_GPU_F_RESOURCE_BLOB: Size-based blob resources supported
VIRTIO_GPU_F_CONTEXT_INIT: Context types and synchronization timelines supported
VIRTIO_CONSOLE_F_SIZE: Host providing console size
VIRTIO_CONSOLE_F_MULTIPORT: Multiple ports for device supported
VIRTIO_CONSOLE_F_EMERG_WRITE: Emergency write supported
VIRTIO_BLK_F_SIZE_MAX: Max segment size is size_max
VIRTIO_BLK_F_SEG_MAX: Max segments in a request is seg_max
VIRTIO_BLK_F_GEOMETRY: Legacy geometry available
VIRTIO_BLK_F_RO: Device is read-only
VIRTIO_BLK_F_BLK_SIZE: Block size of disk available
VIRTIO_BLK_F_TOPOLOGY: Topology information available
VIRTIO_BLK_F_MQ: Multiqueue supported
VIRTIO_BLK_F_DISCARD: Discard command supported
VIRTIO_BLK_F_WRITE_ZEROES: Write zeroes command supported
VIRTIO_BLK_F_SECURE_ERASE: Secure erase supported
VIRTIO_BLK_F_ZONED: Zoned block devices
VIRTIO_BLK_F_BARRIER: Request barriers supported
VIRTIO_BLK_F_SCSI: SCSI packet commands supported
VIRTIO_BLK_F_FLUSH: Flush command supported
VIRTIO_BLK_F_CONFIG_WCE: Cache writeback and writethrough modes supported
VIRTIO_CONFIG_S_DRIVER_OK: Driver setup and ready
VIRTIO_CONFIG_S_FEATURES_OK: Feature negotiation complete
VIRTIO_CONFIG_S_DRIVER: Guest OS compatible with device
VIRTIO_CONFIG_S_NEEDS_RESET: Irrecoverable error, device needs reset
VIRTIO_CONFIG_S_FAILED: Error in guest, device failed
VIRTIO_CONFIG_S_ACKNOWLEDGE: Valid virtio device found
VHOST_USER_PROTOCOL_F_MQ: Multiqueue protocol supported
VHOST_USER_PROTOCOL_F_LOG_SHMFD: Shared log memory fd supported
VHOST_USER_PROTOCOL_F_RARP: Vhost-user back-end RARP broadcasting supported
VHOST_USER_PROTOCOL_F_REPLY_ACK: Requested operation status ack. supported
VHOST_USER_PROTOCOL_F_NET_MTU: Expose host MTU to guest supported
VHOST_USER_PROTOCOL_F_BACKEND_REQ: Socket fd for back-end initiated requests supported
VHOST_USER_PROTOCOL_F_CROSS_ENDIAN: Endianness of VQs for legacy devices supported
VHOST_USER_PROTOCOL_F_CRYPTO_SESSION: Session creation for crypto operations supported
VHOST_USER_PROTOCOL_F_PAGEFAULT: Request servicing on userfaultfd for accessed pages supported
VHOST_USER_PROTOCOL_F_CONFIG: Vhost-user messaging for virtio device configuration space supported
VHOST_USER_PROTOCOL_F_BACKEND_SEND_FD: Backend fd communication channel supported
VHOST_USER_PROTOCOL_F_HOST_NOTIFIER: Host notifiers for specified VQs supported
VHOST_USER_PROTOCOL_F_INFLIGHT_SHMFD: Shared inflight I/O buffers supported
VHOST_USER_PROTOCOL_F_RESET_DEVICE: Disabling all rings and resetting internal device state supported
VHOST_USER_PROTOCOL_F_INBAND_NOTIFICATIONS: In-band messaging supported
VHOST_USER_PROTOCOL_F_CONFIGURE_MEM_SLOTS: Configuration for memory slots supported
VHOST_USER_PROTOCOL_F_STATUS: Querying and notifying back-end device status supported
VHOST_USER_PROTOCOL_F_SHARED_OBJECT: Backend shared object supported
VHOST_USER_PROTOCOL_F_DEVICE_STATE: Backend device state transfer supported
VIRTIO_F_NOTIFY_ON_EMPTY: Notify when device runs out of avail. descs. on VQ
VIRTIO_F_ANY_LAYOUT: Device accepts arbitrary desc. layouts
VIRTIO_F_VERSION_1: Device compliant for v1 spec (legacy)
VIRTIO_F_IOMMU_PLATFORM: Device can be used on IOMMU platform
VIRTIO_F_RING_PACKED: Device supports packed VQ layout
VIRTIO_F_IN_ORDER: Device uses buffers in same order as made available by driver
VIRTIO_F_ORDER_PLATFORM: Memory accesses ordered by platform
VIRTIO_F_SR_IOV: Device supports single root I/O virtualization
VIRTIO_F_RING_RESET: Driver can reset a queue individually
VIRTIO_RING_F_INDIRECT_DESC: Indirect descriptors supported
VIRTIO_RING_F_EVENT_IDX: Used & avail. event fields enabled
/sys/module/vhost/parameters/max_mem_regions
ignoring invalid max_mem_regions value in vhost module: %s
dev->vhost_ops->backend_type == VHOST_BACKEND_TYPE_KERNEL
Unexpected IOTLB message when virtio device is stopped
Access failure IOTLB message type not supported
Unknown vhost iotlb message type
%d@%zu.%06zu:vhost_user_postcopy_waker %s + 0x%lx
vhost_user_postcopy_waker %s + 0x%lx
%d@%zu.%06zu:vhost_user_postcopy_waker_found 0x%lx
vhost_user_postcopy_waker_found 0x%lx
%d@%zu.%06zu:vhost_user_postcopy_waker_nomatch %s + 0x%lx
vhost_user_postcopy_waker_nomatch %s + 0x%lx
%d@%zu.%06zu:vhost_user_postcopy_fault_handler %s: @0x%lx nregions:%d
vhost_user_postcopy_fault_handler %s: @0x%lx nregions:%d
%s: Failed to find region for fault %lx
%d@%zu.%06zu:vhost_user_postcopy_fault_handler_loop %d: client 0x%lx +0x%lx
vhost_user_postcopy_fault_handler_loop %d: client 0x%lx +0x%lx
%d@%zu.%06zu:vhost_user_postcopy_fault_handler_found %d: region_offset: 0x%lx rb_offset:0x%lx
vhost_user_postcopy_fault_handler_found %d: region_offset: 0x%lx rb_offset:0x%lx
dev->vhost_ops->backend_type == VHOST_BACKEND_TYPE_USER
Failed to write msg. Wrote %d instead of %d.
%d@%zu.%06zu:vhost_user_write req:%d flags:0x%x
vhost_user_write req:%d flags:0x%x
vhost-user trying to send unhandled ioctl
vhost_user_write() return %d, close session failed
Failed to read msg header. Read %d instead of %d. Original request %d.
Failed to read msg header. Flags 0x%x instead of 0x%x.
%d@%zu.%06zu:vhost_user_read req:%d flags:0x%x
vhost_user_read req:%d flags:0x%x
Failed to read msg header. Size %d exceeds the maximum %zu.
Failed to read msg payload. Read %d instead of %d.
Failed to send postcopy_advise to vhost
Failed to get postcopy_advise reply from vhost
Unexpected msg type. Expected %d received %d
Received unexpected msg type. Expected %d received %d
Back-end does not support migration state transfer
Failed to send SET_DEVICE_STATE_FD message
Failed to receive SET_DEVICE_STATE_FD reply
Received unexpected message type, expected %d, received %d
Received bad message size, expected %zu, received %u
Back-end did not accept migration state transfer
Failed to get back-end-provided transfer pipe FD
VHOST_USER_PROTOCOL_F_CONFIG not supported
config_len <= VHOST_USER_MAX_CONFIG_SIZE
Failed to send CHECK_DEVICE_STATE message
Failed to receive CHECK_DEVICE_STATE reply
Back-end failed to process its internal state
Unsupported asymmetric key size
vhost_user_write() return %d, create session failed
vhost_user_read() return %d, create session failed
%d@%zu.%06zu:vhost_user_postcopy_listen 
Failed to send postcopy_listen to vhost
Failed to receive reply to postcopy_listen
%d@%zu.%06zu:vhost_user_postcopy_end_entry 
vhost_user_postcopy_end_entry 
Failed to send postcopy_end to vhost
Failed to receive reply to postcopy_end
%d@%zu.%06zu:vhost_user_postcopy_end_exit 
vhost_user_postcopy_end_exit 
vhost-user backend not capable of postcopy
*fd_num < VHOST_MEMORY_BASELINE_NREGIONS
%d@%zu.%06zu:vhost_user_set_mem_table_withfd %d:%s: size:0x%lx GPA:0x%lx QVA/userspace:0x%lx RB offset:0x%lx
vhost_user_set_mem_table_withfd %d:%s: size:0x%lx GPA:0x%lx QVA/userspace:0x%lx RB offset:0x%lx
Failed preparing vhost-user memory table msg
Failed initializing vhost-user memory map, consider using -object memory-backend-file share=on
%s: Received unexpected msg type.Expected %d received %d
%s: Unexpected size for postcopy reply %d vs %d
%d@%zu.%06zu:vhost_user_set_mem_table_postcopy client:0x%lx for hva: 0x%lx reply %d region %d
vhost_user_set_mem_table_postcopy client:0x%lx for hva: 0x%lx reply %d region %d
%s: invalid postcopy reply for region. Got guest physical address %lX, expected %lX
%s: postcopy reply not fully consumed %d vs %zd
vhost-user device expecting VHOST_USER_PROTOCOL_F_CONFIG but the vhost-user backend does not support it.
vhost-user backend supports VHOST_USER_PROTOCOL_F_CONFIG but QEMU does not.
The maximum number of queues supported by the backend is %lu
IOMMU support requires reply-ack and backend-req protocol features.
The backend specified a max ram slots limit of %lu, when the prior validated limit was %d. This limit should never decrease.
Migration disabled: vhost-user backend lacks VHOST_USER_PROTOCOL_F_LOG_SHMFD feature.
%d@%zu.%06zu:vhost_user_create_notifier idx:%d n:%p
vhost_user_create_notifier idx:%d n:%p
vhost-user/host-notifier@%p mmaps[%d]
Received unexpected msg type: %d.
Cannot initialize vhost-user state
Device %s says index %u is used
Device %s says index %u is used, but it was not available
Invalid address 0x%lx given by guest
Guest buffer expands over iova range
SVQ Invalid device feature flags, offer: 0x%lx, ok: 0x%lx
../hw/virtio/vhost-shadow-virtqueue.c
Guest provided element with no descriptors
More than %u used buffers obtained in a %u size SVQ
/home/virus/AMD/AMD/include/hw/virtio/virtio-balloon.h
%d@%zu.%06zu:virtio_balloon_bad_addr 0x%lx
virtio_balloon_bad_addr 0x%lx
%d@%zu.%06zu:virtio_balloon_handle_output section name: %s gpa: 0x%lx
virtio_balloon_handle_output section name: %s gpa: 0x%lx
Balloon used with backing page size > 4kiB, this may not be reliable
Couldn't MADV_WILLNEED on balloon deflate: %s
%d@%zu.%06zu:virtio_balloon_get_config num_pages: %d actual: %d
virtio_balloon_get_config num_pages: %d actual: %d
%d@%zu.%06zu:virtio_balloon_set_config actual: %d oldactual: %d
virtio_balloon_set_config actual: %d oldactual: %d
%d@%zu.%06zu:virtio_balloon_to_target balloon target: 0x%lx num_pages: %d
virtio_balloon_to_target balloon target: 0x%lx num_pages: %d
'free-page-hint' requires 'iothread' to be set
virtio_ballloon_get_free_page_hints
timer value must be greater than zero
virtio-balloon-device/page-poison
virtio-balloon-device/free-page-report
/home/virus/AMD/AMD/include/hw/virtio/vhost-user-fs.h
Back-end of %s device %s (tag: "%s") does not support migration through qemu
Error saving back-end state of %s device %s (tag: "%s"): 
Error loading back-end state of %s device %s (tag: "%s"): 
tag property must be %zu bytes or less
num-request-queues property must be larger than 0
queue-size property must be a power of 2
queue-size property must be %u or smaller
/home/virus/AMD/AMD/include/hw/virtio/virtio-pmem.h
%d@%zu.%06zu:virtio_pmem_flush_request flush request
virtio_pmem_flush_request flush request
virtio-pmem missing request data
virtio-pmem request not proper
%d@%zu.%06zu:virtio_pmem_flush_done fsync return=%d
virtio_pmem_flush_done fsync return=%d
%d@%zu.%06zu:virtio_pmem_response flush response
virtio_pmem_response flush response
/home/virus/AMD/AMD/include/hw/virtio/vhost-vsock.h
guest-cid property must be greater than 2
guest-cid property must be a 32-bit number
vhost-vsock: unable to parse vhostfd: 
vhost-vsock: unable to set non-blocking mode
vhost-vsock: failed to open vhost device
vhost-vsock: unable to set guest cid
Error starting vhost vsock: %d
vhost vsock set running failed: %d
/home/virus/AMD/AMD/include/hw/virtio/vhost-user-vsock.h
../hw/virtio/vhost-user-vsock.c
%d@%zu.%06zu:virtio_rng_request rng %p: %zd bytes requested, %u bytes quota left
virtio_rng_request rng %p: %zd bytes requested, %u bytes quota left
/home/virus/AMD/AMD/include/hw/virtio/virtio-rng.h
%d@%zu.%06zu:virtio_rng_guest_not_ready rng %p: guest not ready
virtio_rng_guest_not_ready rng %p: guest not ready
%d@%zu.%06zu:virtio_rng_cpu_is_stopped rng %p: cpu is stopped, dropping %d bytes
virtio_rng_cpu_is_stopped rng %p: cpu is stopped, dropping %d bytes
%d@%zu.%06zu:virtio_rng_popped rng %p: elem popped
virtio_rng_popped rng %p: elem popped
%d@%zu.%06zu:virtio_rng_pushed rng %p: %zd bytes pushed
virtio_rng_pushed rng %p: %zd bytes pushed
'period' parameter expects a positive integer
'max-bytes' parameter must be positive, and less than 2^63
'rng' parameter expects a valid object
%d@%zu.%06zu:virtio_rng_vm_state_change rng %p: state change to running %d state %d
virtio_rng_vm_state_change rng %p: state change to running %d state %d
Property '%s' changed from 0x%lx to 0x%lx
Property '%s' size changed from 0x%lx to 0x%lx
Property '%s' changed from %u to %u
/sys/kernel/mm/transparent_hugepage/
/sys/kernel/mm/transparent_hugepage/hpage_pmd_size
Read unsupported THP size: %lx
Could not detect THP size, falling back to %lx  MiB.
!vmem->mr && vmem->dynamic_memslots
%d@%zu.%06zu:virtio_mem_resized_usable_region old_size=0x%lxnew_size=0x%lx
virtio_mem_resized_usable_region old_size=0x%lxnew_size=0x%lx
/home/virus/AMD/AMD/include/hw/virtio/virtio-mem.h
virtio-mem device cannot get unplugged while 'unplugged-inaccessible' != 'on'
virtio-mem device cannot get unplugged while some of its memory is still plugged
virtio-mem device cannot get unplugged while 'requested-size' != '0'
%d@%zu.%06zu:virtio_mem_send_response type=%u
virtio_mem_send_response type=%u
%d@%zu.%06zu:virtio_mem_unplugged_all 
vmem->unplugged_inaccessible != ON_OFF_AUTO_AUTO
%s: Replaying plugged ranges failed: %s
rdl->section->mr == &vmem->memdev->mr
'%s' property has to be at least 0x%x
'%s' property has to be a power of two
Proper preallocation with migration requires a newer QEMU machine
'%s' has to be multiples of '%s' (0x%lx)
'%s' cannot exceed the memory backend size(0x%lx)
virtio-mem protocol violation: invalid request size: %d
virtio-mem protocol violation: not enough space for response: %zu
%d@%zu.%06zu:virtio_mem_plug_request addr=0x%lx nb_blocks=%u
virtio_mem_plug_request addr=0x%lx nb_blocks=%u
%d@%zu.%06zu:virtio_mem_unplug_request addr=0x%lx nb_blocks=%u
virtio_mem_unplug_request addr=0x%lx nb_blocks=%u
%d@%zu.%06zu:virtio_mem_unplug_all_request 
virtio_mem_unplug_all_request 
%d@%zu.%06zu:virtio_mem_state_request addr=0x%lx nb_blocks=%u
virtio_mem_state_request addr=0x%lx nb_blocks=%u
%d@%zu.%06zu:virtio_mem_state_response state=%u
virtio_mem_state_response state=%u
virtio-mem protocol violation: unknown request type: %d
'%s' property specifies an unsupported memdev
'%s' property specifies a memdev with preallocation enabled: %s. Instead, specify 'prealloc=on' for the virtio-mem device. 
'%s' property has value '%u', which exceedsthe number of numa nodes: %d
'%s' property set to 'on' requires '%s' to be 'on'
'%s' property set to 'off' with a memdev that does not support the shared zeropage.
'%s' property has to be at least the page size (0x%lx)
'%s' property is smaller than the default block size (%lx MiB)
'%s' property has to be multiples of '%s' (0x%lx)
'%s' property memdev size has to be multiples of'%s' (0x%lx)
Unexpected error discarding RAM
!vmem->memslots && vmem->nb_memslots && vmem->dynamic_memslots
!vmem->mr && !vmem->nb_memslots && !vmem->memslots
virtio-mem-device/sanity-checks
../hw/virtio/vhost-vsock-pci.c
vhost-vsock-pci-non-transitional
../hw/virtio/vhost-user-vsock-pci.c
vhost-user-vsock-pci-non-transitional
../hw/virtio/vhost-user-blk-pci.c
vhost-user-blk-pci-transitional
vhost-user-blk-pci-non-transitional
../hw/virtio/vhost-user-scsi-pci.c
vhost-user-scsi-pci-transitional
vhost-user-scsi-pci-non-transitional
vhost-scsi-pci-non-transitional
../hw/virtio/vhost-user-fs-pci.c
../hw/virtio/virtio-crypto-pci.c
../hw/virtio/virtio-input-host-pci.c
../hw/virtio/virtio-input-pci.c
../hw/virtio/virtio-balloon-pci.c
virtio-9p-pci-non-transitional
../hw/virtio/virtio-scsi-pci.c
virtio-scsi-pci-non-transitional
virtio-blk-pci-non-transitional
virtio-net-pci-non-transitional
../hw/virtio/virtio-serial-pci.c
virtio-serial-pci-transitional
virtio-serial-pci-non-transitional
../hw/virtio/virtio-pmem-pci.h
../hw/virtio/virtio-iommu-pci.c
Check your machine implements a hotplug handler for the virtio-iommu-pci device
reserved region %d has an invalid type
virtio-iommu-pci must be plugged on the root bus
'%s' cannot be changed if the device is in the process of unplug
vhost-vdpa-device-pci-transitional
vhost-vdpa-device-pci-non-transitional
hotplug of virtio based memory devices not supported on this bus.
Unexpected unplug of virtio based memory device
this virtio based memory devices cannot be unplugged
hotunplug of virtio based memory devices notsupported on this bus
../hw/remote/proxy-memory-listener.c
win-dump: failed to read KiProcessorBlock
win-dump: failed to read OffsetPrcbContext
win-dump: number of QEMU CPUs is bigger than NumberProcessors (%u) in guest Windows
win-dump: failed to read CPU #%d PRCB location
win-dump: failed to read CPU #%d ContextFrame location
win-dump: failed to save CPU #%d context
win-dump: failed to write CPU #%d context
win-dump: invalid vmcoreinfo note size
win-dump: invalid header, expected '%.4s', got '%.4s'
win-dump: invalid header, expected 'DUMP' or 'DU64', got '%.4s'
win-dump: failed to read OwnerTag
win-dump: invalid KDBG OwnerTag, expected '%.4s', got '%.4s'
win-dump: failed to read MmPfnDatabase
win-dump: failed to read KiBugcheckData
win-dump: failed to read bugcheck data
win-dump: failed to write header
win-dump: failed to map physical range 0x%016lx-0x%016lx
win-dump: failed to save memory
win-dump: failed to restore CPU #%d context
%d@%zu.%06zu:breakpoint_singlestep cpu=%d enable=%d
breakpoint_singlestep cpu=%d enable=%d
%d@%zu.%06zu:cpu_out addr 0x%x(%c) value %u
cpu_out addr 0x%x(%c) value %u
%d@%zu.%06zu:cpu_in addr 0x%x(%c) value %u
cpu_in addr 0x%x(%c) value %u
%d@%zu.%06zu:memory_region_ram_device_write cpu %d mr %p addr 0x%lx value 0x%lx size %u
memory_region_ram_device_write cpu %d mr %p addr 0x%lx value 0x%lx size %u
%d@%zu.%06zu:memory_region_ram_device_read cpu %d mr %p addr 0x%lx value 0x%lx size %u
memory_region_ram_device_read cpu %d mr %p addr 0x%lx value 0x%lx size %u
%d@%zu.%06zu:flatview_destroy_rcu %p (root %p)
flatview_destroy_rcu %p (root %p)
qatomic_read(&as->bounce_buffer_size) == 0
QLIST_EMPTY(&as->map_client_list)
%d@%zu.%06zu:flatview_destroy %p (root %p)
flatview_destroy %p (root %p)
%d@%zu.%06zu:memory_region_sync_dirty mr '%s' listener '%s' synced (global=%d)
memory_region_sync_dirty mr '%s' listener '%s' synced (global=%d)
Invalid %s at addr 0x%lX, size %u, region '%s', reason: rejected
Invalid %s at addr 0x%lX, size %u, region '%s', reason: unaligned
Invalid %s at addr 0x%lX, size %u, region '%s', reason: invalid size (min:%u max:%u)
%d@%zu.%06zu:memory_region_subpage_read cpu %d mr %p offset 0x%lx value 0x%lx size %u
memory_region_subpage_read cpu %d mr %p offset 0x%lx value 0x%lx size %u
%d@%zu.%06zu:memory_region_ops_read cpu %d mr %p addr 0x%lx value 0x%lx size %u name '%s'
memory_region_ops_read cpu %d mr %p addr 0x%lx value 0x%lx size %u name '%s'
Blocked re-entrant IO on MemoryRegion: %s at addr: 0x%lX
%d@%zu.%06zu:memory_region_subpage_write cpu %d mr %p offset 0x%lx value 0x%lx size %u
memory_region_subpage_write cpu %d mr %p offset 0x%lx value 0x%lx size %u
%d@%zu.%06zu:memory_region_ops_write cpu %d mr %p addr 0x%lx value 0x%lx size %u name '%s'
memory_region_ops_write cpu %d mr %p addr 0x%lx value 0x%lx size %u name '%s'
  %016lx-%016lx (prio %d, %s%s): %s @%016lx
  %016lx-%016lx (prio %d, %s%s): %s
%016lx-%016lx (prio %d, %s%s): alias %s @%s %016lx-%016lx%s
%016lx-%016lx (prio %d, %s%s): %s%s
%d@%zu.%06zu:flatview_new %p (root %p)
memory_region_transaction_depth
flags && !(flags & (~GLOBAL_DIRTY_MASK))
(global_dirty_tracking & flags) == flags
%d@%zu.%06zu:global_dirty_changed bitmask 0x%x
global_dirty_changed bitmask 0x%x
entry->iova >= notifier->start && entry_end <= notifier->end
memory_region_is_iommu(MEMORY_REGION(iommu_mr))
n->notifier_flags != IOMMU_NOTIFIER_NONE
n->iommu_idx >= 0 && n->iommu_idx < memory_region_iommu_num_indexes(iommu_mr)
iommu map to non memory area %lx
iommu map to discarded memory (e.g., unplugged via virtio-mem): %lx
iommu has granularity incompatible with target AS
!(listener->log_sync && listener->log_sync_global)
map->sections_nb < TARGET_PAGE_SIZE
/home/virus/AMD/AMD/include/exec/ram_addr.h
offset_in_ramblock(block, offset)
madvise doesn't support MADV_DONTDUMP, but dump-guest-core=off specified
existing->mr->subpage || existing->mr == &io_mem_unassigned
Invalid access to non-RAM device at addr 0x%lX, size %lu, region '%s'
Failed to find gap of requested size: %lu
%d@%zu.%06zu:find_ram_offset_loop trying size: 0x%lx @ 0x%lx, offset: 0x%lx next: 0x%lx mingap: 0x%lx
find_ram_offset_loop trying size: 0x%lx @ 0x%lx, offset: 0x%lx next: 0x%lx mingap: 0x%lx
%d@%zu.%06zu:find_ram_offset size: 0x%lx @ 0x%lx
find_ram_offset size: 0x%lx @ 0x%lx
cannot set up guest memory '%s'
cannot set up private guest memory for %s: KVM required
cannot set up private guest memory: discard currently blocked
Are you using assigned devices?
Memory region %s uses guest_memfd, which is not supported with CPR.
!memory_region_is_iommu(section->mr)
(orig_addr & ~TARGET_PAGE_MASK) == 0
asidx >= 0 && asidx < cpu->num_ases
block == qemu_get_ram_block(end - 1)
start >= ramblock->offset && start + length <= ramblock->offset + ramblock->used_length
%24s %8s  %18s %18s %18s %18s %3s
%24s %8s  0x%016lx 0x%016lx 0x%016lx 0x%016lx %3s
RAMBlock "%s" already registered, abort!
Size mismatch: %s: 0x%lx != 0x%lx
Size too large: %s: 0x%lx > 0x%lx
(start + length) <= block->used_length
%s: failed to sync memory range: start: %lx length: %lx
share_flags != (RAM_SHARED | RAM_PRIVATE)
(ram_flags & ~(RAM_SHARED | RAM_PMEM | RAM_NORESERVE | RAM_PROTECTED | RAM_NAMED_FILE | RAM_READONLY | RAM_READONLY_FD | RAM_GUEST_MEMFD | RAM_RESIZEABLE)) == 0
host lacks kvm mmu notifiers, -mem-path unsupported
%s backing store size 0x%lx is too small for 'size' option 0x%lx plus 'offset' option 0x%lx
alignment 0x%lx must be multiples of page size 0x%zx
alignment 0x%lx must be a power of two
offset 0x%lx must be multiples of page size 0x%zx
memory size 0x%lx must be equal to or larger than page size 0x%zx
unable to map backing store for guest RAM
!host ^ (ram_flags & RAM_PREALLOC)
%d@%zu.%06zu:qemu_ram_alloc_shared %s size %zu max_size %zu fd %d host %p
qemu_ram_alloc_shared %s size %zu max_size %zu fd %d host %p
can't open backing store %s for guest RAM
Consider opening the backing store read-only but still creating writable RAM using '-object memory-backend-file,readonly=on,rom=off...' (see "VM templating" documentation)
(ram_flags & ~(RAM_SHARED | RAM_NORESERVE | RAM_GUEST_MEMFD | RAM_PRIVATE)) == 0
(uintptr_t)host >= (uintptr_t)rb->host
section_index < d->map.sections_nb
%d@%zu.%06zu:address_space_map as:%p addr 0x%lx:%lx write:%d attrs:0x%x
address_space_map as:%p addr 0x%lx:%lx write:%d attrs:0x%x
bounce->magic == BOUNCE_BUFFER_MAGIC
%s: Unaligned start address: %p
%s: Discarding RAM with readonly files is not supported
%s: Discarding RAM in private file mappings is possibly dangerous, because it will modify the underlying file and will affect other users of the file
%s: Failed to fallocate %s:%lx+%lx +%zx (%d)
%s: Failed to discard range %s:%lx +%zx (%d)
%d@%zu.%06zu:ram_block_discard_range %s@%p + 0x%zx: madvise: %d fallocate: %d ret: %d
ram_block_discard_range %s@%p + 0x%zx: madvise: %d fallocate: %d ret: %d
%s: Overrun block '%s' (%lu/%zx/%lx)
Could not remap RAM %s:%lx+%lx +%zx
Could not remap RAM %s:%lx +%zx
%s: Failed to fallocate %s:%lx +%zx (%d)
    Nodes (%d bits per level, %d levels) ptr=[%d] skip=%d
      #%d @%016lx..%016lx %s%s%s%s%s
Memory region %s is not compatible with CPR. share=on is required for memory-backend objects, and aux-ram-share=on is required.
%d@%zu.%06zu:migration_bitmap_clear_dirty rb %s start 0x%lx size 0x%lx page 0x%lx
migration_bitmap_clear_dirty rb %s start 0x%lx size 0x%lx page 0x%lx
block %s should not be migrated !
%d@%zu.%06zu:ram_dirty_bitmap_sync_start 
%d@%zu.%06zu:ram_dirty_bitmap_request %s
%d@%zu.%06zu:ram_dirty_bitmap_sync_wait 
%d@%zu.%06zu:ram_dirty_bitmap_sync_complete 
ram_dirty_bitmap_sync_complete 
%d@%zu.%06zu:ram_state_resume_prepare %ld
Block: %s, host: %p is a nvdimm memory, postcopyis not supported now!
%d@%zu.%06zu:migration_bitmap_sync_start 
%d@%zu.%06zu:migration_bitmap_sync_end dirty_pages %lu
migration_bitmap_sync_end dirty_pages %lu
%d@%zu.%06zu:migration_throttle 
%d@%zu.%06zu:migration_dirty_limit_guest guest dirty page rate limit %li MB/s
migration_dirty_limit_guest guest dirty page rate limit %li MB/s
rb->flags & RAM_UF_WRITEPROTECT
%d@%zu.%06zu:ram_write_tracking_ramblock_start %s: page_size: %zu addr: %p length: %zu
ram_write_tracking_ramblock_start %s: page_size: %zu addr: %p length: %zu
ram_write_tracking_start() failed: restoring initial memory state
%d@%zu.%06zu:ram_write_tracking_ramblock_stop %s: page_size: %zu addr: %p length: %zu
ram_write_tracking_ramblock_stop %s: page_size: %zu addr: %p length: %zu
%s: Error allocating zero page
%s: Error allocating encoded_buf
%s: Error allocating current_buf
clear_bitmap_shift (%u) too big, using max value (%u)
clear_bitmap_shift (%u) too small, using min value (%u)
%s: failed to start RDMA registration
%s: failed to stop RDMA registration
%s: multifd synchronization failed
%d@%zu.%06zu:ram_postcopy_send_discard_bitmap 
ram_postcopy_send_discard_bitmap 
%d@%zu.%06zu:ram_discard_range %s: start: %lx %zx
ram_discard_range %s: start: %lx %zx
ram_discard_range: Failed to find block '%s'
RAM block '%s' resized during precopy.
RAM block '%s' discard of resized RAM failed
RAM block '%s' resized during postcopy state: %d
%d@%zu.%06zu:ram_save_page %s: offset: 0x%lx host: %p
ram_save_page %s: offset: 0x%lx host: %p
%d@%zu.%06zu:save_xbzrle_page_skipping 
%d@%zu.%06zu:save_xbzrle_page_overflow 
MIG_RP_MSG_REQ_PAGES has no previous block
MIG_RP_MSG_REQ_PAGES has no block '%s'
%d@%zu.%06zu:ram_save_queue_pages %s: start: 0x%zx len: 0x%zx
ram_save_queue_pages %s: start: 0x%zx len: 0x%zx
MIG_RP_MSG_REQ_PAGES request overrun, start=%lx len=%lx blocklen=%lx
%d@%zu.%06zu:postcopy_preempt_send_host_page ramblock %s offset 0x%lx
postcopy_preempt_send_host_page ramblock %s offset 0x%lx
%d@%zu.%06zu:postcopy_preempt_hit ramblock %s offset 0x%lx
postcopy_preempt_hit ramblock %s offset 0x%lx
%s: ram_save_target_page failed
ram_save_host_page_urgent() failed: ramblock=%s, start_addr=0x%lx
%d@%zu.%06zu:get_queued_page_not_dirty %s/0x%lx page_abs=0x%lx
get_queued_page_not_dirty %s/0x%lx page_abs=0x%lx
%d@%zu.%06zu:get_queued_page %s/0x%lx page_abs=0x%lx
get_queued_page %s/0x%lx page_abs=0x%lx
block && (block->flags & RAM_UF_WRITEPROTECT) != 0
%d@%zu.%06zu:ram_save_iterate_big_wait big wait: %lu milliseconds, %d iterations
ram_save_iterate_big_wait big wait: %lu milliseconds, %d iterations
Failed to write bitmap to file: 
%s: Can't alloc memory for COLO cache of block %s,size 0x%lx
%d@%zu.%06zu:ram_load_postcopy_loop chan=%d addr=0x%lx flags=0x%x
ram_load_postcopy_loop chan=%d addr=0x%lx flags=0x%x
Non-same host page detected on channel %d: Target host page %p, received host page %p (rb %s offset 0x%lx target_pages %d)
Found a zero page with value %d
Unknown combination of migration flags: 0x%x (postcopy mode)
%s: colo_cache is NULL in block :%s
%d@%zu.%06zu:ram_load_loop %s: addr: 0x%lx flags: 0x%x host: %p
ram_load_loop %s: addr: 0x%lx flags: 0x%x host: %p
Could not read whole mapped-ram migration header (expected %zd, got %zd bytes)
Migration mapped-ram capability version not supported (expected <= %d, got %d)
Error reading ramblock %s pages, region has bad alignment
page outside of ramblock %s range
(%s) failed to read page %lxfrom file offset %lx: 
Mismatched RAM page size %s (local) %zd != %ld
Mismatched GPAs for block %s %ld!= %ld
Unknown ramblock "%s", cannot accept migration
Failed to load XBZRLE page - wrong compression!
Failed to load XBZRLE page - len overflow!
Failed to load XBZRLE page - decode error!
Failed to decompress XBZRLE page at %lx
Unknown combination of migration flags: 0x%x
%d@%zu.%06zu:ram_load_complete exit_code %d seq iteration %lu
ram_load_complete exit_code %d seq iteration %lu
%d@%zu.%06zu:colo_flush_ram_cache_begin dirty_pages %lu
colo_flush_ram_cache_begin dirty_pages %lu
%d@%zu.%06zu:colo_flush_ram_cache_end 
%d@%zu.%06zu:ram_dirty_bitmap_reload_begin %s
ram_dirty_bitmap_reload_begin %s
Reload bitmap in incorrect state %s
ramblock '%s' bitmap size mismatch (0x%lx != 0x%lx)
read bitmap failed for ramblock '%s': (size 0x%lx, got: 0x%lx)
ramblock '%s' end mark incorrect: 0x%lx
%d@%zu.%06zu:ram_dirty_bitmap_reload_complete %s
ram_dirty_bitmap_reload_complete %s
No memory is mapped at address 0x%lx
Memory at address 0x%lx is not RAM
Size of memory region at 0x%lx exceeded.
Host virtual address for 0x%lx (%s) is %p
Cannot open /proc/self/pagemap
Host physical address for 0x%lx (%s) is 0x%lx
table->cmd == NULL && table->cmd_info_hrt == NULL
commit changes to the disk images (if -snapshot is used) or backing files
copy data from a backing file into a block device
set maximum speed for a background block operation
stop an active background block operation (use -f
			 if you want to abort the operation immediately
			 instead of keep running until data is in sync)
stop an active background block operation
pause an active background block operation
resume a paused background block operation
eject a removable medium (use -f to force it)
device:B,force:-f,target:F,arg:s?,read-only-mode:s?
device [-f] filename [format [read-only-mode]]
change a removable medium, optional format, use -f to force the operation
filename:F,format:-fs,device:s?,head:i?
filename [-f format] [device [head]]
save screen from head 'head' of display device 'device'in specified format 'format' as image 'filename'.Currently only 'png' and 'ppm' formats are supported.
changes status of a specific trace event (vcpu: vCPU to set, default is all)
activate logging of the specified items
save a VM snapshot. If no tag is provided, a new snapshot is created
restore a VM snapshot from its tag
delete a VM snapshot from its tag
run emulation with one guest instruction per translation block
start gdbserver on given device (default 'tcp::1234'), stop with 'none'
virtual memory dump starting at 'addr'
physical memory dump starting at 'addr'
print the host virtual address corresponding to a guest physical address
print the host physical address corresponding to a guest physical address
print the guest physical address corresponding to a guest virtual address
print expression value (use $reg for CPU register access)
send keys to the VM (e.g. 'sendkey ctrl-alt-f1', default hold time=100 ms)
enable, disable or reset synchronization profiling. With no arguments, prints whether profiling is on or off.
compute the checksum of a memory region
add device, like -device on the command line
change mouse button state (1=L, 2=M, 4=R)
set which mouse device receives events
path:F,audiodev:s,freq:i?,bits:i?,nchannels:i?
path audiodev [frequency [bits [channels]]]
capture audio to a wave file (default frequency=44100 bits=16 channels=2)
save to disk virtual memory dump starting at 'addr' of size 'size'
save to disk physical memory dump starting at 'addr' of size 'size'
define new values for the boot device list
Write to a ring buffer character device
Read from a ring buffer character device
Trigger GARP/RARP announcements
migrate to URI (using -d to not wait for completion)
			 -r to resume a paused postcopy migration
cancel the current VM migration
Continue migration from the given paused state
Continue an incoming migration from an -incoming defer
Continue a paused incoming postcopy migration
Pause an ongoing migration (postcopy-only)
Enable/Disable the usage of a capability for migration
Set the parameter for migration
Followup to a migration command to switch the migration to postcopy mode. The postcopy-ram capability must be set on both source and destination before the original migration command .
Tell COLO that heartbeat is lost,
			a failover or takeover is needed.
protocol:s,hostname:s,port:i?,tls-port:i?,cert-subject:s?
protocol hostname port tls-port cert-subject
set migration information for remote display
paging:-p,detach:-d,windmp:-w,zlib:-z,lzo:-l,snappy:-s,raw:-R,filename:F,begin:l?,length:l?
[-p] [-d] [-z|-l|-s|-w] [-R] filename [begin length]
dump guest memory into file 'filename'.
			-p: do paging to get guest's memory mapping.
			-d: return immediately (do not wait for completion).
			-z: dump in kdump-compressed format, with zlib compression.
			-l: dump in kdump-compressed format, with lzo compression.
			-s: dump in kdump-compressed format, with snappy compression.
			-R: when using kdump (-z, -l, -s), use raw rather than makedumpfile-flattened
			    format
			-w: dump in Windows crashdump format (can be used instead of ELF-dump converting),
			    for Windows x86 and x64 guests with vmcoreinfo driver only.
			begin: the starting physical address.
			length: the memory size, in bytes.
reuse:-n,device:B,snapshot-file:s?,format:s?
[-n] device [new-image-file] [format]
initiates a live snapshot
			of device. If a new image file is specified, the
			new image file will become the new root image.
			If format is specified, the snapshot file will
			be created in that format.
			The default format is qcow2.  The -n flag requests QEMU
			to reuse the image found in new-image-file, instead of
			recreating it from scratch.
take an internal snapshot of device.
			The format of the image used by device must
			support it, such as qcow2.
snapshot_delete_blkdev_internal
delete an internal snapshot of device.
			If id is specified, qemu will try delete
			the snapshot matching both id and name.
			The format of the image used by device must
			support it, such as qcow2.
reuse:-n,full:-f,device:B,target:s,format:s?
[-n] [-f] device target [format]
initiates live storage
			migration for a device. The device's contents are
			copied to the new image file, including data that
			is written after the command is started.
			The -n flag requests QEMU to reuse the image found
			in new-image-file, instead of recreating it from scratch.
			The -f flag requests QEMU to copy the whole disk,
			so that the result does not need a backing file.
reuse:-n,full:-f,compress:-c,device:B,target:s,format:s?
[-n] [-f] [-c] device target [format]
initiates a point-in-time
			copy for a device. The device's contents are
			copied to the new image file, excluding data that
			is written after the command is started.
			The -n flag requests QEMU to reuse the image found
			in new-image-file, instead of recreating it from scratch.
			The -f flag requests QEMU to copy the whole disk,
			so that the result does not need a backing file.
			The -c flag requests QEMU to compress backup data
			(if the target format supports it).
[-n] [[<domain>:]<bus>:]<slot>
[file=file][,if=type][,bus=n]
[,unit=m][,media=d][,index=i]
[,snapshot=on|off][,cache=on|off]
[,readonly=on|off][,copy-on-read=on|off]
add drive to PCI storage controller
advisory_non_fatal:-a,correctable:-c,id:s,error_status:s,header0:i?,header1:i?,header2:i?,header3:i?,prefix0:i?,prefix1:i?,prefix2:i?,prefix3:i?
[-a] [-c] id <error_status> [<tlp header> [<tlp header prefix>]]
inject pcie aer error
			 -a for advisory non fatal error
			 -c for correctable error
			<id> = qdev device id
			<error_status> = error string or 32bit
			<tlp header> = 32bit x 4
			<tlp header prefix> = 32bit x 4
[user|tap|socket|stream|dgram|vde|bridge|hubport|netmap|vhost-user],id=str[,prop=value][,...]
[qom-type=]type,id=str[,prop=value][,...]
[netdev_id] [tcp|udp]:[hostaddr]:hostport-[guestaddr]:guestport
redirect TCP or UDP connections from host to guest (requires -net user)
[netdev_id] [tcp|udp]:[hostaddr]:hostport
remove host-to-guest TCP or UDP redirection
request VM to change its memory allocation (in MB)
change the link status of a network adapter
[reset|shutdown|poweroff|pause|debug|none|inject-nmi]
nbd_server_start [-a] [-w] host:port
serve block devices on the given host and port
nbd_server_add [-w] device [name]
remove an export previously exposed via NBD
stop serving block devices using the NBD protocol
broadcast:-b,cpu_index:i,bank:i,status:l,mcg_status:l,addr:l,misc:l
[-b] cpu bank status mcgstatus addr misc
inject a MCE on the given CPU [and broadcast to other CPUs with -b option]
receive a file descriptor via SCM rights and assign it a name
close a file descriptor previously passed via SCM rights
device:B,bps:l,bps_rd:l,bps_wr:l,iops:l,iops_rd:l,iops_wr:l
device bps bps_rd bps_wr iops iops_rd iops_wr
change I/O throttle limits for a block drive
protocol:s,password:s,display:-ds,connected:s?
protocol password [-d display] [action-if-connected]
set spice/vnc password expire-time
run a qemu-io command on a block device
			-d: [device] is a device ID rather than a drive ID or node name
json:-j,path:s,property:s,value:S
set QOM property.
			-j: the value is specified in json format.
set breakpoint at the specified instruction count
replay execution to the specified instruction count
dirty_ring:-r,dirty_bitmap:-b,second:l,sample_pages_per_GB:l?
[-r] [-b] second [sample_pages_per_GB]
start a round of guest dirty rate measurement (using -r to
			 specify dirty ring as the method of calculation and
			 -b to specify dirty bitmap as method of calculation)
set dirty page rate limit, use cpu_index to set limit
					 on a specified virtual cpu
cancel dirty page rate limit, use cpu_index to cancel
					 limit on a specified virtual cpu
show various information about the system state
dump the FDT in dtb format to 'filename'
show info of one block device or all block devices (-n: show named nodes; -v: show details)
show progress of ongoing block device operations
show the cpu registers (-a: show register info for all cpus; vcpu: specific vCPU to query; show the current CPU's registers if no argument is specified)
show local apic state (apic-id: local apic to read, default is which of current CPU)
show the interrupts statistics (if available)
show virtual to physical memory mappings
show the active virtual memory mappings
flatview:-f,dispatch_tree:-d,owner:-o,disabled:-D
show memory tree (-f: dump flat view for address spaces;-d: dump dispatch tree, valid with -f only);-o: dump region owners/parents;-D: dump disabled regions
show dynamic compiler opcode counters
show synchronization profiling info, up to max entries (default: 10), sorted by total wait time. (-m: sort by mean wait time; -n: do not coalesce objects with the same call site)
show the currently saved VM snapshots
show the current VM status (running|paused)
show which guest mouse is receiving events
show user network stack connection states
show current migration capabilities
show current migration parameters
show device tree (-b: brief, omit properties)
show available trace-events & their state (name: event name pattern; vcpu: vCPU to query, default is any)
Show rocker OF-DPA flow tables
Display the latest dump status
Display system ramblock information
Show information about hotpluggable CPUs
Show Virtual Machine Generation ID
show the amount of initially allocated and present hotpluggable (if enabled) memory in bytes.
show record/replay information
show dirty page limit information of all vCPU
show statistics for the given target (vm or vcpu); optionally filter byname (comma-separated list, or * for all) and provider
List all available virtio devices
Display status of a given virtio device
Display status of a given virtio queue
Display status of a given vhost queue
Display element of a given virtio queue
TCG translation block cache size
Map jit pages into separate RW and RX regions
Only put one guest insn in each translation block
No MTTCG when icount is enabled
tcg_ops->debug_check_breakpoint
(tb_cflags(tb) & CF_PCREL) || tb->pc == pc
Trace %d: %p [%08lx/%016lx/%08x/%08x] %s
%d@%zu.%06zu:exec_tb_exit tb:%p flags=0x%x
exec_tb_exit tb:%p flags=0x%x
Stopped execution of TB chain before %p [%016lx] %s
n < ARRAY_SIZE(tb->jmp_list_next)
Linking TBs %p index %d -> %p
%d@%zu.%06zu:exec_tb tb:%p pc=0x%lx
Warning: The guest is now late by %.1f to %.1f seconds
ptr_locked == 1 && dest->cflags & CF_INVALID
%d@%zu.%06zu:translate_block tb:%p, pc:0x%lx, tb_code:%p
translate_block tb:%p, pc:0x%lx, tb_code:%p
Restarting code generation for code_gen_buffer overflow
Restarting code generation with smaller translation block (max %d insns)
Restarting code generation with re-locked pages
  -- guest addr 0x%016lx + tb prologue
  -- tb slow paths + alignment
cpu_io_recompile: could not find TB for pc=%p
cpu_io_recompile: rewound execution of TB to %016lx
offset == db->record_start + db->record_len
db->record_len + size <= sizeof(db->record)
((base ^ pc) & TARGET_PAGE_MASK) == 0
((base ^ last) & TARGET_PAGE_MASK) == 0
../accel/tcg/ldst_atomicity.c.inc
%d@%zu.%06zu:memory_notdirty_write_access 0x%lx ram_addr 0x%lx size %u
memory_notdirty_write_access 0x%lx ram_addr 0x%lx size %u
%d@%zu.%06zu:memory_notdirty_set_dirty 0x%lx
memory_notdirty_set_dirty 0x%lx
%d@%zu.%06zu:store_atom16_fallback mop:0x%x, ra:0x%lx
store_atom16_fallback mop:0x%x, ra:0x%lx
-(addr | TARGET_PAGE_MASK) >= size
../accel/tcg/atomic_common.c.inc
%d@%zu.%06zu:kvm_dirty_ring_reap_vcpu vcpu %d
kvm_dirty_ring_reap_vcpu vcpu %d
%d@%zu.%06zu:kvm_dirty_ring_page vcpu %d fetch %u offset 0x%lx
kvm_dirty_ring_page vcpu %d fetch %u offset 0x%lx
%d@%zu.%06zu:kvm_slots_grow %u -> %u
Restoring resisters after reset: 
Failed to put registers after reset: %s
Configure KVM in-kernel irqchip
Size of KVM dirty page ring buffer (default: 0, i.e. use bitmap)
Path to the device node to use (default: /dev/kvm)
Allow energy related MSRs for RAPL interface in Guest
Socket Path for comminucating with the Virtual MSR helper daemon
KVM stats: failed to read stats header: expected %zu actual %zu
KVM stats: failed to read stats descriptors: expected %zu actual %zu
Failed to synchronize CPU state: 
Putting registers after init: 
Failed to put registers after init: %s
%d@%zu.%06zu:kvm_irqchip_release_virq virq %d
kvm_irqchip_release_virq virq %d
KVM stats: failed to read data: expected %zu actual %zu
dirty-ring-size must be a power of two.
%d@%zu.%06zu:kvm_resample_fd_notify gsi %d
kvm_resample_fd_notify gsi %d
%d@%zu.%06zu:kvm_park_vcpu index: %d id: %lu
kvm_park_vcpu index: %d id: %lu
%d@%zu.%06zu:kvm_unpark_vcpu id: %lu %s
ROUND_UP(max_slot_size, qemu_real_host_page_size()) == max_slot_size
%d@%zu.%06zu:kvm_irqchip_add_msi_route dev %s vector %d virq %d
kvm_irqchip_add_msi_route dev %s vector %d virq %d
%d@%zu.%06zu:kvm_irqchip_update_msi_route Updating MSI route virq=%d
kvm_irqchip_update_msi_route Updating MSI route virq=%d
%d@%zu.%06zu:kvm_ioctl type 0x%lx, arg %p
%d@%zu.%06zu:kvm_destroy_vcpu index: %d id: %lu
kvm_destroy_vcpu index: %d id: %lu
%d@%zu.%06zu:kvm_failed_get_vcpu_mmap_size 
kvm_failed_get_vcpu_mmap_size 
%d@%zu.%06zu:kvm_vm_ioctl type 0x%lx, arg %p
kvm_vm_ioctl type 0x%lx, arg %p
KVM_CREATE_VCPU IOCTL failed for vCPU %lu
%d@%zu.%06zu:kvm_create_vcpu index: %d, id: %lu, kvm fd: %d
kvm_create_vcpu index: %d, id: %lu, kvm fd: %d
(attr & kvm_supported_memory_attributes) == attr
failed to set memory (0x%lx+0x%lx) with attr 0x%lx error '%s'
%d@%zu.%06zu:kvm_convert_memory start 0x%lx size 0x%lx %s
kvm_convert_memory start 0x%lx size 0x%lx %s
Convert non guest_memfd backed memory region (0x%lx ,+ 0x%lx) to %s
bmap_start % BITS_PER_LONG == 0
%s: KVM_CLEAR_DIRTY_LOG failed, slot=%d, start=0x%lx, size=0x%x, errno=%d
%d@%zu.%06zu:kvm_clear_dirty_log slot#%d start 0x%lx size 0x%x
kvm_clear_dirty_log slot#%d start 0x%lx size 0x%x
%s: kvm log clear failed: mr=%s offset=%lx size=%lx
kvm_async_interrupts_enabled()
%d@%zu.%06zu:kvm_irqchip_commit_routes 
%d@%zu.%06zu:kvm_set_ioeventfd_pio fd: %d @0x%x val=0x%x assign: %d size: %d match: %d
kvm_set_ioeventfd_pio fd: %d @0x%x val=0x%x assign: %d size: %d match: %d
%s: error deleting ioeventfd: %s (%d)
%s: error adding ioeventfd: %s (%d)
%d@%zu.%06zu:kvm_set_ioeventfd_mmio fd: %d @0x%lx val=0x%x assign: %d size: %d match: %d
kvm_set_ioeventfd_mmio fd: %d @0x%lx val=0x%x assign: %d size: %d match: %d
%d@%zu.%06zu:kvm_dirty_ring_reap reaped %lu pages (took %li us)
kvm_dirty_ring_reap reaped %lu pages (took %li us)
%d@%zu.%06zu:kvm_dirty_ring_reaper %s
%s: KVM_GET_DIRTY_LOG failed with %d
%d@%zu.%06zu:kvm_dirty_ring_flush %d
%d@%zu.%06zu:kvm_set_user_memory AddrSpace#%d Slot#%d flags=0x%x gpa=0x%lx size=0x%lx ua=0x%lx guest_memfd=%d guest_memfd_offset=0x%lx ret=%d
kvm_set_user_memory AddrSpace#%d Slot#%d flags=0x%x gpa=0x%lx size=0x%lx ua=0x%lx guest_memfd=%d guest_memfd_offset=0x%lx ret=%d
%s: KVM_SET_USER_MEMORY_REGION2 failed, slot=%d, start=0x%lx, size=0x%lx, flags=0x%x, guest_memfd=%d, guest_memfd_offset=0x%lx: %s
%s: KVM_SET_USER_MEMORY_REGION failed, slot=%d, start=0x%lx, size=0x%lx: %s
%s: error unregistering slot: %s
%s: error registering slot: %s
%s: failed to set memory attribute private: %s
TARGET_PAGE_SIZE <= qemu_real_host_page_size()
Could not access KVM kernel module: %m
ioctl(KVM_CREATE_VM) failed: %s
Number of %s cpus requested (%d) exceeds the recommended cpus supported by KVM (%d)
Number of %s cpus requested (%d) exceeds the maximum cpus supported by KVM (%d)
KVM dirty ring not available, using bitmap method
KVM dirty ring size %u too big (maximum is %ld).  Please use a smaller value.
Enabling of KVM dirty ring failed: %s. Suggested minimum value is 1024.
Enabling of KVM dirty ring's backup bitmap failed: %s. 
Trying to enable capability %lu of KVM_CAP_MANUAL_DIRTY_LOG_PROTECT2 but failed. Falling back to the legacy mode. 
s->kernel_irqchip_split != ON_OFF_AUTO_AUTO
Enable kernel irqchip failed: %s
Split IRQ chip mode not supported.
Create kernel irqchip failed: %s
%d@%zu.%06zu:kvm_vcpu_ioctl cpu_index %d, type 0x%lx, arg %p
kvm_vcpu_ioctl cpu_index %d, type 0x%lx, arg %p
%d@%zu.%06zu:kvm_init_vcpu index: %d id: %lu
kvm_init_vcpu index: %d id: %lu
kvm_init_vcpu: kvm_create_vcpu failed (%lu)
kvm_init_vcpu: KVM_GET_VCPU_MMAP_SIZE failed
kvm_init_vcpu: mmap'ing vcpu state failed (%lu)
kvm_init_vcpu: kvm_arch_init_vcpu failed (%lu)
%d@%zu.%06zu:kvm_interrupt_exit_request 
%d@%zu.%06zu:kvm_io_window_exit 
%d@%zu.%06zu:kvm_run_exit cpu_index %d, reason %d
kvm_run_exit cpu_index %d, reason %d
KVM: unknown exit, hardware reason %lx
KVM internal error. Suberror: %d
%d@%zu.%06zu:kvm_dirty_ring_full vcpu %d
%d@%zu.%06zu:kvm_run_exit_system_event cpu_index %d, system_even_type %u
kvm_run_exit_system_event cpu_index %d, system_even_type %u
%d@%zu.%06zu:kvm_memory_fault start 0x%lx size 0x%lx flags 0x%lx
kvm_memory_fault start 0x%lx size 0x%lx flags 0x%lx
KVM_EXIT_MEMORY_FAULT: Unknown flag 0x%lx
%d@%zu.%06zu:kvm_device_ioctl dev fd %d, type 0x%lx, arg %p
kvm_device_ioctl dev fd %d, type 0x%lx, arg %p
KVM_%s_DEVICE_ATTR failed: Group %d attr 0x%016lx
%d@%zu.%06zu:kvm_failed_reg_set Warning: Unable to set ONEREG %lu to KVM: %s
kvm_failed_reg_set Warning: Unable to set ONEREG %lu to KVM: %s
%d@%zu.%06zu:kvm_failed_reg_get Warning: Unable to retrieve ONEREG %lu from KVM: %s
kvm_failed_reg_get Warning: Unable to retrieve ONEREG %lu from KVM: %s
KVM does not support guest_memfd
Error creating KVM guest_memfd
KVM_CAP_DESTROY_MEMORY_REGION_WORKS
KVM_CAP_JOIN_MEMORY_REGIONS_WORKS
<?xml version="1.0"?>
<!-- Copyright (C) 2010-2017 Free Software Foundation, Inc.
     Copying and distribution of this file, with or without modification,
     are permitted in any medium without royalty provided the copyright
     notice and this notice are preserved.  -->
<!-- x86_64 64bit -->
<!DOCTYPE target SYSTEM "gdb-target.dtd">
<feature name="org.gnu.gdb.i386.core">
  <flags id="x64_eflags" size="4">
	<field name="" start="22" end="31"/>
	<field name="ID" start="21" end="21"/>
	<field name="VIP" start="20" end="20"/>
	<field name="VIF" start="19" end="19"/>
	<field name="AC" start="18" end="18"/>
	<field name="VM" start="17" end="17"/>
	<field name="RF" start="16" end="16"/>
	<field name="" start="15" end="15"/>
	<field name="NT" start="14" end="14"/>
	<field name="IOPL" start="12" end="13"/>
	<field name="OF" start="11" end="11"/>
	<field name="DF" start="10" end="10"/>
	<field name="IF" start="9" end="9"/>
	<field name="TF" start="8" end="8"/>
	<field name="SF" start="7" end="7"/>
	<field name="ZF" start="6" end="6"/>
	<field name="" start="5" end="5"/>
	<field name="AF" start="4" end="4"/>
	<field name="" start="3" end="3"/>
	<field name="PF" start="2" end="2"/>
	<field name="" start="1" end="1"/>
	<field name="CF" start="0" end="0"/>
  </flags>
  <!-- General registers -->
  <reg name="rax" bitsize="64" type="int64" regnum="0"/>
  <reg name="rbx" bitsize="64" type="int64"/>
  <reg name="rcx" bitsize="64" type="int64"/>
  <reg name="rdx" bitsize="64" type="int64"/>
  <reg name="rsi" bitsize="64" type="int64"/>
  <reg name="rdi" bitsize="64" type="int64"/>
  <reg name="rbp" bitsize="64" type="data_ptr"/>
  <reg name="rsp" bitsize="64" type="data_ptr"/>
  <reg name="r8" bitsize="64" type="int64"/>
  <reg name="r9" bitsize="64" type="int64"/>
  <reg name="r10" bitsize="64" type="int64"/>
  <reg name="r11" bitsize="64" type="int64"/>
  <reg name="r12" bitsize="64" type="int64"/>
  <reg name="r13" bitsize="64" type="int64"/>
  <reg name="r14" bitsize="64" type="int64"/>
  <reg name="r15" bitsize="64" type="int64"/>
  <reg name="rip" bitsize="64" type="code_ptr"/>
  <reg name="eflags" bitsize="32" type="x64_eflags"/>
  <!-- Segment registers -->
  <reg name="cs" bitsize="32" type="int32"/>
  <reg name="ss" bitsize="32" type="int32"/>
  <reg name="ds" bitsize="32" type="int32"/>
  <reg name="es" bitsize="32" type="int32"/>
  <reg name="fs" bitsize="32" type="int32"/>
  <reg name="gs" bitsize="32" type="int32"/>
  <!-- Segment descriptor caches and TLS base MSRs -->
  <!--reg name="cs_base" bitsize="64" type="int64"/>
  <reg name="ss_base" bitsize="64" type="int64"/>
  <reg name="ds_base" bitsize="64" type="int64"/>
  <reg name="es_base" bitsize="64" type="int64"/-->
  <reg name="fs_base" bitsize="64" type="int64"/>
  <reg name="gs_base" bitsize="64" type="int64"/>
  <reg name="k_gs_base" bitsize="64" type="int64"/>
  <!-- Control registers -->
  <flags id="x64_cr0" size="8">
	<field name="PG" start="31" end="31"/>
	<field name="CD" start="30" end="30"/>
	<field name="NW" start="29" end="29"/>
	<field name="AM" start="18" end="18"/>
	<field name="WP" start="16" end="16"/>
	<field name="NE" start="5" end="5"/>
	<field name="ET" start="4" end="4"/>
	<field name="TS" start="3" end="3"/>
	<field name="EM" start="2" end="2"/>
	<field name="MP" start="1" end="1"/>
	<field name="PE" start="0" end="0"/>
  </flags>
  <flags id="x64_cr3" size="8">
	<field name="PDBR" start="12" end="63"/>
	<!--field name="" start="3" end="11"/>
	<field name="WT" start="2" end="2"/>
	<field name="CD" start="1" end="1"/>
	<field name="" start="0" end="0"/-->
	<field name="PCID" start="0" end="11"/>
  </flags>
  <flags id="x64_cr4" size="8">
	<field name="PKE" start="22" end="22"/>
	<field name="SMAP" start="21" end="21"/>
	<field name="SMEP" start="20" end="20"/>
	<field name="OSXSAVE" start="18" end="18"/>
	<field name="PCIDE" start="17" end="17"/>
	<field name="FSGSBASE" start="16" end="16"/>
	<field name="SMXE" start="14" end="14"/>
	<field name="VMXE" start="13" end="13"/>
	<field name="LA57" start="12" end="12"/>
	<field name="UMIP" start="11" end="11"/>
	<field name="OSXMMEXCPT" start="10" end="10"/>
	<field name="OSFXSR" start="9" end="9"/>
	<field name="PCE" start="8" end="8"/>
	<field name="PGE" start="7" end="7"/>
	<field name="MCE" start="6" end="6"/>
	<field name="PAE" start="5" end="5"/>
	<field name="PSE" start="4" end="4"/>
	<field name="DE" start="3" end="3"/>
	<field name="TSD" start="2" end="2"/>
	<field name="PVI" start="1" end="1"/>
	<field name="VME" start="0" end="0"/>
  </flags>
  <flags id="x64_efer" size="8">
	<field name="TCE" start="15" end="15"/>
	<field name="FFXSR" start="14" end="14"/>
	<field name="LMSLE" start="13" end="13"/>
	<field name="SVME" start="12" end="12"/>
	<field name="NXE" start="11" end="11"/>
	<field name="LMA" start="10" end="10"/>
	<field name="LME" start="8" end="8"/>
	<field name="SCE" start="0" end="0"/>
  </flags>
  <reg name="cr0" bitsize="64" type="x64_cr0"/>
  <reg name="cr2" bitsize="64" type="int64"/>
  <reg name="cr3" bitsize="64" type="x64_cr3"/>
  <reg name="cr4" bitsize="64" type="x64_cr4"/>
  <reg name="cr8" bitsize="64" type="int64"/>
  <reg name="efer" bitsize="64" type="x64_efer"/>
  <!-- x87 FPU -->
  <reg name="st0" bitsize="80" type="i387_ext"/>
  <reg name="st1" bitsize="80" type="i387_ext"/>
  <reg name="st2" bitsize="80" type="i387_ext"/>
  <reg name="st3" bitsize="80" type="i387_ext"/>
  <reg name="st4" bitsize="80" type="i387_ext"/>
  <reg name="st5" bitsize="80" type="i387_ext"/>
  <reg name="st6" bitsize="80" type="i387_ext"/>
  <reg name="st7" bitsize="80" type="i387_ext"/>
  <reg name="fctrl" bitsize="32" type="int" group="float"/>
  <reg name="fstat" bitsize="32" type="int" group="float"/>
  <reg name="ftag" bitsize="32" type="int" group="float"/>
  <reg name="fiseg" bitsize="32" type="int" group="float"/>
  <reg name="fioff" bitsize="32" type="int" group="float"/>
  <reg name="foseg" bitsize="32" type="int" group="float"/>
  <reg name="fooff" bitsize="32" type="int" group="float"/>
  <reg name="fop" bitsize="32" type="int" group="float"/>
  <vector id="v4f" type="ieee_single" count="4"/>
  <vector id="v2d" type="ieee_double" count="2"/>
  <vector id="v16i8" type="int8" count="16"/>
  <vector id="v8i16" type="int16" count="8"/>
  <vector id="v4i32" type="int32" count="4"/>
  <vector id="v2i64" type="int64" count="2"/>
  <union id="vec128">
	<field name="v4_float" type="v4f"/>
	<field name="v2_double" type="v2d"/>
	<field name="v16_int8" type="v16i8"/>
	<field name="v8_int16" type="v8i16"/>
	<field name="v4_int32" type="v4i32"/>
	<field name="v2_int64" type="v2i64"/>
	<field name="uint128" type="uint128"/>
  </union>
  <flags id="x64_mxcsr" size="4">
	<field name="IE" start="0" end="0"/>
	<field name="DE" start="1" end="1"/>
	<field name="ZE" start="2" end="2"/>
	<field name="OE" start="3" end="3"/>
	<field name="UE" start="4" end="4"/>
	<field name="PE" start="5" end="5"/>
	<field name="DAZ" start="6" end="6"/>
	<field name="IM" start="7" end="7"/>
	<field name="DM" start="8" end="8"/>
	<field name="ZM" start="9" end="9"/>
	<field name="OM" start="10" end="10"/>
	<field name="UM" start="11" end="11"/>
	<field name="PM" start="12" end="12"/>
	<field name="FZ" start="15" end="15"/>
  </flags>
  <reg name="xmm0" bitsize="128" type="vec128"/>
  <reg name="xmm1" bitsize="128" type="vec128"/>
  <reg name="xmm2" bitsize="128" type="vec128"/>
  <reg name="xmm3" bitsize="128" type="vec128"/>
  <reg name="xmm4" bitsize="128" type="vec128"/>
  <reg name="xmm5" bitsize="128" type="vec128"/>
  <reg name="xmm6" bitsize="128" type="vec128"/>
  <reg name="xmm7" bitsize="128" type="vec128"/>
  <reg name="xmm8" bitsize="128" type="vec128"/>
  <reg name="xmm9" bitsize="128" type="vec128"/>
  <reg name="xmm10" bitsize="128" type="vec128"/>
  <reg name="xmm11" bitsize="128" type="vec128"/>
  <reg name="xmm12" bitsize="128" type="vec128"/>
  <reg name="xmm13" bitsize="128" type="vec128"/>
  <reg name="xmm14" bitsize="128" type="vec128"/>
  <reg name="xmm15" bitsize="128" type="vec128"/>
  <reg name="mxcsr" bitsize="32" type="x64_mxcsr" group="vector"/>
</feature>
qapi/qapi-visit-machine-target.c
%d@%zu.%06zu:qmp_enter_query_cpu_model_expansion %s
qmp_enter_query_cpu_model_expansion %s
%d@%zu.%06zu:qmp_exit_query_cpu_model_expansion %s %d
qmp_exit_query_cpu_model_expansion %s %d
%d@%zu.%06zu:qmp_enter_query_cpu_definitions %s
qmp_enter_query_cpu_definitions %s
%d@%zu.%06zu:qmp_exit_query_cpu_definitions %s %d
qmp_exit_query_cpu_definitions %s %d
%d@%zu.%06zu:qmp_enter_rtc_reset_reinjection %s
qmp_enter_rtc_reset_reinjection %s
%d@%zu.%06zu:qmp_exit_rtc_reset_reinjection %s %d
qmp_exit_rtc_reset_reinjection %s %d
%d@%zu.%06zu:qmp_enter_query_sev %s
%d@%zu.%06zu:qmp_exit_query_sev %s %d
%d@%zu.%06zu:qmp_enter_query_sev_launch_measure %s
qmp_enter_query_sev_launch_measure %s
%d@%zu.%06zu:qmp_exit_query_sev_launch_measure %s %d
qmp_exit_query_sev_launch_measure %s %d
%d@%zu.%06zu:qmp_enter_query_sev_capabilities %s
qmp_enter_query_sev_capabilities %s
%d@%zu.%06zu:qmp_exit_query_sev_capabilities %s %d
qmp_exit_query_sev_capabilities %s %d
%d@%zu.%06zu:qmp_enter_sev_inject_launch_secret %s
qmp_enter_sev_inject_launch_secret %s
%d@%zu.%06zu:qmp_exit_sev_inject_launch_secret %s %d
qmp_exit_sev_inject_launch_secret %s %d
%d@%zu.%06zu:qmp_enter_query_sev_attestation_report %s
qmp_enter_query_sev_attestation_report %s
%d@%zu.%06zu:qmp_exit_query_sev_attestation_report %s %d
qmp_exit_query_sev_attestation_report %s %d
%d@%zu.%06zu:qmp_enter_query_sgx %s
%d@%zu.%06zu:qmp_exit_query_sgx %s %d
%d@%zu.%06zu:qmp_enter_query_sgx_capabilities %s
qmp_enter_query_sgx_capabilities %s
%d@%zu.%06zu:qmp_exit_query_sgx_capabilities %s %d
qmp_exit_query_sgx_capabilities %s %d
%d@%zu.%06zu:qmp_enter_xen_event_list %s
%d@%zu.%06zu:qmp_exit_xen_event_list %s %d
qmp_exit_xen_event_list %s %d
%d@%zu.%06zu:qmp_enter_xen_event_inject %s
qmp_enter_xen_event_inject %s
%d@%zu.%06zu:qmp_exit_xen_event_inject %s %d
qmp_exit_xen_event_inject %s %d
blockdev-snapshot-internal-sync
invalid_zone_append_operations
corrected-persistent-error-count
corrected-volatile-error-count
dirty-limit-throttle-time-per-round
cxl-inject-uncorrectable-errors
cxl-inject-memory-module-event
cxl-inject-general-media-event
x-query-virtio-vhost-queue-status
query-hv-balloon-status-report
NETDEV_VHOST_USER_DISCONNECTED
query-dump-guest-memory-capability
blockdev-snapshot-delete-internal-sync
x-debug-block-dirty-bitmap-sha256
Attempt to set link property '%s' on device '%s' (type '%s') after it was realized
Property value for '%s' has bits outside mask '0x%lx'
Property %s.%s doesn't take value %lu (maximum: %u)
array size property %s may not be set more than once
prop->info == &qdev_prop_bit64
Attempt to set property '%s' on device '%s' (type '%s') after it was realized
Attempt to set property '%s' on anonymous device (type '%s') after it was realized
Property '%s.%s' can't take value '%s', it's in use
Property '%s.%s' doesn't take value '%s'
global %s.%s has invalid class name
dev->parent_bus || !dc->bus_type
dc->bus_type && object_dynamic_cast(OBJECT(bus), dc->bus_type)
%d@%zu.%06zu:qdev_update_parent_bus obj=%p(%s) old_parent=%p(%s) new_parent=%p(%s)
qdev_update_parent_bus obj=%p(%s) old_parent=%p(%s) new_parent=%p(%s)
!dev->realized && !dev->parent_bus
!DEVICE_GET_CLASS(dev)->bus_type
object_dynamic_cast(container, TYPE_CONTAINER)
Device %s is not migratable, but --only-migratable was specified
%d@%zu.%06zu:resettable_phase_hold_begin obj=%p(%s) count=%d type=%d
resettable_phase_hold_begin obj=%p(%s) count=%d type=%d
%d@%zu.%06zu:resettable_phase_hold_exec obj=%p(%s) method=%d
resettable_phase_hold_exec obj=%p(%s) method=%d
%d@%zu.%06zu:resettable_phase_hold_end obj=%p(%s) count=%d
resettable_phase_hold_end obj=%p(%s) count=%d
%d@%zu.%06zu:resettable_phase_exit_begin obj=%p(%s) count=%d type=%d
resettable_phase_exit_begin obj=%p(%s) count=%d type=%d
%d@%zu.%06zu:resettable_phase_exit_exec obj=%p(%s) method=%d
resettable_phase_exit_exec obj=%p(%s) method=%d
%d@%zu.%06zu:resettable_phase_exit_end obj=%p(%s) count=%d
resettable_phase_exit_end obj=%p(%s) count=%d
%d@%zu.%06zu:resettable_phase_enter_begin obj=%p(%s) count=%d type=%d
resettable_phase_enter_begin obj=%p(%s) count=%d type=%d
%d@%zu.%06zu:resettable_phase_enter_exec obj=%p(%s) type=%d method=%d
resettable_phase_enter_exec obj=%p(%s) type=%d method=%d
%d@%zu.%06zu:resettable_phase_enter_end obj=%p(%s) count=%d
resettable_phase_enter_end obj=%p(%s) count=%d
%d@%zu.%06zu:resettable_reset_assert_begin obj=%p cold=%d
resettable_reset_assert_begin obj=%p cold=%d
%d@%zu.%06zu:resettable_reset_assert_end obj=%p
resettable_reset_assert_end obj=%p
%d@%zu.%06zu:resettable_reset_release_begin obj=%p cold=%d
resettable_reset_release_begin obj=%p cold=%d
%d@%zu.%06zu:resettable_reset_release_end obj=%p
resettable_reset_release_end obj=%p
%d@%zu.%06zu:resettable_reset obj=%p cold=%d
resettable_reset obj=%p cold=%d
!enter_phase_in_progress && !exit_phase_in_progress
%d@%zu.%06zu:resettable_change_parent obj=%p from=%p(%d) to=%p(%d)
resettable_change_parent obj=%p from=%p(%d) to=%p(%d)
/home/virus/AMD/AMD/include/hw/irq.h
/home/virus/AMD/AMD/include/hw/clock.h
%d@%zu.%06zu:clock_disconnect '%s'
%d@%zu.%06zu:clock_update '%s', src='%s', val=%luHz cb=%d
clock_update '%s', src='%s', val=%luHz cb=%d
%d@%zu.%06zu:clock_set '%s', %luHz->%luHz
%d@%zu.%06zu:clock_propagate '%s'
%d@%zu.%06zu:clock_set_source '%s', src='%s'
clock_set_source '%s', src='%s'
%d@%zu.%06zu:clock_set_mul_div '%s', mul: %u -> %u, div: %u -> %u
clock_set_mul_div '%s', mul: %u -> %u, div: %u -> %u
elem->offset > sizeof(DeviceState)
Can not find clock-in '%s' for device type '%s'
Can not find clock-out '%s' for device type '%s'
Type '%s' is missing its parent '%s'
Registering `%s' which already exists
abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_.
Registering '%s' with illegal type name
parent->class_size <= ti->class_size
parent->instance_size <= ti->instance_size
missing interface '%s' for object '%s'
%d@%zu.%06zu:object_dynamic_cast_assert %s->%s (%s:%d:%s)
object_dynamic_cast_assert %s->%s (%s:%d:%s)
%s:%d:%s: Object %p is not an instance of type %s
%d@%zu.%06zu:object_class_dynamic_cast_assert %s->%s (%s:%d:%s)
object_class_dynamic_cast_assert %s->%s (%s:%d:%s)
type->instance_size >= sizeof(Object)
!object_class_property_find(klass, name)
attempt to add duplicate property '%s' to object (type '%s')
Property '%s.%s' is not readable
Property '%s.%s' is not writable
Invalid parameter type for '%s', expected: string
Invalid parameter type for '%s', expected: boolean
Invalid parameter type for '%s', expected: int
Invalid parameter type for '%s', expected: uint
Property %s on %s is not '%s' enum type
Path '%s' does not uniquely identify an object
Invalid parameter type for '%s', expected: %s
More than one object of type %s
List of user creatable objects:
Identifiers consist of letters, digits, '-', '.', '_', starting with a letter.
object type '%s' isn't supported by object-add
object '%s' is in use, can not be deleted
/home/virus/AMD/AMD/include/system/event-loop-base.h
%s value must be in range [0, %ld]
%d@%zu.%06zu:gdbstub_io_binaryreply 0x%04zx: %s
gdbstub_io_binaryreply 0x%04zx: %s
%d@%zu.%06zu:gdbstub_io_reply Sent: %s
;ReverseStep+;ReverseContinue+
;vContSupported+;multiprocess+
<architecture>%s</architecture>
%d@%zu.%06zu:gdbstub_op_extra_info Thread extra info: %s
gdbstub_op_extra_info Thread extra info: %s
<?xml version="1.0"?><!DOCTYPE feature SYSTEM "gdb-target.dtd"><feature name="%s">
<reg name="%s" bitsize="%d" regnum="%d" type="%s" group="%s"/>
<reg name="%s" bitsize="%d" regnum="%d" type="%s"/>
len == gdbserver_state.mem_buf->len
Error: Bad gdb register numbering for '%s', expected %d got %d
%d@%zu.%06zu:gdbstub_err_got_nack Got NACK, retransmitting
gdbstub_err_got_nack Got NACK, retransmitting
%d@%zu.%06zu:gdbstub_io_got_ack Got ACK
%d@%zu.%06zu:gdbstub_io_got_unexpected Got 0x%02x when expecting ACK/NACK
gdbstub_io_got_unexpected Got 0x%02x when expecting ACK/NACK
%d@%zu.%06zu:gdbstub_err_unexpected_runpkt unexpected packet (0x%02x) while target running
gdbstub_err_unexpected_runpkt unexpected packet (0x%02x) while target running
%d@%zu.%06zu:gdbstub_err_garbage received garbage between packets: 0x%02x
gdbstub_err_garbage received garbage between packets: 0x%02x
%d@%zu.%06zu:gdbstub_err_overrun command buffer overrun, dropping command
gdbstub_err_overrun command buffer overrun, dropping command
%d@%zu.%06zu:gdbstub_err_invalid_repeat got invalid RLE count: 0x%02x
gdbstub_err_invalid_repeat got invalid RLE count: 0x%02x
%d@%zu.%06zu:gdbstub_err_invalid_rle got invalid RLE sequence
gdbstub_err_invalid_rle got invalid RLE sequence
%d@%zu.%06zu:gdbstub_err_checksum_invalid got invalid command checksum digit: 0x%02x
gdbstub_err_checksum_invalid got invalid command checksum digit: 0x%02x
%d@%zu.%06zu:gdbstub_err_checksum_incorrect got command packet with incorrect checksum, expected=0x%02x, received=0x%02x
gdbstub_err_checksum_incorrect got command packet with incorrect checksum, expected=0x%02x, received=0x%02x
%d@%zu.%06zu:gdbstub_io_command Received: %s
gdbstub_io_command Received: %s
/home/virus/AMD/AMD/include/hw/cpu/cluster.h
cluster->cluster_id != UINT32_MAX
%d@%zu.%06zu:gdbstub_hit_watchpoint Watchpoint hit, type="%s" cpu=%d, vaddr=0x%lx
gdbstub_hit_watchpoint Watchpoint hit, type="%s" cpu=%d, vaddr=0x%lx
%d@%zu.%06zu:gdbstub_hit_break RUN_STATE_DEBUG
gdbstub_hit_break RUN_STATE_DEBUG
%d@%zu.%06zu:gdbstub_hit_paused RUN_STATE_PAUSED
gdbstub_hit_paused RUN_STATE_PAUSED
%d@%zu.%06zu:gdbstub_hit_shutdown RUN_STATE_SHUTDOWN
gdbstub_hit_shutdown RUN_STATE_SHUTDOWN
%d@%zu.%06zu:gdbstub_hit_io_error RUN_STATE_IO_ERROR
gdbstub_hit_io_error RUN_STATE_IO_ERROR
%d@%zu.%06zu:gdbstub_hit_watchdog RUN_STATE_WATCHDOG
gdbstub_hit_watchdog RUN_STATE_WATCHDOG
%d@%zu.%06zu:gdbstub_hit_internal_error RUN_STATE_INTERNAL_ERROR
gdbstub_hit_internal_error RUN_STATE_INTERNAL_ERROR
%d@%zu.%06zu:gdbstub_hit_unknown Unknown run state=0x%x
gdbstub_hit_unknown Unknown run state=0x%x
gdbstub: meaningless to attach gdb to a machine without any CPU.
gdbstub: current accelerator doesn't support guest debugging
gdbstub: missing connection string
%d@%zu.%06zu:gdbstub_op_start Starting gdbstub using device %s
gdbstub_op_start Starting gdbstub using device %s
,wait=off,nodelay=on,server=on
gdbstub: couldn't create chardev
%d@%zu.%06zu:gdbstub_op_exiting notifying exit with code=0x%02x
gdbstub_op_exiting notifying exit with code=0x%02x
gdbserver_state.mem_buf->len == 0
%d@%zu.%06zu:gdbstub_op_continue Continuing all CPUs
gdbstub_op_continue Continuing all CPUs
%d@%zu.%06zu:gdbstub_op_stepping Stepping CPU %d
gdbstub_op_stepping Stepping CPU %d
%d@%zu.%06zu:gdbstub_op_continue_cpu Continuing CPU %d
gdbstub_op_continue_cpu Continuing CPU %d
failed to map shared memory for execute
allocate %zu bytes for jit buffer
region.start_aligned == s->code_gen_buffer
size <= s->code_gen_buffer_size
/home/virus/AMD/AMD/tcg/i386/tcg-target.c.inc
cum.info_in_idx <= ARRAY_SIZE(info->in)
OP after optimization and liveness analysis:
s->gen_insn_end_off[num_insns] == off
vece <= (in_32 ? MO_32 : MO_64)
in_32 == NULL || in_64 == NULL
Could not open %s: %s, proceeding without perfmap
CLOCK_MONOTONIC is not available, proceeding without jitdump
Could not open %s: %s, proceeding without jitdump
Could not map %s: %s, proceeding without jitdump
%d@%zu.%06zu:migration_transferred_bytes qemu_file %lu multifd %lu RDMA %lu
migration_transferred_bytes qemu_file %lu multifd %lu RDMA %lu
is smaller than one target page size
is not a power of two number of pages
%d@%zu.%06zu:migration_pagecache_init Setting cache buckets to %ld
migration_pagecache_init Setting cache buckets to %ld
%d@%zu.%06zu:migration_pagecache_insert Error allocating page
migration_pagecache_insert Error allocating page
!(((uintptr_t)old_buf | (uintptr_t)new_buf | slen) % sizeof(long))
Invalid value %d expecting positive value <= %d
vmstate: put_nullptr must be called with pv == NULL
vmstate: get_nullptr expected VMS_NULLPTR_MARKER
%d@%zu.%06zu:put_qlist %s(%s v%d)
%d@%zu.%06zu:put_qlist_end %s(%s)
%d@%zu.%06zu:get_qlist %s(%s v%d)
%d@%zu.%06zu:get_qlist_end %s(%s)
%d@%zu.%06zu:put_gtree %s(%s/%s) nnodes=%d
put_gtree %s(%s/%s) nnodes=%d
%s : failed to save gtree (%d)
%d@%zu.%06zu:put_gtree_end %s(%s/%s) %d
%d@%zu.%06zu:put_qtailq %s v%d
%d@%zu.%06zu:put_qtailq_end %s %s
%d@%zu.%06zu:get_gtree %s(%s/%s) nnodes=%d
get_gtree %s(%s/%s) nnodes=%d
%s inconsistent stream when loading the gtree
%d@%zu.%06zu:get_gtree_end %s(%s/%s) %d
%d@%zu.%06zu:get_qtailq %s v%d
%d@%zu.%06zu:get_qtailq_end %s %s/%d
%d@%zu.%06zu:vmstate_field_exists %s:%s field_version %d version %d result %d
vmstate_field_exists %s:%s field_version %d version %d result %d
%d@%zu.%06zu:vmstate_n_elems %s: %d
field->flags & VMS_ARRAY_OF_POINTER
%d@%zu.%06zu:vmstate_load_state %s v%d
%s: incoming version_id %d is too new for local version_id %d
%d@%zu.%06zu:vmstate_load_state_end %s %s/%d
vmstate_load_state_end %s %s/%d
%s: incoming version_id %d is too old for local minimum version_id  %d
%d@%zu.%06zu:vmstate_load_state_field %s:%s exists=%d
vmstate_load_state_field %s:%s exists=%d
first_elem || !n_elems || !size
%d@%zu.%06zu:vmstate_load_field_error field "%s" load failed, ret = %d
vmstate_load_field_error field "%s" load failed, ret = %d
Input validation failed: %s/%s
%d@%zu.%06zu:vmstate_subsection_load %s
%d@%zu.%06zu:vmstate_subsection_load_bad %s: %s/%s
vmstate_subsection_load_bad %s: %s/%s
%d@%zu.%06zu:vmstate_subsection_load_good %s
vmstate_subsection_load_good %s
%d@%zu.%06zu:vmstate_save_state_top %s
%d@%zu.%06zu:vmstate_save_state_pre_save_res %s/%d
vmstate_save_state_pre_save_res %s/%d
%d@%zu.%06zu:vmstate_save_state_loop %s/%s[%d]
vmstate_save_state_loop %s/%s[%d]
Output state validation failed: %s/%s
!(field->flags & VMS_MUST_EXIST)
%d@%zu.%06zu:vmstate_subsection_save_top %s
vmstate_subsection_save_top %s
%d@%zu.%06zu:vmstate_subsection_save_loop %s/%s
vmstate_subsection_save_loop %s/%s
migrate: madvise DONTNEED failed %p %zd: %s
qemu_file_get_error(f) || !qemu_file_is_writable(f)
%d@%zu.%06zu:qemu_file_put_fd ioc %s, fd %d -> status %d
qemu_file_put_fd ioc %s, fd %d -> status %d
qemu_fclose: received fd %d was never claimed
%d@%zu.%06zu:qemu_file_fclose 
Partial write of size %zu, expected %zu
Partial read of size %zu, expected %zu
%s does not support fd passing
%d@%zu.%06zu:qemu_file_get_fd ioc %s -> fd %d
qemu_file_get_fd ioc %s -> fd %d
/home/virus/AMD/AMD/include/io/channel-buffer.h
/home/virus/AMD/AMD/include/io/channel-command.h
%d@%zu.%06zu:qio_channel_command_abort Command abort ioc=%p pid=%d
qio_channel_command_abort Command abort ioc=%p pid=%d
%d@%zu.%06zu:qio_channel_command_wait Command abort ioc=%p pid=%d ret=%d status=%d
qio_channel_command_wait Command abort ioc=%p pid=%d ret=%d status=%d
%d@%zu.%06zu:qio_channel_command_new_pid Command new pid ioc=%p writefd=%d readfd=%d pid=%d
qio_channel_command_new_pid Command new pid ioc=%p writefd=%d readfd=%d pid=%d
/home/virus/AMD/AMD/include/io/channel-file.h
Unable to seek to offset %lld whence %d in file
%d@%zu.%06zu:qio_channel_file_new_fd File new fd ioc=%p fd=%d
qio_channel_file_new_fd File new fd ioc=%p fd=%d
%d@%zu.%06zu:qio_channel_file_new_path File new fd ioc=%p path=%s flags=%d mode=%d fd=%d
qio_channel_file_new_path File new fd ioc=%p path=%s flags=%d mode=%d fd=%d
/home/virus/AMD/AMD/include/io/channel-null.h
%d@%zu.%06zu:qio_channel_null_new Null new ioc=%p
qio_channel_null_new Null new ioc=%p
Unable to get peer credentials
Unable to query remote socket address
Unable to query local socket address
Only %d FDs can be sent, got %zu
Process can't lock enough memory for using MSG_ZEROCOPY
%d@%zu.%06zu:qio_channel_socket_new Socket new ioc=%p
qio_channel_socket_new Socket new ioc=%p
%d@%zu.%06zu:qio_channel_socket_new_fd Socket new ioc=%p fd=%d
qio_channel_socket_new_fd Socket new ioc=%p fd=%d
%d@%zu.%06zu:qio_channel_socket_connect_sync Socket connect sync ioc=%p addr=%p
qio_channel_socket_connect_sync Socket connect sync ioc=%p addr=%p
%d@%zu.%06zu:qio_channel_socket_connect_fail Socket connect fail ioc=%p
qio_channel_socket_connect_fail Socket connect fail ioc=%p
%d@%zu.%06zu:qio_channel_socket_connect_complete Socket connect complete ioc=%p fd=%d
qio_channel_socket_connect_complete Socket connect complete ioc=%p fd=%d
%d@%zu.%06zu:qio_channel_socket_connect_async Socket connect async ioc=%p addr=%p
qio_channel_socket_connect_async Socket connect async ioc=%p addr=%p
%d@%zu.%06zu:qio_channel_socket_listen_sync Socket listen sync ioc=%p addr=%p num=%d
qio_channel_socket_listen_sync Socket listen sync ioc=%p addr=%p num=%d
%d@%zu.%06zu:qio_channel_socket_listen_fail Socket listen fail ioc=%p
qio_channel_socket_listen_fail Socket listen fail ioc=%p
%d@%zu.%06zu:qio_channel_socket_listen_complete Socket listen complete ioc=%p fd=%d
qio_channel_socket_listen_complete Socket listen complete ioc=%p fd=%d
%d@%zu.%06zu:qio_channel_socket_listen_async Socket listen async ioc=%p addr=%p num=%d
qio_channel_socket_listen_async Socket listen async ioc=%p addr=%p num=%d
%d@%zu.%06zu:qio_channel_socket_dgram_sync Socket dgram sync ioc=%p localAddr=%p remoteAddr=%p
qio_channel_socket_dgram_sync Socket dgram sync ioc=%p localAddr=%p remoteAddr=%p
%d@%zu.%06zu:qio_channel_socket_dgram_fail Socket dgram fail ioc=%p
qio_channel_socket_dgram_fail Socket dgram fail ioc=%p
%d@%zu.%06zu:qio_channel_socket_dgram_complete Socket dgram complete ioc=%p fd=%d
qio_channel_socket_dgram_complete Socket dgram complete ioc=%p fd=%d
%d@%zu.%06zu:qio_channel_socket_dgram_async Socket dgram async ioc=%p localAddr=%p remoteAddr=%p
qio_channel_socket_dgram_async Socket dgram async ioc=%p localAddr=%p remoteAddr=%p
%d@%zu.%06zu:qio_channel_socket_accept Socket accept start ioc=%p
qio_channel_socket_accept Socket accept start ioc=%p
%d@%zu.%06zu:qio_channel_socket_accept_fail Socket accept fail ioc=%p
qio_channel_socket_accept_fail Socket accept fail ioc=%p
%d@%zu.%06zu:qio_channel_socket_accept_complete Socket accept complete ioc=%p cioc=%p fd=%d
qio_channel_socket_accept_complete Socket accept complete ioc=%p cioc=%p fd=%d
%d@%zu.%06zu:qio_channel_tls_handshake_fail TLS handshake fail ioc=%p
qio_channel_tls_handshake_fail TLS handshake fail ioc=%p
%d@%zu.%06zu:qio_channel_tls_handshake_complete TLS handshake complete ioc=%p
qio_channel_tls_handshake_complete TLS handshake complete ioc=%p
%d@%zu.%06zu:qio_channel_tls_credentials_deny TLS credentials deny ioc=%p
qio_channel_tls_credentials_deny TLS credentials deny ioc=%p
%d@%zu.%06zu:qio_channel_tls_credentials_allow TLS credentials allow ioc=%p
qio_channel_tls_credentials_allow TLS credentials allow ioc=%p
%d@%zu.%06zu:qio_channel_tls_handshake_pending TLS handshake pending ioc=%p status=%d
qio_channel_tls_handshake_pending TLS handshake pending ioc=%p status=%d
%d@%zu.%06zu:qio_channel_tls_bye_fail TLS termination fail ioc=%p
qio_channel_tls_bye_fail TLS termination fail ioc=%p
%d@%zu.%06zu:qio_channel_tls_bye_pending TLS termination pending ioc=%p status=%d
qio_channel_tls_bye_pending TLS termination pending ioc=%p status=%d
%d@%zu.%06zu:qio_channel_tls_handshake_cancel TLS handshake cancel ioc=%p
qio_channel_tls_handshake_cancel TLS handshake cancel ioc=%p
%d@%zu.%06zu:qio_channel_tls_bye_cancel TLS termination cancel ioc=%p
qio_channel_tls_bye_cancel TLS termination cancel ioc=%p
%d@%zu.%06zu:qio_channel_tls_new_server TLS new client ioc=%p master=%p creds=%p acltname=%s
qio_channel_tls_new_server TLS new client ioc=%p master=%p creds=%p acltname=%s
%d@%zu.%06zu:qio_channel_tls_new_client TLS new client ioc=%p master=%p creds=%p hostname=%s
qio_channel_tls_new_client TLS new client ioc=%p master=%p creds=%p hostname=%s
%d@%zu.%06zu:qio_channel_tls_handshake_start TLS handshake start ioc=%p
qio_channel_tls_handshake_start TLS handshake start ioc=%p
%d@%zu.%06zu:qio_channel_tls_bye_start TLS termination start ioc=%p
qio_channel_tls_bye_start TLS termination start ioc=%p
%d@%zu.%06zu:qio_channel_websock_encode Websocket encoded ioc=%p opcode=0x%x header-len=%zu payload-len=%zu
qio_channel_websock_encode Websocket encoded ioc=%p opcode=0x%x header-len=%zu payload-len=%zu
%d@%zu.%06zu:qio_channel_websock_header_partial_decode Websocket header decoded ioc=%p payload-len=%zu fin=0x%x opcode=0x%x has_mask=0x%x
qio_channel_websock_header_partial_decode Websocket header decoded ioc=%p payload-len=%zu fin=0x%x opcode=0x%x has_mask=0x%x
only binary websocket frames may be fragmented
only binary frames may be fragmented
unsupported opcode: 0x%04x; only binary, close, ping, and pong websocket frames are supported
only binary, close, ping, and pong frames are supported
websocket control frame is too large
client websocket frames must be masked
%d@%zu.%06zu:qio_channel_websock_header_full_decode Websocket header decoded ioc=%p header-len=%zu payload-len=%zu mask=0x%x
qio_channel_websock_header_full_decode Websocket header decoded ioc=%p header-len=%zu payload-len=%zu mask=0x%x
%d@%zu.%06zu:qio_channel_websock_payload_decode Websocket header decoded ioc=%p opcode=0x%x payload-remain=%zu
qio_channel_websock_payload_decode Websocket header decoded ioc=%p opcode=0x%x payload-remain=%zu
/home/virus/AMD/AMD/include/io/channel-websock.h
%d@%zu.%06zu:qio_channel_websock_close Websocket close ioc=%p
qio_channel_websock_close Websocket close ioc=%p
%d@%zu.%06zu:qio_channel_websock_http_greeting Websocket HTTP request ioc=%p greeting='%s'
qio_channel_websock_http_greeting Websocket HTTP request ioc=%p greeting='%s'
Missing HTTP version delimiter
HTTP/1.1 404 Not Found
Server: QEMU VNC
Date: %s
Connection: close
HTTP/1.1 400 Bad Request
Server: QEMU VNC
Date: %s
Connection: close
Sec-WebSocket-Version: 13
Missing websocket version header data
Missing websocket key header data
Missing websocket host header data
Missing websocket connection header data
Missing websocket upgrade header data
%d@%zu.%06zu:qio_channel_websock_http_request Websocket HTTP request ioc=%p protocols='%s' version='%s' host='%s' connection='%s' upgrade='%s' key='%s'
qio_channel_websock_http_request Websocket HTTP request ioc=%p protocols='%s' version='%s' host='%s' connection='%s' upgrade='%s' key='%s'
No '%s' protocol is supported by client '%s'
Version '%s' is not supported by client '%s'
Key length '%zu' was not as expected '%d'
No connection upgrade requested '%s'
258EAFA5-E914-47DA-95CA-C5AB0DC85B11
HTTP/1.1 500 Internal Server Error
Server: QEMU VNC
Date: %s
Connection: close
HTTP/1.1 101 Switching Protocols
Server: QEMU VNC
Date: %s
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: %s
Sec-WebSocket-Protocol: binary
HTTP/1.1 101 Switching Protocols
Server: QEMU VNC
Date: %s
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: %s
%d@%zu.%06zu:qio_channel_websock_handshake_fail Websock handshake fail ioc=%p err=%s
qio_channel_websock_handshake_fail Websock handshake fail ioc=%p err=%s
%d@%zu.%06zu:qio_channel_websock_handshake_complete Websock handshake complete ioc=%p
qio_channel_websock_handshake_complete Websock handshake complete ioc=%p
%d@%zu.%06zu:qio_channel_websock_handshake_pending Websock handshake pending ioc=%p status=%d
qio_channel_websock_handshake_pending Websock handshake pending ioc=%p status=%d
HTTP/1.1 403 Request Entity Too Large
Server: QEMU VNC
Date: %s
Connection: close
End of headers not found in first 4096 bytes
End of headers not found before connection closed
%d@%zu.%06zu:qio_channel_websock_handshake_reply Websock handshake reply ioc=%p
qio_channel_websock_handshake_reply Websock handshake reply ioc=%p
%d@%zu.%06zu:qio_channel_websock_new_server Websock new client ioc=%p master=%p
qio_channel_websock_new_server Websock new client ioc=%p master=%p
%d@%zu.%06zu:qio_channel_websock_handshake_start Websock handshake start ioc=%p
qio_channel_websock_handshake_start Websock handshake start ioc=%p
qemu_get_current_aio_context() == qemu_coroutine_get_aio_context(co)
Channel does not support file descriptor passing
Channel does not support peek read
Zero Copy does not support file descriptor passing
Requested Zero Copy feature is not available
Channel does not support pwritev
Requested channel is not seekable
Channel does not support preadv
Data path shutdown not supported
Channel does not support peer pid
Channel does not support random access
in_aio_context_home_thread(ioc_ctx)
Unexpected end-of-file before all data were read
/home/virus/AMD/AMD/include/io/dns-resolver.h
address resolution failed for %s:%s: %s
/home/virus/AMD/AMD/include/io/net-listener.h
%d@%zu.%06zu:qio_task_thread_run Task thread run task=%p
qio_task_thread_run Task thread run task=%p
%d@%zu.%06zu:qio_task_thread_exit Task thread exit task=%p
qio_task_thread_exit Task thread exit task=%p
%d@%zu.%06zu:qio_task_thread_source_attach Task thread source attach task=%p source=%p
qio_task_thread_source_attach Task thread source attach task=%p source=%p
%d@%zu.%06zu:qio_task_new Task new task=%p source=%p func=%p opaque=%p
qio_task_new Task new task=%p source=%p func=%p opaque=%p
%d@%zu.%06zu:qio_task_thread_start Task thread start task=%p worker=%p opaque=%p
qio_task_thread_start Task thread start task=%p worker=%p opaque=%p
%d@%zu.%06zu:qio_task_complete Task complete task=%p
qio_task_complete Task complete task=%p
%d@%zu.%06zu:qio_task_thread_result Task thread result task=%p
qio_task_thread_result Task thread result task=%p
%d@%zu.%06zu:qio_task_thread_source_cancel Task thread source cancel task=%p source=%p
qio_task_thread_source_cancel Task thread source cancel task=%p source=%p
Try to verify signature without padding
../crypto/akcipher-nettle.c.inc
Data length %zu is greater than key size: %zu
Signature length %zu is greater than key size: %zu
Unsupported hash algorithm: %d
Try to make signature without padding
Signature buffer length %zu is less than key size: %zu
Ciphertext length %zu is greater than key size: %zu
RSA with raw padding is not supported
Plaintext length %zu is greater than key size: %zu
Ciphertext buffer length %zu is less than key size: %zu
No AES cipher with key size %zu available
No Serpent cipher with key size %zu available
No Twofish cipher with key size %zu available
Cipher %s not supported with essiv
QEMU_IS_ALIGNED(offset, QCRYPTO_BLOCK_LUKS_SECTOR_SIZE)
QEMU_IS_ALIGNED(len, QCRYPTO_BLOCK_LUKS_SECTOR_SIZE)
slot_idx < QCRYPTO_BLOCK_LUKS_NUM_KEY_SLOTS
PBKDF iterations %llu too large to scale
PBKDF iterations %llu larger than %u
Parameter '%skey-secret' is required for cipher
Cipher name '%s' is too long for LUKS header
Cipher mode '%s' is too long for LUKS header
Hash name '%s' is too long for LUKS header
'new-secret' is required to activate a keyslot
'old-secret' must not be given when activating keyslots
Invalid keyslot %u specified, must be between 0 and %u
Can't add a keyslot - all keyslots are in use
Refusing to overwrite active keyslot %i - please erase it first
Invalid password, cannot unlock any keyslot
Failed to retrieve the master key
'new-secret' must not be given when erasing keyslots
'iter-time' must not be given when erasing keyslots
'secret' must not be given when erasing keyslots
Invalid keyslot %i specified, must be between 0 and %i
Given keyslot %i doesn't contain the given old password for erase operation
Given keyslot %i is already erased (inactive) 
Attempt to erase the only active keyslot %i which will erase all the data in the image irreversibly - refusing operation
No keyslots match given (old) password for erase operation
All the active keyslots match the (old) password that was given and erasing them will erase all the data in the image irreversibly - refusing operation
To erase keyslot(s), either explicit keyslot index or the password currently contained in them must be given
LUKS version %u is not supported
LUKS header cipher name is not NUL terminated
LUKS header cipher mode is not NUL terminated
LUKS header hash spec is not NUL terminated
LUKS payload is overlapping with the header
LUKS key iteration count is zero
Keyslot %zu is corrupted (stripes %d != %d)
Keyslot %zu state (active/disable) is corrupted
Keyslot %zu iteration count is zero
Keyslot %zu is overlapping with the LUKS header
Keyslot %zu is overlapping with the encrypted payload
Keyslots %zu and %zu are overlapping in the header
Unexpected cipher mode string format '%s'
Algorithm '%s' with key size %d bytes not supported
Missing IV generator hash specification
QEMU_IS_ALIGNED(offset, QCRYPTO_BLOCK_QCOW_SECTOR_SIZE)
QEMU_IS_ALIGNED(len, QCRYPTO_BLOCK_QCOW_SECTOR_SIZE)
QEMU_IS_ALIGNED(offset, sectorsize)
QEMU_IS_ALIGNED(len, sectorsize)
Cannot amend encryption format
Crypto format %s doesn't support format options amendment
!block->free_ciphers && !block->max_free_ciphers && !block->n_free_ciphers
block->n_free_ciphers == block->max_free_ciphers
Length %zu must be a multiple of block size %zu
alg < G_N_ELEMENTS(alg_key_len)
Cipher algorithm %d out of range
XTS mode not compatible with DES/3DES
XTS cipher key length should be a multiple of 2
Cipher key length %zu should be %zu
Unsupported cipher algorithm %s
Unexpected tag: expected: %u, actual: %u
Only definite length format is allowed
Invalid byte count of content length: %u
alg < G_N_ELEMENTS(qcrypto_hash_alg_size)
Unknown block IV generator algorithm %d
Unable to get thread CPU usage
Unable to get accurate CPU usage
/home/virus/AMD/AMD/include/crypto/secret_common.h
Object with id '%s' is not a secret
Secret with id '%s' has no data
%s provides no 'load_data' method'
Key should be 32 bytes in length
IV is required to decrypt secret
IV should be 16 bytes in length not %zu
Incorrect number of padding bytes (%d) found on decrypted data
Data from secret %s is not valid UTF-8
/home/virus/AMD/AMD/include/crypto/secret.h
'file' and 'data' are mutually exclusive
Either 'file' or 'data' must be provided
qcrypto_tls_creds_load_dh TLS creds load DH creds=%p filename=%s
%d@%zu.%06zu:qcrypto_tls_creds_load_dh TLS creds load DH creds=%p filename=%s
Unable to initialize DH parameters: %s
Unable to generate DH parameters: %s
Unable to load DH parameters from %s: %s
Unable to access credentials %s
%d@%zu.%06zu:qcrypto_tls_creds_get_path TLS creds path creds=%p filename=%s path=%s
qcrypto_tls_creds_get_path TLS creds path creds=%p filename=%s path=%s
Expected TLS credentials for a %s endpoint
/home/virus/AMD/AMD/include/crypto/tlscredsanon.h
%d@%zu.%06zu:qcrypto_tls_creds_anon_load TLS creds anon load creds=%p dir=%s
qcrypto_tls_creds_anon_load TLS creds anon load creds=%p dir=%s
Cannot allocate credentials: %s
/home/virus/AMD/AMD/include/crypto/tlscredspsk.h
%d@%zu.%06zu:qcrypto_tls_creds_psk_load TLS creds psk load creds=%p dir=%s
qcrypto_tls_creds_psk_load TLS creds psk load creds=%p dir=%s
username should not be set when endpoint=server
Cannot set PSK server credentials: %s
Username %s not found in PSK file %s
Cannot set PSK client credentials: %s
/home/virus/AMD/AMD/include/crypto/tlscredsx509.h
The CA certificate %s has expired
The server certificate %s has expired
The client certificate %s has expired
The CA certificate %s is not yet active
The server certificate %s is not yet active
The client certificate %s is not yet active
The certificate %s basic constraints show a CA, but we need one for a server
The certificate %s basic constraints show a CA, but we need one for a client
%d@%zu.%06zu:qcrypto_tls_creds_x509_check_basic_constraints TLS creds x509 check basic constraints creds=%p file=%s status=%d
qcrypto_tls_creds_x509_check_basic_constraints TLS creds x509 check basic constraints creds=%p file=%s status=%d
The certificate %s basic constraints do not show a CA
The certificate %s is missing basic constraints for a CA
Unable to query certificate %s basic constraints: %s
%d@%zu.%06zu:qcrypto_tls_creds_x509_check_key_usage TLS creds x509 check key usage creds=%p file=%s status=%d usage=%d critical=%d
qcrypto_tls_creds_x509_check_key_usage TLS creds x509 check key usage creds=%p file=%s status=%d usage=%d critical=%d
Unable to query certificate %s key usage: %s
Certificate %s usage does not permit certificate signing
Certificate %s usage does not permit digital signature
Certificate %s usage does not permit key encipherment
Unable to query certificate %s key purpose: %s
%d@%zu.%06zu:qcrypto_tls_creds_x509_check_key_purpose TLS creds x509 check key usage creds=%p file=%s status=%d usage=%s critical=%d
qcrypto_tls_creds_x509_check_key_purpose TLS creds x509 check key usage creds=%p file=%s status=%d usage=%s critical=%d
Certificate %s purpose does not allow use with a TLS server
Certificate %s purpose does not allow use with a TLS client
Unable to import server certificate %s: %s
Unable to import client certificate %s: %s
Unable to verify server certificate %s against CA certificate %s
Unable to verify client certificate %s against CA certificate %s
The certificate is not trusted
The certificate hasn't got a known issuer
The certificate has been revoked
The certificate uses an insecure algorithm
%d@%zu.%06zu:qcrypto_tls_creds_x509_load TLS creds x509 load creds=%p dir=%s
qcrypto_tls_creds_x509_load TLS creds x509 load creds=%p dir=%s
%d@%zu.%06zu:qcrypto_tls_creds_x509_load_cert TLS creds x509 load cert creds=%p isServer=%d file=%s
qcrypto_tls_creds_x509_load_cert TLS creds x509 load cert creds=%p isServer=%d file=%s
Unable to initialize certificate: %s
Cannot load CA cert list %s: %s
%d@%zu.%06zu:qcrypto_tls_creds_x509_load_cert_list TLS creds x509 load cert list creds=%p file=%s
qcrypto_tls_creds_x509_load_cert_list TLS creds x509 load cert list creds=%p file=%s
Unable to import CA certificate list %s
Our own certificate %s failed validation against %s: %s
Cannot allocate credentials: '%s'
Cannot load CA certificate '%s': %s
Cannot load certificate '%s' & key '%s': %s
%d@%zu.%06zu:qcrypto_tls_session_new TLS session new session=%p creds=%p hostname=%s authzid=%s endpoint=%d
qcrypto_tls_session_new TLS session new session=%p creds=%p hostname=%s authzid=%s endpoint=%d
Credentials endpoint doesn't match session
Cannot initialize TLS session: %s
Unable to set TLS session priority %s: %s
Cannot set session credentials: %s
Cannot set default TLS session priority %s: %s
Unsupported TLS credentials type %s
%d@%zu.%06zu:qcrypto_tls_session_check_creds TLS session check creds session=%p status=%s
qcrypto_tls_session_check_creds TLS session check creds session=%p status=%s
Cannot initialize certificate: %s
The certificate is not yet activated
Cannot get client distinguished name: %s
TLS x509 authz check for %s is denied
Certificate does not match the hostname %s
No hostname for certificate validation
Cannot write to TLS channel: %s
Cannot read from TLS channel: %s
TLS termination failed: %s: %s
Cannot get TLS cipher key size
Failed to parse RSA private key
Failed to parse RSA public key
Result buffer size %zu is smaller than hash %d
Failed to get fingerprint from certificate
Result buffer size %zu is smaller than hash %zu
PBKDF iterations %llu must be less than %u
PBKDF does not support hash algorithm %s
/home/virus/AMD/AMD/include/crypto/secret_keyring.h
'serial' parameter must be provided
Unable to read serial key %08x
'serial' should not be equal to 0
Afalg type(%s) is larger than %d bytes
Afalg name(%s) is larger than %d bytes
Set IV len(%zu) not match expected(%zu)
Send data to AF_ALG core failed
Get result from AF_ALG core failed
Unsupported cipher algorithm %d
Result buffer size %zu is not match hash %d
Recv result from afalg-core failed
Send data to afalg-core failed
/home/virus/AMD/AMD/include/authz/base.h
%d@%zu.%06zu:qauthz_is_allowed AuthZ %p check identity=%s allowed=%d
qauthz_is_allowed AuthZ %p check identity=%s allowed=%d
Cannot find QAuthZ object ID %s
Object '%s' is not a QAuthZ subclass
/home/virus/AMD/AMD/include/authz/list.h
%d@%zu.%06zu:qauthz_list_check_rule AuthZ list %p check rule=%s identity=%s format=%d policy=%d
qauthz_list_check_rule AuthZ list %p check rule=%s identity=%s format=%d policy=%d
%d@%zu.%06zu:qauthz_list_default_policy AuthZ list %p default identity=%s policy=%d
qauthz_list_default_policy AuthZ list %p default identity=%s policy=%d
%d@%zu.%06zu:qauthz_list_file_load AuthZ file %p load filename=%s
qauthz_list_file_load AuthZ file %p load filename=%s
File '%s' must contain a JSON object
/home/virus/AMD/AMD/include/authz/listfile.h
Filename must be an absolute path
Path has no trailing filename component
%d@%zu.%06zu:qauthz_list_file_refresh AuthZ file %p load filename=%s success=%d
qauthz_list_file_refresh AuthZ file %p load filename=%s success=%d
/home/virus/AMD/AMD/include/authz/simple.h
%d@%zu.%06zu:qauthz_simple_is_allowed AuthZ simple %p check want identity=%s got identity=%s
qauthz_simple_is_allowed AuthZ simple %p check want identity=%s got identity=%s
The 'identity' property must be set
%d@%zu.%06zu:nbd_handshake_timer_cb client took too long to negotiate
nbd_handshake_timer_cb client took too long to negotiate
iov[1].iov_len <= NBD_MAX_STRING_SIZE
%d@%zu.%06zu:nbd_negotiate_meta_query_reply Replying with meta context '%s' id %u
nbd_negotiate_meta_query_reply Replying with meta context '%s' id %u
%d@%zu.%06zu:nbd_negotiate_send_rep_len Reply opt=%u (%s), type=%u (%s), len=%u
nbd_negotiate_send_rep_len Reply opt=%u (%s), type=%u (%s), len=%u
%d@%zu.%06zu:nbd_negotiate_send_info Sending NBD_REP_INFO type %d (%s) with remaining length %u
nbd_negotiate_send_info Sending NBD_REP_INFO type %d (%s) with remaining length %u
%d@%zu.%06zu:nbd_negotiate_send_rep_err sending error message "%s"
nbd_negotiate_send_rep_err sending error message "%s"
write failed (error message): 
%d@%zu.%06zu:nbd_blk_aio_detach Export %s: Detaching clients from AIO context %p
nbd_blk_aio_detach Export %s: Detaching clients from AIO context %p
length <= NBD_MAX_BUFFER_SIZE + sizeof(NBDStructuredReadData)
client->mode < NBD_MODE_STRUCTURED || (client->mode == NBD_MODE_STRUCTURED && request->type != NBD_CMD_READ)
%d@%zu.%06zu:nbd_co_send_simple_reply Send simple reply: cookie = %lu, error = %u (%s), len = %lu
nbd_co_send_simple_reply Send simple reply: cookie = %lu, error = %u (%s), len = %lu
(ea->extents[i].length | ea->extents[i].flags) <= UINT32_MAX
%d@%zu.%06zu:nbd_co_send_extents Send block status reply: cookie = %lu, extents = %u, context = %d (extents cover %lu bytes, last chunk = %d)
nbd_co_send_extents Send block status reply: cookie = %lu, extents = %u, context = %d (extents cover %lu bytes, last chunk = %d)
client->nb_requests <= MAX_NBD_REQUESTS - 1
option '%s' has unexpected length
Inconsistent lengths in option %s
Unexpected embedded NUL in option %s
%d@%zu.%06zu:nbd_blk_aio_attached Export %s: Attaching clients to AIO context %p
nbd_blk_aio_attached Export %s: Attaching clients to AIO context %p
client->recv_coroutine == NULL
client->send_coroutine == NULL
%d@%zu.%06zu:nbd_co_send_chunk_done Send structured reply done: cookie = %lu
nbd_co_send_chunk_done Send structured reply done: cookie = %lu
size && size <= NBD_MAX_BUFFER_SIZE
%d@%zu.%06zu:nbd_co_send_chunk_read Send structured read data reply: cookie = %lu, offset = %lu, data = %p, len = %lu
nbd_co_send_chunk_read Send structured read data reply: cookie = %lu, offset = %lu, data = %p, len = %lu
%d@%zu.%06zu:nbd_co_send_chunk_error Send structured error reply: cookie = %lu, error = %d (%s), msg = '%s'
nbd_co_send_chunk_error Send structured error reply: cookie = %lu, error = %d (%s), msg = '%s'
%d@%zu.%06zu:nbd_negotiate_handle_export_name Checking length
nbd_negotiate_handle_export_name Checking length
Extended headers already negotiated
%d@%zu.%06zu:nbd_negotiate_handle_export_name_request Client requested export '%s'
nbd_negotiate_handle_export_name_request Client requested export '%s'
%d@%zu.%06zu:nbd_negotiate_new_style_size_flags advertising size %lu and flags 0x%x
nbd_negotiate_new_style_size_flags advertising size %lu and flags 0x%x
exp_args->type == BLOCK_EXPORT_TYPE_NBD
Failed to determine the NBD export's length
Enabled bitmap '%s' incompatible with readonly export
strlen(bitmap) <= BDRV_BITMAP_MAX_NAME_SIZE
NBD server already has export named '%s'
%d@%zu.%06zu:nbd_negotiate_begin Beginning negotiation
nbd_negotiate_begin Beginning negotiation
%d@%zu.%06zu:nbd_negotiate_options_flags Received client flags 0x%x
nbd_negotiate_options_flags Received client flags 0x%x
Unknown client flags 0x%x received
%d@%zu.%06zu:nbd_negotiate_options_check_magic Checking opts magic 0x%lx
nbd_negotiate_options_check_magic Checking opts magic 0x%lx
len (%u) is larger than max len (%u)
%d@%zu.%06zu:nbd_negotiate_options_check_option Checking option %u (%s)
nbd_negotiate_options_check_option Checking option %u (%s)
client->opt == NBD_OPT_STARTTLS
%d@%zu.%06zu:nbd_negotiate_handle_starttls Setting up TLS
nbd_negotiate_handle_starttls Setting up TLS
%d@%zu.%06zu:nbd_negotiate_handle_starttls_handshake Starting TLS handshake
nbd_negotiate_handle_starttls_handshake Starting TLS handshake
Option 0x%x not permitted before TLS
%d@%zu.%06zu:nbd_negotiate_send_rep_list Advertising export name '%s' description '%s'
nbd_negotiate_send_rep_list Advertising export name '%s' description '%s'
name_len <= NBD_MAX_STRING_SIZE && desc_len <= NBD_MAX_STRING_SIZE
write failed (description buffer): 
%d@%zu.%06zu:nbd_negotiate_handle_info_requests Client requested %d items of info
nbd_negotiate_handle_info_requests Client requested %d items of info
%d@%zu.%06zu:nbd_negotiate_handle_info_request Client requested info %d (%s)
nbd_negotiate_handle_info_request Client requested info %d (%s)
sizes[0] <= NBD_MAX_BUFFER_SIZE
%d@%zu.%06zu:nbd_negotiate_handle_info_block_size advertising minimum 0x%x, preferred 0x%x, maximum 0x%x
nbd_negotiate_handle_info_block_size advertising minimum 0x%x, preferred 0x%x, maximum 0x%x
request NBD_INFO_BLOCK_SIZE to use this export
extended headers already negotiated
structured reply already negotiated
request option '%s' when structured reply is not negotiated
%d@%zu.%06zu:nbd_negotiate_meta_context Client requested %s for export %s, with %u queries
nbd_negotiate_meta_context Client requested %s for export %s, with %u queries
%d@%zu.%06zu:nbd_negotiate_meta_query_skip Skipping meta query: %s
nbd_negotiate_meta_query_skip Skipping meta query: %s
%d@%zu.%06zu:nbd_negotiate_meta_query_parse Parsed meta query '%s'
nbd_negotiate_meta_query_parse Parsed meta query '%s'
%d@%zu.%06zu:nbd_negotiate_success Negotiation succeeded
nbd_negotiate_success Negotiation succeeded
%d@%zu.%06zu:nbd_trip Reading request
client->recv_coroutine == qemu_coroutine_self()
Unexpected end-of-file before all bytes were read
%d@%zu.%06zu:nbd_receive_request Got request: { magic = 0x%x, .flags = 0x%x, .type = 0x%x, from = %lu, len = %lu }
nbd_receive_request Got request: { magic = 0x%x, .flags = 0x%x, .type = 0x%x, from = %lu, len = %lu }
invalid magic (got 0x%x, expected 0x%x)
%d@%zu.%06zu:nbd_co_receive_request_decode_type Decoding type: cookie = %lu, type = %u (%s)
nbd_co_receive_request_decode_type Decoding type: cookie = %lu, type = %u (%s)
%d@%zu.%06zu:nbd_co_receive_ext_payload_compliance client sent non-compliant write without payload flag: from=0x%lx, len=0x%lx
nbd_co_receive_ext_payload_compliance client sent non-compliant write without payload flag: from=0x%lx, len=0x%lx
len (%lu) is larger than max len (%u)
client->contexts.exp == client->exp
%d@%zu.%06zu:nbd_co_receive_request_payload_received Payload received: cookie = %lu, len = %lu
nbd_co_receive_request_payload_received Payload received: cookie = %lu, len = %lu
%d@%zu.%06zu:nbd_co_receive_block_status_payload_compliance client sent unusable block status payload: from=0x%lx, len=0x%lx
nbd_co_receive_block_status_payload_compliance client sent unusable block status payload: from=0x%lx, len=0x%lx
request->type != NBD_CMD_WRITE
operation past EOF; From: %lu, Len: %lu, Size: %lu
%d@%zu.%06zu:nbd_co_receive_align_compliance client sent non-compliant unaligned %s request: from=0x%lx, len=0x%lx, align=0x%x
nbd_co_receive_align_compliance client sent non-compliant unaligned %s request: from=0x%lx, len=0x%lx, align=0x%x
unsupported flags for command %s (got 0x%x)
request->len <= NBD_MAX_BUFFER_SIZE
pnum && pnum <= size - progress
%d@%zu.%06zu:nbd_co_send_chunk_read_hole Send structured read hole reply: cookie = %lu, offset = %lu, len = %lu
nbd_co_send_chunk_read_hole Send structured read hole reply: cookie = %lu, offset = %lu, len = %lu
client->mode >= NBD_MODE_EXTENDED || request->len <= UINT32_MAX
request->contexts->exp == client->exp
CMD_BLOCK_STATUS payload not valid
CMD_BLOCK_STATUS not negotiated
invalid request type (%u) received
request.type == NBD_CMD_BLOCK_STATUS
Request handling failed in intermediate state
nbd_exp->eject_notifier_blk == NULL
No driver found for the requested export type
Cannot export read-only node as writable
Export type does not support inactive exports
drv->instance_size >= sizeof(BlockExport)
Block export id '%s' is already in use
qatomic_read(&exp->refcount) > 0
in_aio_context_home_thread(qemu_get_aio_context())
Export '%s' is already shutting down
Use mode='hard' to force client disconnect
Failed to get length of block node '%s'
num-queues must be greater than 0
../block/export/vhost-user-blk-server.c
virtio-blk request missing headers
Invalid size %zd, expected %zu
max_read=%zu,default_permissions%s
Failed to mount FUSE session to export
blk_exp_args->type == BLOCK_EXPORT_TYPE_FUSE
There already is a FUSE export on '%s'
qatomic_read(&vblk_exp->inflight) == 0
failed to set reconnect log file
failed to read data from eventfd
Failed to delete snapshot with id '%s' and name '%s' on device '%s' in abort: 
Block format '%s' used by device '%s' does not support internal snapshots
Snapshot with name '%s' already exists on device '%s'
Failed to create snapshot '%s' on device '%s'
Failed to query the replacement node's size
cannot replace image with a mirror image of different size
must provide a valid bitmap name for '%s' sync mode
Bitmap sync mode must be '%s' when using sync mode '%s'
Bitmap '%s' could not be found
Bitmap sync mode must be given when providing a bitmap
sync mode '%s' does not produce meaningful bitmap outputs
Bitmap sync mode '%s' has no meaningful effect when combined with sync mode '%s'
Cannot specify bitmap sync mode without a bitmap
Invalid option stats-intervals.%s
Supported formats (read-only):
Cannot specify both 'driver' and 'format'
(bdrv_flags & BDRV_O_CACHE_MASK) == 0
The specification of stats-intervals is invalid
Cannot override units-per-bus property of the %s interface, because a drive of that type has already been added.
machine type does not support if=%s,bus=%d,unit=%d
'%s' and its alias '%s' can't be used at the same time
disabling copy-on-read on read-only drive
index cannot be used with bus and unit
drive with bus=%d, unit=%d (index=%d) exists
werror is not supported by this bus type
rerror is not supported by this bus type
Snapshot with id '%s' and name '%s' does not exist on device '%s'
Action '%s' does not support transaction property completion-mode = %s
New overlay node-name already in use
Filters cannot be used as overlays
The overlay already has a backing image
The overlay does not support backing images
Transaction aborted using Abort action
'base' and 'base-node' cannot be specified at the same time
'base' and 'bottom' cannot be specified at the same time
'bottom' and 'base-node' cannot be specified at the same time
Can't find '%s' in the backing chain
bdrv_get_aio_context(base_bs) == aio_context
Node '%s' is not a backing image of '%s'
Node '%s' is a filter, use a non-filter node as 'bottom'
Node '%s' is not in a chain starting from '%s'
bdrv_get_aio_context(bottom_bs) == aio_context
backing file specified, but streaming the entire chain
%d@%zu.%06zu:qmp_block_stream bs %p
'top-node' and 'top' are mutually exclusive
'%s' is not in this backing file chain
bdrv_get_aio_context(top_bs) == aio_context
'base-node' and 'base' are mutually exclusive
cannot commit an image into itself
'backing-file' specified, but 'top' is the active layer
'backing-file' specified, but 'top' has a writer on it
a node-name must be provided when replacing a named node of the graph
The block job for device '%s' is currently paused
%d@%zu.%06zu:qmp_block_job_cancel job %p
%d@%zu.%06zu:qmp_block_job_pause job %p
%d@%zu.%06zu:qmp_block_job_resume job %p
%d@%zu.%06zu:qmp_block_job_complete job %p
qmp_block_job_complete job %p
%d@%zu.%06zu:qmp_block_job_finalize job %p
qmp_block_job_finalize job %p
%d@%zu.%06zu:qmp_block_job_dismiss job %p
not allowing backing file change on an image without a backing file
'%s' and image file are not in the same chain
Could not change backing file to '%s'
'node-name' must be specified for the root node
Failed to find node with node-name='%s'
Node %s is not owned by the monitor
Failed to inactivate all nodes
The parameters child and node are in conflict
Either child or node must be specified
Node '%s' does not have child '%s'
Node %s is associated with a BlockBackend and could be in use (use force=true to override this check)
host AIO implementation (threads, native, io_uring)
name of the block throttling group
copy read data from backing file into image file
try to optimize zero writes (off, on, unmap)
whether to account for invalid I/O operations in the statistics
whether to account for failed I/O operations in the statistics
unit number (i.e. lun for scsi)
interface (ide, scsi, sd, mtd, floppy, pflash, virtio)
qemu_in_main_thread() && nbd_server
Block export '%s' is not an NBD export
/home/virus/AMD/AMD/include/system/iothread.h
%d@%zu.%06zu:qmp_job_cancel job %p
%d@%zu.%06zu:qmp_job_pause job %p
%d@%zu.%06zu:qmp_job_resume job %p
%d@%zu.%06zu:qmp_job_complete job %p
%d@%zu.%06zu:qmp_job_finalize job %p
%d@%zu.%06zu:qmp_job_dismiss job %p
unable to change process name: %s
unable to query NOFILE limit: %s
unable to set NOFILE limit: %s
(user_uid == (uid_t)-1) || user_pwd == NULL
(user_uid == (uid_t)-1) == (user_gid == (gid_t)-1)
Failed to initgroups("%s", %d)
bs->drv && bs->drv->bdrv_child_perm
setting detect-zeroes to unmap is not allowed without setting discard operation to unmap
!new_bs || child->quiesced_parent
bdrv_get_aio_context(old_bs) == bdrv_get_aio_context(new_bs)
bs->open_flags & BDRV_O_INACTIVE
bs->drv->bdrv_debug_remove_breakpoint
!bs->drv || !bs->drv->is_filter
!new_bs || new_bs->quiesce_counter
Should not change '%s' link to '%s'
Cannot change '%s' link to '%s'
Could not read image for determining its format
Could not determine image format: No compatible driver found
!path_has_protocol(fat_filename->str)
Cannot use relative backing file names for '%s'
Driver '%s' does not support image creation
Unsupported preallocation mode '%s'
Protocol driver '%s' does not support creating new images, so an existing image must be selected as the target; however, opening the given target as an existing image failed: 
Failed to inquire the new image file's length
Failed to clear the new image's first sector
Driver '%s' does not support image deletion
Could not open temporary file '%s'
Permission conflict on node '%s': permissions '%s' are both required by %s (uses node '%s' as '%s' child) and unshared by %s (uses node '%s' as '%s' child).
Read-only block node '%s' cannot support read-write users
Cannot get 'write' permission without 'resize': Image size is not a multiple of request alignment
!(role & (BDRV_CHILD_DATA | BDRV_CHILD_METADATA | BDRV_CHILD_COW))
!(role & (BDRV_CHILD_DATA | BDRV_CHILD_METADATA))
qapi_perm < BLOCK_PERMISSION__MAX
QTAILQ_EMPTY(&all_bdrv_states)
Block driver '%s' does not support size measurement
Cannot find device='%s' nor node-name='%s'
Can't set node '%s' to r/o with copy-on-read enabled
Could not refresh total sector count
!(bs->open_flags & BDRV_O_INACTIVE)
%d@%zu.%06zu:bdrv_lock_medium bs %p locked %d
bdrv_lock_medium bs %p locked %d
(int) op >= 0 && op < BLOCK_OP_TYPE_MAX
Changing iothreads is not supported by %s
Permission '%s' unavailable on inactive node
Making '%s' a %s child of '%s' would create a cycle
Inactive '%s' can't be a %s child of active '%s'
Cannot change frozen '%s' link from '%s' to '%s'
Driver '%s' of node '%s' does not support backing files
Cannot set file child to format node without file child
bs->backing->bs->quiesce_counter > 0
QLIST_EMPTY(&bs->dirty_bitmaps)
!bdrv_parent_drained_poll_single(s->child)
Cannot replace implicit %s child of %s
'%s' is a %s filter node that does not support a %s child
node-name=%s is conflicting with a device id
Duplicate nodes with node-name='%s'
!drv->bdrv_needs_filename || bs->filename[0]
!(bs->supported_read_flags & ~BDRV_REQ_MASK)
!(bs->supported_write_flags & ~BDRV_REQ_MASK)
is_power_of_2(bs->bl.request_alignment)
Block driver '%s' does not support option amendment
Cannot replace '%s' by a node mirrored from '%s', because it cannot be guaranteed that doing so would not lead to an abrupt change of visible data
QLIST_NEXT(child, next) == NULL
bs_entry->state.bs->quiesce_counter > 0
old_flags == reopen_state->flags
Option '%s' cannot be reset to its default value
failed while preparing to reopen image '%s'
Block format '%s' used by node '%s' does not support reopening files
Could not update backing file link
!(child->role & BDRV_CHILD_COW)
child->role & BDRV_CHILD_FILTERED
!(child->role & BDRV_CHILD_FILTERED)
!(child->role & BDRV_CHILD_PRIMARY)
node is used as backing hd of '%s'
Cannot generate a base directory for %s nodes
Driver doesn't support backing files
Driver '%s' can only be used for read-only devices
Driver '%s' is not whitelisted
Cannot reference an existing block device with additional options or a new filename
Could not parse the JSON options: 
Can't specify 'file' and 'filename' options at the same time
Must specify either driver or file
drvname || !(flags & BDRV_O_PROTOCOL)
Use of "backing": "" is deprecated; use "backing": null instead
!!(flags & BDRV_O_PROTOCOL) == !!drv->protocol_name
!(flags & BDRV_O_PROTOCOL) || !file
options != NULL && bs->options != options
force-share=on can only be used with read-only images
The '%s' block driver requires a file name
%d@%zu.%06zu:bdrv_open_common bs %p filename "%s" flags 0x%x format_name "%s"
bdrv_open_common bs %p filename "%s" flags 0x%x format_name "%s"
qatomic_read(&bs->copy_on_read) == 0
Can't use copy-on-read on read-only device
!drv->protocol_name || file == NULL
Block protocol '%s' doesn't support the option '%s'
Block format '%s' does not support the option '%s'
Could not create temporary overlay '%s': 
A block device must be specified for "%s"
!parent->drv->filtered_child_is_backing
 (try using a larger cluster size)
Format driver '%s' does not support image creation
Protocol driver '%s' does not support image creation
The image size must be specified only once
Backing file not supported for file format '%s'
Backing file format not supported for file format '%s'
Error: Trying to create an image with the same filename as the backing file
Expected backing file name, got empty string
Could not open backing image.
Backing file specified without backing format
Image creation needs a size parameter
The image size is too large for file format '%s'%s
The node %s does not support adding a child
Cannot add a %s child to a %s parent
The node %s already has a parent
The node %s does not support removing a child
The node %s does not have a child named %s
c->perm & (BLK_PERM_WRITE | BLK_PERM_WRITE_UNCHANGED)
%s does not support emptying nodes
bs->backing->role & BDRV_CHILD_COW
bdrv_get_aio_context(from) == bdrv_get_aio_context(to)
bdrv_get_aio_context(bs) == ctx
Cannot change '%s' link from '%s' to '%s'
Cannot freeze '%s' link to '%s'
Preallocation mode (allowed values: off)
Node name of the block device node
Block driver to use for the node
Bypass software writeback cache on the host
Node is opened in read-only mode
Node can become read-only if opening read-write fails
discard operation (ignore/off, unmap/on)
always accept other writers (default: off)
Job type does not support change
Cannot query QEMU internal jobs
job->job.driver->free == &block_job_free
job->job.driver->user_resume == &block_job_user_resume
block device is in use by block job: %s
job->job.user_paused && job->job.pause_count > 0
s1 >= 0 && s1 < JOB_STATUS__MAX
%d@%zu.%06zu:job_state_transition job %p (ret: %d) attempting %s transition (%s-->%s)
job_state_transition job %p (ret: %d) attempting %s transition (%s-->%s)
job->cancelled || !job->force_cancel
job && job_started_locked(job)
job && job->driver && job->driver->run
job->aio_context == qemu_get_current_aio_context()
verb >= 0 && verb < JOB_VERB__MAX
%d@%zu.%06zu:job_apply_verb job %p in state %s; applying verb %s (%s)
job_apply_verb job %p in state %s; applying verb %s (%s)
Job '%s' in state '%s' cannot accept command verb '%s'
The active block job '%s' cannot be completed
job->paused || job_is_completed_locked(job)
Cannot specify job ID for internal job
An explicit job ID is required
job->status == JOB_STATUS_NULL
!timer_pending(&job->sleep_timer)
Can't resume a job that was not paused
job->status == JOB_STATUS_CREATED
job && !job_started_locked(job) && job->paused && job->driver && job->driver->run
job_cancel_requested_locked(other_job)
job && job->txn && !job_is_completed_locked(job)
%d@%zu.%06zu:job_completed job %p ret %d
 raises the given signal
 Example:
 'sigraise %i' - raises SIGTERM
 Invokes raise(signal), where "signal" is the mandatory integer argument
 given to sigraise.
 Changes the open options of an already opened image
 Example:
 'reopen -o lazy-refcounts=on' - activates lazy refcount writeback on a qcow2 image
 -r, -- Reopen the image read-only
 -w, -- Reopen the image read-write
 -c, -- Change the cache mode to the given value
 -o, -- Changes block driver options (cf. 'open' command)
 discards a range of bytes from the given offset
 Example:
 'discard 512 1k' - discards 1 kilobyte from 512 bytes into the file
 Discards a segment of the currently open file.
 -C, -- report statistics in a machine parsable format
 -q, -- quiet mode, do not show I/O statistics
 asynchronously writes a range of bytes from the given offset source
 from multiple buffers
 Example:
 'aio_write 512 1k 1k' - writes 2 kilobytes at 512 bytes into the open file
 Writes into a segment of the currently open file, using a buffer
 filled with a set pattern (0xcdcdcdcd).
 The write is performed asynchronously and the aio_flush command must be
 used to ensure all outstanding aio requests have been completed.
 Note that due to its asynchronous nature, this command will be
 considered successful once the request is submitted, independently
 of potential I/O errors or pattern mismatches.
 -C, -- report statistics in a machine parsable format
 -f, -- use Force Unit Access semantics
 -i, -- treat request as invalid, for exercising stats
 -P, -- use different pattern to fill file
 -q, -- quiet mode, do not show I/O statistics
 -r, -- register I/O buffer
 -u, -- with -z, allow unmapping
 -z, -- write zeroes using blk_aio_pwrite_zeroes
 asynchronously reads a range of bytes from the given offset
 Example:
 'aio_read -v 512 1k 1k ' - dumps 2 kilobytes read from 512 bytes into the file
 Reads a segment of the currently open file, optionally dumping it to the
 standard output stream (with -v option) for subsequent inspection.
 The read is performed asynchronously and the aio_flush command must be
 used to ensure all outstanding aio requests have been completed.
 Note that due to its asynchronous nature, this command will be
 considered successful once the request is submitted, independently
 of potential I/O errors or pattern mismatches.
 -C, -- report statistics in a machine parsable format
 -i, -- treat request as invalid, for exercising stats
 -P, -- use a pattern to verify read data
 -q, -- quiet mode, do not show I/O statistics
 -r, -- register I/O buffer
 -v, -- dump buffer to standard output
 writes a range of bytes from the given offset source from multiple buffers
 Example:
 'writev 512 1k 1k' - writes 2 kilobytes at 512 bytes into the open file
 Writes into a segment of the currently open file, using a buffer
 filled with a set pattern (0xcdcdcdcd).
 -C, -- report statistics in a machine parsable format
 -f, -- use Force Unit Access semantics
 -P, -- use different pattern to fill file
 -q, -- quiet mode, do not show I/O statistics
 -r, -- register I/O buffer
 writes a range of bytes from the given offset
 Example:
 'write 512 1k' - writes 1 kilobyte at 512 bytes into the open file
 Writes into a segment of the currently open file, using a buffer
 filled with a set pattern (0xcdcdcdcd).
 -b, -- write to the VM state rather than the virtual disk
 -c, -- write compressed data with blk_write_compressed
 -C, -- report statistics in a machine parsable format
 -f, -- use Force Unit Access semantics
 -n, -- with -z, don't allow slow fallback
 -p, -- ignored for backwards compatibility
 -P, -- use different pattern to fill file
 -q, -- quiet mode, do not show I/O statistics
 -r, -- register I/O buffer
 -s, -- use a pattern file to fill the write buffer
 -u, -- with -z, allow unmapping
 -z, -- write zeroes using blk_pwrite_zeroes
 reads a range of bytes from the given offset into multiple buffers
 Example:
 'readv -v 512 1k 1k ' - dumps 2 kilobytes read from 512 bytes into the file
 Reads a segment of the currently open file, optionally dumping it to the
 standard output stream (with -v option) for subsequent inspection.
 Uses multiple iovec buffers if more than one byte range is specified.
 -C, -- report statistics in a machine parsable format
 -P, -- use a pattern to verify read data
 -q, -- quiet mode, do not show I/O statistics
 -r, -- register I/O buffer
 -v, -- dump buffer to standard output
 reads a range of bytes from the given offset
 Example:
 'read -v 512 1k' - dumps 1 kilobyte read from 512 bytes into the file
 Reads a segment of the currently open file, optionally dumping it to the
 standard output stream (with -v option) for subsequent inspection.
 -b, -- read from the VM state rather than the virtual disk
 -C, -- report statistics in a machine parsable format
 -l, -- length for pattern verification (only with -P)
 -p, -- ignored for backwards compatibility
 -P, -- use a pattern to verify read data
 -q, -- quiet mode, do not show I/O statistics
 -r, -- register I/O buffer
 -s, -- start offset for pattern verification (only with -P)
 -v, -- dump buffer to standard output
Could not remove breakpoint %s: %s
Parsing error: non-numeric argument, or extraneous/unrecognized suffix -- %s
Parsing error: argument too large -- %s
Failed to query image length: %s
Failed to get allocation status: %s
%s (0x%lx) bytes %s at offset %s (0x%lx)
%s %ld/%ld bytes at offset %ld
%s, %d ops; %s (%s/sec and %.4f ops/sec)
Use 'help commandname' for extended help.
Pattern verification failed at offset %ld, %zu bytes
Argument '%s' exceeds maximum size %lu
The total number of bytes exceed the maximum size %lu
signal argument '%s' is too large to be a valid signal
After zap done, the append sector is 0x%lx
Number of zones must be less than 2^32
start: 0x%lx, len 0x%lx, cap 0x%lx, wptr 0x%lx, zcond:%u, [type: %u]
Invalid preallocation mode '%s'
truncates the current file at the given offset
%ld/%ld bytes allocated at offset %s
discards a number of bytes at a specified offset
length cannot exceed %lu, given %s
%s is not a valid pattern byte
writes a number of bytes at a specified offset
[-Cfqr] [-P pattern] off len [len..]
[-bcCfnqruz] [-P pattern | -s source_file] off len
-b and -z cannot be specified at the same time
-f and -b or -c cannot be specified at the same time
-n requires -z to be specified
-u requires -z to be specified
Only one of -z, -P, and -s can be specified at the same time
length cannot exceed %lu without -n, given %s
%ld is not a sector-aligned value for 'offset'
%ld is not a sector-aligned value for 'count'
cannot combine zero write with registered I/O buffer
reads a number of bytes at a specified offset
[-Cqrv] [-P pattern] off len [len..]
Only one -r/-w option may be given
reopens an image with new options
[(-r|-w)] [-c cache] [-o options]
Cannot change cache.writeback: Device attached
Cannot set both -r/-w and 'read-only'
Cannot set both -c and the cache options
ci->perm == 0 || (ci->flags & (CMD_FLAG_GLOBAL | CMD_NOFILE_OK)) == 0
injecting invalid write request
asynchronously writes a number of bytes
[-Cfiqruz] [-P pattern] off len [len..]
-z supports only a single length parameter
-z and -P cannot be specified at the same time
injecting invalid read request
asynchronously reads a number of bytes
[-Ciqrv] [-P pattern] off len [len..]
[-abCqrv] [-P pattern [-s off] [-l len]] off len
pattern verification range exceeds end of read data
I/O buffer registration is not supported when reading from vmstate
Pattern verification failed at offset %ld, %ld bytes
no file open, try 'help open'
bad argument count %d to %s, expected at least %d arguments
bad argument count %d to %s, expected %d arguments
bad argument count %d to %s, expected between %d and %d arguments
waits for the given value in milliseconds
simulate a program crash using abort(3)
waits for the suspension of a request
resumes the request tagged as tag
sets a breakpoint on event and tags the stopped request as tag
prints the allocated areas of a file
checks if offset is allocated in the file
prints information about the current file
gets the length of the current file
append write a number of bytes at a specified offset
reset a zone write pointer in zone block device
finish a range of zones in zone block device
close a range of zones in zone block device
explicit open a range of zones in zone block device
flush all in-core file state to disk
completes all outstanding aio requests
%d@%zu.%06zu:nbd_send_option_request Sending option request %u (%s), len %u
nbd_send_option_request Sending option request %u (%s), len %u
Failed to send option request header: 
Failed to send option request data: 
strnlen(export, NBD_MAX_STRING_SIZE + 1) <= NBD_MAX_STRING_SIZE
strnlen(query, NBD_MAX_STRING_SIZE + 1) <= NBD_MAX_STRING_SIZE
opt == NBD_OPT_LIST_META_CONTEXT
%d@%zu.%06zu:nbd_opt_meta_request Requesting %s %s for export %s
nbd_opt_meta_request Requesting %s %s for export %s
server error %u (%s) message is too long
Failed to read option error %u (%s) message: 
%d@%zu.%06zu:nbd_server_error_msg server reported error 0x%x (%s) with additional message: %s
nbd_server_error_msg server reported error 0x%x (%s) with additional message: %s
%d@%zu.%06zu:nbd_reply_err_ignored server failed request %u (%s) with error 0x%x (%s), attempting fallback
nbd_reply_err_ignored server failed request %u (%s) with error 0x%x (%s), attempting fallback
Denied by server for option %u (%s)
Invalid parameters for option %u (%s)
Server lacks support for option %u (%s)
TLS negotiation required before option %u (%s)
Did you forget a valid tls-creds?
Requested export not available
Server shutting down before option %u (%s)
Server requires INFO_BLOCK_SIZE for option %u (%s)
Unknown error code when asking for option %u (%s)
%d@%zu.%06zu:nbd_receive_option_reply Received option reply %u (%s), type %u (%s), len %u
nbd_receive_option_reply Received option reply %u (%s), type %u (%s), len %u
Unexpected option type %u (%s), expected %u (%s)
Server answered option %d (%s) with unexpected reply %u (%s)
Option %d ('%s') response length is %u (it should be zero)
%d@%zu.%06zu:nbd_start_negotiate Receiving negotiation tlscreds=%p hostname=%s
nbd_start_negotiate Receiving negotiation tlscreds=%p hostname=%s
Output I/O channel required for TLS
%d@%zu.%06zu:nbd_receive_negotiate_magic Magic is 0x%lx
nbd_receive_negotiate_magic Magic is 0x%lx
Bad initial magic received: 0x%lx
%d@%zu.%06zu:nbd_receive_negotiate_server_flags Global flags are 0x%x
nbd_receive_negotiate_server_flags Global flags are 0x%x
Failed to send clientflags field: 
Server don't support STARTTLS option
%d@%zu.%06zu:nbd_receive_starttls_new_client Setting up TLS
nbd_receive_starttls_new_client Setting up TLS
%d@%zu.%06zu:nbd_receive_starttls_tls_handshake Starting TLS handshake
nbd_receive_starttls_tls_handshake Starting TLS handshake
Server does not support STARTTLS
Bad server magic received: 0x%lx
%d@%zu.%06zu:nbd_opt_info_go_start Attempting %s for export '%s'
nbd_opt_info_go_start Attempting %s for export '%s'
server sent invalid NBD_REP_ACK
broken server omitted NBD_INFO_EXPORT
%d@%zu.%06zu:nbd_opt_info_go_success Export is ready after %s request
nbd_opt_info_go_success Export is ready after %s request
unexpected reply type %u (%s), expected %u (%s)
NBD_REP_INFO length %u is too short
remaining export info len %u is unexpected size
export size %lu is not multiple of minimum block size %u
%d@%zu.%06zu:nbd_receive_negotiate_size_flags Size is %lu, export flags 0x%x
nbd_receive_negotiate_size_flags Size is %lu, export flags 0x%x
server minimum block size %u is not a power of two
server preferred block size %u is not valid
server maximum block size %u is not valid
%d@%zu.%06zu:nbd_opt_info_block_size Block sizes are 0x%x, 0x%x, 0x%x
nbd_opt_info_block_size Block sizes are 0x%x, 0x%x, 0x%x
%d@%zu.%06zu:nbd_opt_info_unknown Ignoring unknown info %d (%s)
nbd_opt_info_unknown Ignoring unknown info %d (%s)
Unexpected length to ACK response
Unexpected reply type %u (%s), expected %u (%s)
Failed to negotiate meta context, server answered with unexpected length %u
%d@%zu.%06zu:nbd_opt_meta_reply Received %s mapping of %s to id %u
nbd_opt_meta_reply Received %s mapping of %s to id %u
length too long for option end
incorrect name length in server's list response
incorrect description length in server's list response
%d@%zu.%06zu:nbd_receive_list export list includes '%s', description '%s'
nbd_receive_list export list includes '%s', description '%s'
info->name && strlen(info->name) <= NBD_MAX_STRING_SIZE
%d@%zu.%06zu:nbd_receive_negotiate_name Requesting NBD export name '%s'
nbd_receive_negotiate_name Requesting NBD export name '%s'
Failed to negotiate meta context '%s', server answered with different context '%s'
Server answered with more than one context
%d@%zu.%06zu:nbd_receive_query_exports_start Querying export list for '%s'
nbd_receive_query_exports_start Querying export list for '%s'
No export with name '%s' available
%d@%zu.%06zu:nbd_receive_query_exports_success Found desired export name '%s'
nbd_receive_query_exports_success Found desired export name '%s'
Server does not support non-empty export names
Failed to read reserved block: 
%d@%zu.%06zu:nbd_init_set_socket Setting NBD socket
nbd_init_set_socket Setting NBD socket
%d@%zu.%06zu:nbd_init_set_block_size Setting block size to %lu
nbd_init_set_block_size Setting block size to %lu
%d@%zu.%06zu:nbd_init_set_size Setting size to %lu block(s)
nbd_init_set_size Setting size to %lu block(s)
%d@%zu.%06zu:nbd_init_trailing_bytes Ignoring trailing %d bytes of export
nbd_init_trailing_bytes Ignoring trailing %d bytes of export
Failed setting size (in blocks)
%d@%zu.%06zu:nbd_init_set_readonly Setting readonly attribute
nbd_init_set_readonly Setting readonly attribute
Failed setting read-only attribute
%d@%zu.%06zu:nbd_init_finish Negotiation ended
nbd_init_finish Negotiation ended
%d@%zu.%06zu:nbd_client_loop Doing NBD loop
nbd_client_loop Doing NBD loop
%d@%zu.%06zu:nbd_client_loop_ret NBD loop returned %d: %s
nbd_client_loop_ret NBD loop returned %d: %s
%d@%zu.%06zu:nbd_client_clear_queue Clearing NBD queue
nbd_client_clear_queue Clearing NBD queue
%d@%zu.%06zu:nbd_client_clear_socket Clearing NBD socket
nbd_client_clear_socket Clearing NBD socket
%d@%zu.%06zu:nbd_send_request Sending request to server: { .from = %lu, .len = %lu, .cookie = %lu, .flags = 0x%x, .type = %u (%s) }
nbd_send_request Sending request to server: { .from = %lu, .len = %lu, .cookie = %lu, .flags = 0x%x, .type = %u (%s) }
Server does not support export lists
%d@%zu.%06zu:nbd_receive_wrong_header Server sent unexpected magic 0x%x for negotiated mode %s
nbd_receive_wrong_header Server sent unexpected magic 0x%x for negotiated mode %s
reply->magic == NBD_SIMPLE_REPLY_MAGIC
%d@%zu.%06zu:nbd_receive_simple_reply Got simple reply: { .error = %d (%s), cookie = %lu }
nbd_receive_simple_reply Got simple reply: { .error = %d (%s), cookie = %lu }
chunk->magic == NBD_EXTENDED_REPLY_MAGIC
server chunk %u (%s) payload is too long
%d@%zu.%06zu:nbd_receive_reply_chunk_header Got reply chunk header: { flags = 0x%x, type = %u (%s), cookie = %lu, length = %u }
nbd_receive_reply_chunk_header Got reply chunk header: { flags = 0x%x, type = %u (%s), cookie = %lu, length = %u }
%d@%zu.%06zu:nbd_connect_thread_sleep timeout %lu
nbd_connect_thread_sleep timeout %lu
Connection attempt cancelled by timeout
%d@%zu.%06zu:nbd_unknown_error Squashing unexpected error %d to EINVAL
nbd_unknown_error Squashing unexpected error %d to EINVAL
REASSIGN_BLOCKS/INITIALIZE ELEMENT STATUS
READ_DEFECT_DATA/INITIALIZE_ELEMENT_STATUS_WITH_RANGE
/home/virus/AMD/AMD/include/scsi/pr-manager.h
%d@%zu.%06zu:pr_manager_run fd=%d cmd=0x%02x service action=0x%02x
pr_manager_run fd=%d cmd=0x%02x service action=0x%02x
%d@%zu.%06zu:pr_manager_execute fd=%d cmd=0x%02x service action=0x%02x
pr_manager_execute fd=%d cmd=0x%02x service action=0x%02x
No persistent reservation manager with id '%s'
Object with id '%s' is not a persistent reservation manager
n_written != QIO_CHANNEL_ERR_BLOCK
cdb[0] == PERSISTENT_RESERVE_OUT || cdb[0] == PERSISTENT_RESERVE_IN
cookie->type < BLOCK_MAX_IOTYPE
pool->busy_tasks < pool->max_busy_tasks
qemu_coroutine_self() == pool->main_co
Block driver '%s' not found or not supported
x-blockdev-amend doesn't support changing the block driver
Driver does not support x-blockdev-amend
job_is_cancelled(&job->common.job)
block_job_driver(job) == &backup_job_driver
The backup job only supports block checkpoint in sync=none mode
sync_mode != MIRROR_SYNC_MODE_INCREMENTAL
sync_bitmap || sync_mode != MIRROR_SYNC_MODE_BITMAP
Source and target cannot be the same
Compression is not supported for this drive %s
max-workers must be between 1 and %d
max-chunk must be zero (which means no limit) or positive
Source and target image have different sizes
Required max-chunk (%li) is less than backup cluster size (%li)
blkdebug: Resuming request '%s'
blkdebug requires both config file and image path
QEMU_IS_ALIGNED(offset, bs->bl.request_alignment)
QEMU_IS_ALIGNED(bytes, bs->bl.request_alignment)
QEMU_IS_ALIGNED(offset, align) || QEMU_IS_ALIGNED(offset + bytes, align) || DIV_ROUND_UP(offset, align) == DIV_ROUND_UP(offset + bytes, align)
QEMU_IS_ALIGNED(offset, align)
bytes <= bs->bl.max_pwrite_zeroes
QEMU_IS_ALIGNED(offset | bytes, bs->bl.request_alignment)
Could not read blkdebug config file
Cannot meet constraints with align %lu
Cannot meet constraints with max-transfer %lu
Cannot meet constraints with opt-write-zero %lu
Cannot meet constraints with max-write-zero %lu
Cannot meet constraints with opt-discard %lu
Cannot meet constraints with max-discard %lu
(int)event >= 0 && event < BLKDBG__MAX
blkdebug: Suspended request '%s'
Path to the configuration file
[internal use only, will be removed]
Maximum transfer size in bytes
Optimum write zero alignment in bytes
Maximum write zero size in bytes
Optimum discard alignment in bytes
(1 << s->sectorbits) == s->sectorsize
bs->bl.request_alignment == s->sectorsize
log-append and log-sector-size are mutually exclusive
Invalid flags 0x%lx in log entry %lu
Invalid log superblock update interval %lu
Log superblock update interval (# of write requests)
blkverify: %s offset=%ld bytes=%ld 
return value mismatch %d != %d
contents mismatch at offset %ld
Cannot generate a base directory for blkverify nodes
blkverify requires raw copy and original image path
qatomic_read(&blk->quiesce_counter)
%d@%zu.%06zu:blk_root_detach child %p blk %p bs %p
blk_root_detach child %p blk %p bs %p
%d@%zu.%06zu:blk_root_attach child %p blk %p bs %p
blk_root_attach child %p blk %p bs %p
Cannot change iothread of active block backend
blk->public.throttle_group_member.io_limits_disabled
Device with id '%s' already exists
Device name '%s' conflicts with an existing node name
(uint64_t)qiov->size <= INT64_MAX
%d@%zu.%06zu:blk_co_preadv blk %p bs %p offset %ld bytes %ld flags 0x%x
blk_co_preadv blk %p bs %p offset %ld bytes %ld flags 0x%x
%d@%zu.%06zu:blk_co_pwritev blk %p bs %p offset %ld bytes %ld flags 0x%x
blk_co_pwritev blk %p bs %p offset %ld bytes %ld flags 0x%x
!qiov || qiov->size == acb->bytes
QLIST_EMPTY(&blk->remove_bs_notifiers.notifiers)
QLIST_EMPTY(&blk->insert_bs_notifiers.notifiers)
QLIST_EMPTY(&blk->aio_notifiers)
qemu_co_queue_empty(&blk->queued_requests)
!blk->public.throttle_group_member.throttle_state
offset >= 0 && bytes > 0 && INT64_MAX - offset >= bytes
QEMU_IS_ALIGNED(offset, s->cluster_size)
QEMU_IS_ALIGNED(bytes, s->cluster_size)
offset + bytes <= s->len || offset + bytes == QEMU_ALIGN_UP(s->len, s->cluster_size)
%d@%zu.%06zu:block_copy_write_zeroes_fail bcs %p start %ld ret %d
block_copy_write_zeroes_fail bcs %p start %ld ret %d
%d@%zu.%06zu:block_copy_copy_range_fail bcs %p start %ld ret %d
block_copy_copy_range_fail bcs %p start %ld ret %d
%d@%zu.%06zu:block_copy_read_fail bcs %p start %ld ret %d
block_copy_read_fail bcs %p start %ld ret %d
%d@%zu.%06zu:block_copy_write_fail bcs %p start %ld ret %d
block_copy_write_fail bcs %p start %ld ret %d
bdrv_get_aio_context(s->source->bs) == bdrv_get_aio_context(s->target->bs)
!reqlist_find_conflict(&s->reqs, offset, bytes)
%d@%zu.%06zu:block_copy_skip_range bcs %p start %ld bytes %ld
block_copy_skip_range bcs %p start %ld bytes %ld
new_bytes > 0 && new_bytes < task->req.bytes
%d@%zu.%06zu:block_copy_process bcs %p start %ld
block_copy_process bcs %p start %ld
ret >= 0 || aio_task_pool_status(aio) < 0
min-cluster-size too large: %lu > %li
min-cluster-size needs to be a power of 2
The target block device doesn't provide information about the block size and it doesn't have a backing file. The (default) block size of %li bytes is used. If the actual block size of the target exceeds this value, the backup may be unusable
Couldn't determine the cluster size of the target image, which has no backing file
Aborting, since this may create an unusable destination image
Failed to merge bitmap '%s' to internal copy-bitmap: 
qatomic_read(&call_state->finished)
qatomic_load_acquire(&call_state->finished)
%d@%zu.%06zu:commit_one_iteration s %p offset %ld bytes %lu is_allocated %d
commit_one_iteration s %p offset %ld bytes %lu is_allocated %d
Invalid files for merge: top and base are the same
Could not inquire base image size
Could not inquire top image size
bdrv_skip_filters(filtered_base) == bdrv_skip_filters(base)
%d@%zu.%06zu:commit_start bs %p base %p top %p s %p
commit_start bs %p base %p top %p s %p
full_opts->driver == BLOCKDEV_DRIVER_COPY_BEFORE_WRITE
Cannot create block-copy-state: 
s->on_cbw_error == ON_CBW_ERROR_BREAK_SNAPSHOT
source->total_sectors == target->total_sectors
Driver does not support blockdev-create
info->format == QCRYPTO_BLOCK_FORMAT_LUKS
QEMU_IS_ALIGNED(offset, sector_size)
QEMU_IS_ALIGNED(bytes, sector_size)
Could not write encryption header
Could not read encryption header
The requested file size is too large
create_options->driver == BLOCKDEV_DRIVER_LUKS
Either the parameter 'header' or 'file' must be specified
Parameter 'preallocation' requires 'file' to be specified for formatting LUKS disk
Unable to get image virtual_size
Select new state of affected keyslots (active/inactive)
Select a single keyslot to modify explicitly
Select all keyslots that match this password
New secret to set in the matching keyslots. Empty string to erase
Time to spend in PBKDF in milliseconds
ID of the secret that provides the keyslot passphrase
Name of encryption cipher algorithm
Name of encryption cipher mode
Name of IV generator algorithm
Name of IV generator hash algorithm
Name of encryption hash algorithm
!bdrv_dirty_bitmap_busy(bitmap)
!bdrv_dirty_bitmap_has_successor(bitmap)
!bdrv_dirty_bitmap_readonly(bitmap)
is_power_of_2(granularity) && granularity >= BDRV_SECTOR_SIZE
could not get length of device
Bitmap '%s' is currently in use by another operation and cannot be used
Bitmap '%s' is readonly and cannot be modified
Bitmap '%s' is inconsistent and cannot be used
Try block-dirty-bitmap-remove to delete this bitmap from disk
Cannot create a successor for a bitmap that already has one
bitmap->bs == bitmap->successor->bs
Cannot relinquish control if there's no successor present
Cannot reclaim a successor when none is present
Can't store persistent bitmaps to %s
iter->bitmap->active_iterators > 0
QEMU_IS_ALIGNED(limit, bdrv_dirty_bitmap_serialization_align(bitmap))
!bdrv_dirty_bitmap_readonly(dest)
!bdrv_dirty_bitmap_inconsistent(dest)
!bdrv_dirty_bitmap_inconsistent(src)
Bitmaps are of different sizes (destination size is %ld, source size is %ld) and can't be merged
Compression is not supported for underlying format: %s
ctx->bdrv_graph->reader_count == 0
qatomic_read(&bs->in_flight) == 0
surplus_count <= !!pad->head + !!pad->tail
pad->local_qiov.niov == MIN(padded_niov, IOV_MAX)
*pnum && QEMU_IS_ALIGNED(*pnum, align) && align > offset - aligned_offset
ret & BDRV_BLOCK_OFFSET_VALID && local_file
Driver requires too large request alignment
bdrv_drain_all_count < INT_MAX
bytes(%li) exceeds maximum(%li)
offset(%li) exceeds maximum(%li)
sum of offset(%li) and bytes(%li) exceeds maximum(%li)
qiov_offset(%zu) overflow io vector size(%zu)
bytes(%li) + qiov_offset(%zu) overflow io vector size(%zu)
!(flags & ~bs->supported_read_flags)
QEMU_IS_ALIGNED(offset, BDRV_SECTOR_SIZE)
QEMU_IS_ALIGNED(bytes, BDRV_SECTOR_SIZE)
bytes <= BDRV_REQUEST_MAX_BYTES
qemu_coroutine_self() != req->co
(bs->open_flags & BDRV_O_NO_IO) == 0
!((flags & BDRV_REQ_NO_WAIT) && !(flags & BDRV_REQ_SERIALISING))
offset + bytes <= req->overlap_offset + req->overlap_bytes
offset + bytes <= bs->total_sectors * BDRV_SECTOR_SIZE || child->perm & BLK_PERM_RESIZE
child->perm & (BLK_PERM_WRITE_UNCHANGED | BLK_PERM_WRITE)
align % bs->bl.request_alignment == 0
max_pdiscard >= bs->bl.request_alignment
alignment % bs->bl.request_alignment == 0
max_write_zeroes >= bs->bl.request_alignment
!(flags & ~(BDRV_REQ_COPY_ON_READ | BDRV_REQ_PREFETCH | BDRV_REQ_REGISTERED_BUF))
%d@%zu.%06zu:bdrv_co_do_copy_on_readv bs %p offset %ld bytes %ld cluster_offset %ld cluster_bytes %ld
bdrv_co_do_copy_on_readv bs %p offset %ld bytes %ld cluster_offset %ld cluster_bytes %ld
!(flags & ~(bs->supported_read_flags | BDRV_REQ_REGISTERED_BUF))
%d@%zu.%06zu:bdrv_co_preadv_part bs %p offset %ld bytes %ld flags 0x%x
bdrv_co_preadv_part bs %p offset %ld bytes %ld flags 0x%x
%d@%zu.%06zu:bdrv_co_pwritev_part bs %p offset %ld bytes %ld flags 0x%x
bdrv_co_pwritev_part bs %p offset %ld bytes %ld flags 0x%x
!bytes || (offset & (align - 1)) == 0
%d@%zu.%06zu:bdrv_co_pwrite_zeroes bs %p offset %ld bytes %ld flags 0x%x
bdrv_co_pwrite_zeroes bs %p offset %ld bytes %ld flags 0x%x
!(read_flags & BDRV_REQ_NO_FALLBACK)
!(write_flags & BDRV_REQ_NO_FALLBACK)
!(read_flags & BDRV_REQ_NO_WAIT)
!(write_flags & BDRV_REQ_NO_WAIT)
!(read_flags & BDRV_REQ_SERIALISING)
%d@%zu.%06zu:bdrv_co_copy_range_from src %p offset %ld dst %p offset %ld bytes %ld rw flags 0x%x 0x%x
bdrv_co_copy_range_from src %p offset %ld dst %p offset %ld bytes %ld rw flags 0x%x 0x%x
%d@%zu.%06zu:bdrv_co_copy_range_to src %p offset %ld dst %p offset %ld bytes %ld rw flags 0x%x 0x%x
bdrv_co_copy_range_to src %p offset %ld dst %p offset %ld bytes %ld rw flags 0x%x 0x%x
Failed to prepare request for truncation
Could not get backing file size
Block driver does not support requested flags
Image format driver does not support resize
Change to copy mode '%s' is not implemented
Expected current copy mode '%s', got '%s'
!bdrv_backing_chain_next(target_bs)
Can no longer replace '%s' by '%s', because it can no longer be guaranteed that doing so would not lead to an abrupt change of visible data
%d@%zu.%06zu:mirror_iteration_done s %p offset %ld bytes %lu ret %d
mirror_iteration_done s %p offset %ld bytes %lu ret %d
Cannot mirror to a filter on top of a node in the source's backing chain
bdrv_skip_filters(filtered_target) == bdrv_skip_filters(target)
%d@%zu.%06zu:mirror_start bs %p s %p opaque %p
mirror_start bs %p s %p opaque %p
mirror_top_bs->backing->bs == bs
block device is in use by block-job-complete
op->bytes < BDRV_REQUEST_MAX_BYTES
*op->bytes_handled <= UINT_MAX
QEMU_IS_ALIGNED(op->offset, s->granularity)
QEMU_IS_ALIGNED(op->bytes, BDRV_SECTOR_SIZE)
%d@%zu.%06zu:mirror_yield_in_flight s %p offset %ld in_flight %d
mirror_yield_in_flight s %p offset %ld in_flight %d
%d@%zu.%06zu:mirror_one_iteration s %p offset %ld bytes %lu
mirror_one_iteration s %p offset %ld bytes %lu
%d@%zu.%06zu:mirror_yield s %p dirty count %ld free buffers %d in_flight %d
mirror_yield s %p dirty count %ld free buffers %d in_flight %d
%d@%zu.%06zu:mirror_restart_iter s %p dirty count %ld
mirror_restart_iter s %p dirty count %ld
%d@%zu.%06zu:mirror_before_flush s %p
%d@%zu.%06zu:mirror_before_drain s %p dirty count %ld
mirror_before_drain s %p dirty count %ld
s->in_active_write_counter == 0
QLIST_EMPTY(&bs->tracked_requests)
%d@%zu.%06zu:mirror_before_sleep s %p dirty count %ld synced %d delay %luns
mirror_before_sleep s %p dirty count %ld synced %d delay %luns
ret < 0 || job_is_cancelled(&s->common.job)
!bdrv_get_dirty_count(op->s->dirty_bitmap)
Cannot generate a base directory for NBD nodes
Option '%s' cannot be used with a file name
File name string for NBD must start with 'nbd:'
Can't reopen read-only NBD mount as read/write
Cannot use 'server' and path/host/port at the same time
path and host may not be used at the same time
port may not be used without host
export name too long to send to server
x-dirty-bitmap query too long to send to server
Protocol error: simple reply when structured reply chunk was expected
s->info.mode >= NBD_MODE_STRUCTURED
Protocol error: NBD_REPLY_TYPE_NONE chunk without NBD_REPLY_FLAG_DONE flag set
Protocol error: NBD_REPLY_TYPE_NONE chunk with nonzero length
Unexpected NBD_REPLY_TYPE_OFFSET_DATA chunk
nbd_reply_is_structured(&s->reply)
Protocol error: invalid payload for NBD_REPLY_TYPE_OFFSET_DATA
Protocol error: server sent chunk exceeding requested region
%d@%zu.%06zu:nbd_structured_read_compliance server sent non-compliant unaligned read %s chunk
nbd_structured_read_compliance server sent non-compliant unaligned read %s chunk
Protocol error: invalid payload for structured error
Protocol error: server sent structured error chunk with error = 0
Protocol error: server sent structured error chunk with incorrect message size
chunk->flags & NBD_REPLY_FLAG_DONE
requested x-dirty-bitmap %s not found
%d@%zu.%06zu:nbd_client_handshake_success export '%s'
nbd_client_handshake_success export '%s'
%d@%zu.%06zu:nbd_reconnect_attempt in_flight %u
nbd_reconnect_attempt in_flight %u
%d@%zu.%06zu:nbd_reconnect_attempt_result ret %d in_flight %u
nbd_reconnect_attempt_result ret %d in_flight %u
nbd_reply_is_structured(&reply)
Protocol error: invalid payload for NBD_REPLY_TYPE_OFFSET_HOLE
Unexpected reply type: %d (%s) for CMD_READ
%d@%zu.%06zu:nbd_co_request_fail Request failed { .from = %lu, .len = %lu, .handle = %lu, .flags = 0x%x, .type = %u (%s) } ret = %d, err: %s
nbd_co_request_fail Request failed { .from = %lu, .len = %lu, .handle = %lu, .flags = 0x%x, .type = %u (%s) } ret = %d, err: %s
QEMU_IS_ALIGNED(request.len, s->info.min_block)
%d@%zu.%06zu:nbd_extended_headers_compliance server sent non-compliant %s chunk not matching choice of extended headers
nbd_extended_headers_compliance server sent non-compliant %s chunk not matching choice of extended headers
Several BLOCK_STATUS chunks in reply
Protocol error: invalid payload for NBD_REPLY_TYPE_BLOCK_STATUS
Protocol error: unexpected context id %d for NBD_REPLY_TYPE_BLOCK_STATUS, when negotiated context id is %d
Protocol error: server sent status chunk with zero length
%d@%zu.%06zu:nbd_parse_blockstatus_compliance ignoring extra data from non-compliant server: %s
nbd_parse_blockstatus_compliance ignoring extra data from non-compliant server: %s
Unexpected reply type: %d (%s) for CMD_BLOCK_STATUS
Server did not reply with any status extents
request->type == NBD_CMD_WRITE
request->len == iov_size(write_qiov->iov, write_qiov->niov)
bytes <= UINT32_MAX || s->info.mode >= NBD_MODE_EXTENDED
!(s->info.flags & NBD_FLAG_READ_ONLY)
s->info.flags & NBD_FLAG_SEND_FUA
s->info.flags & NBD_FLAG_SEND_FAST_ZERO
Unix socket path to connect to
Name of the NBD export to open
ID of the TLS credentials to use
Override hostname for validating TLS x509 certificate
experimental: expose named dirty bitmap in place of block status
On an unexpected disconnect, the nbd client tries to connect again until succeeding or encountering a serious error.  During the first @reconnect-delay seconds, all requests are paused and will be rerun on a successful reconnect. After that time, any delayed requests and all future requests before a successful reconnect will immediately fail. Default 0
In seconds. If zero, the nbd driver tries the connection only once, and fails to open if the connection fails. If non-zero, the nbd driver will repeat connection attempts until successful or until @open-timeout seconds have elapsed. Default 0
The only allowed filename for this driver is 'null-aio://'
The only allowed filename for this driver is 'null-co://'
nanoseconds (approximated) to wait before completing request
prealloc-align parameter of preallocate filter is not aligned to %llu
prealloc-align parameter of preallocate filter is not aligned to underlying node request alignment (%i)
!(bs->file->shared_perm & BLK_PERM_WRITE)
!(bs->file->shared_perm & BLK_PERM_RESIZE)
QEMU_IS_ALIGNED(prealloc_align, file_align)
preallocate-filter: failed to drop write-zero preallocation: 
on preallocation, align file length to this number, default 1M
how much to preallocate, default 128M
Device '%s' does not support internal snapshots
Can't list snapshots of device '%s'
%s%s: %s
%s%s: %s
%s%s: %s (%ld bytes)
%sdisk size: %s
 (cannot determine actual path)
info->operations_completed < info->total_operations
%d@%zu.%06zu:qcow2_add_task co %p bs %p pool %p: %s: cluster_type %d file_cluster_offset %lu offset %lu bytes %lu qiov %p qiov_offset %zu
qcow2_add_task co %p bs %p pool %p: %s: cluster_type %d file_cluster_offset %lu offset %lu bytes %lu qiov %p qiov_offset %zu
Request for data outside of extension header
Cluster size must be a power of two between %d and %dk
Extended L2 entries are only supported with cluster sizes of at least %u bytes
%d@%zu.%06zu:qcow2_writev_start_req co %p offset 0x%lx bytes %ld
qcow2_writev_start_req co %p offset 0x%lx bytes %ld
%d@%zu.%06zu:qcow2_writev_start_part co %p
qcow2_writev_start_part co %p
%d@%zu.%06zu:qcow2_writev_done_part co %p cur_bytes %d
qcow2_writev_done_part co %p cur_bytes %d
%d@%zu.%06zu:qcow2_writev_done_req co %p ret %d
qcow2_writev_done_req co %p ret %d
%d@%zu.%06zu:qcow2_pwrite_zeroes_start_req co %p offset 0x%lx bytes %ld
qcow2_pwrite_zeroes_start_req co %p offset 0x%lx bytes %ld
head + bytes + tail <= s->subcluster_size
%d@%zu.%06zu:qcow2_pwrite_zeroes co %p offset 0x%lx bytes %ld
qcow2_pwrite_zeroes co %p offset 0x%lx bytes %ld
image is not encrypted, can't amend
Amend can't be used to change the qcow2 encryption format
Only LUKS encryption options can be amended for qcow2 with blockdev-amend
Cannot allocate cluster for LUKS header size %zu
qcow2_pre_write_overlap_check(bs, 0, ret, clusterlen, false) == 0
Could not zero fill encryption header
%s: Failed to make dirty bitmaps writable: 
bytes <= QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size
%d@%zu.%06zu:qcow2_skip_cow co %p offset 0x%lx nb_clusters %d
qcow2_skip_cow co %p offset 0x%lx nb_clusters %d
offset + bytes > m->offset + m->cow_end.offset
%d@%zu.%06zu:qcow2_writev_data co %p offset 0x%lx
qcow2_writev_data co %p offset 0x%lx
!t->subcluster_type && !t->l2meta
bytes == s->cluster_size || (bytes < s->cluster_size && (offset + bytes == bs->total_sectors << BDRV_SECTOR_BITS))
qcow2: unknown compression type: %u
qcow2: Compression type incompatible feature bit must not be set
qcow2: Compression type incompatible feature bit must be set
qcow2_read_extension: ERROR: pread fail from offset %lu
ERROR: ext_backing_format: len=%u too large (>=%zu)
ERROR: ext_backing_format: Could not read format name
ERROR: ext_feature_table: Could not read table
CRYPTO header extension only expected with LUKS encryption method
CRYPTO header extension size %u, but expected size %zu
Unable to read CRYPTO header extension
Encryption header offset '%lu' is not a multiple of cluster size '%u'
bitmaps_ext: Invalid extension length
This qcow2 v2 image contains bitmaps, but they may have been modified by a program without persistent bitmap support; so now they must all be considered inconsistent
a program lacking bitmap support modified this file, so all bitmaps are now considered inconsistent
Some clusters may be leaked, run 'qemu-img check -r' on the image file to fix.
bitmaps_ext: Could not read ext header
bitmaps_ext: Reserved field is not zero
bitmaps_ext: Image has %u bitmaps, exceeding the QEMU supported maximum of %d
found bitmaps extension with zero bitmaps
bitmaps_ext: invalid bitmap directory offset
bitmaps_ext: bitmap directory size (%lu) exceeds the maximum supported size (%d)
ERROR: Could not read data file name
ERROR: unknown extension: Could not read data
create_options->driver == BLOCKDEV_DRIVER_QCOW2
Image size must be a multiple of %u bytes
Extended L2 entries are only supported with compatibility level 1.1 and above (use version=v3 or greater)
Backing file and preallocation can only be used at the same time if extended_l2 is on
Backing format cannot be used without backing file
Lazy refcounts only supported with compatibility level 1.1 and above (use version=v3 or greater)
Refcount width must be a power of two and may not exceed 64 bits
Different refcount widths than 16 bits require compatibility level 1.1 or above (use version=v3 or greater)
data-file-raw requires data-file
Backing file and data-file-raw cannot be used at the same time
External data files are only supported with compatibility level 1.1 and above (use version=v3 or greater)
Non-zlib compression type is only supported with compatibility level 1.1 and above (use version=v3 or greater)
Could not write refcount table
Could not allocate clusters for qcow2 header and refcount table
Huh, first cluster in empty image is already in use?
Could not assign backing file '%s' with format '%s'
Crypto format not supported in qcow2
Lost persistent bitmaps during inactivation of node '%s': 
Failed to flush the L2 table cache: %s
Failed to flush the refcount block cache: %s
Unknown compatibility level %s
Can't amend encryption options - encryption not present
Only LUKS encryption options can be amended
data-file can only be set for images that use an external data file
data-file-raw cannot be set on existing images
target_version > current_version
Failed to update the snapshot table
Failed to update the image header
Refcount widths other than 16 bits require compatibility level 1.1 or above (use compat=1.1 or greater)
You can use 'qemu-img rebase' instead.
Lazy refcounts only supported with compatibility level 1.1 and above (use compat=1.1 or greater)
Failed to make the image clean
target_version < current_version
compat=0.10 requires refcount_bits=16
Cannot downgrade an image with a data file
Internal snapshots prevent downgrade of image
Cannot downgrade an image with incompatible features 0x%lx set
Failed to turn zero into data clusters
Cannot downgrade an image with zstd compression type and existing compressed clusters
cache-size, l2-cache-size and refcount-cache-size may not be set at the same time
l2-cache-size may not exceed cache-size
refcount-cache-size may not exceed cache-size
L2 cache entry size must be a power of two between %d and the cluster size (%d)
Failed to flush the L2 table cache
Failed to flush the refcount block cache
Could not allocate metadata caches
Lazy refcounts require a qcow2 image with at least qemu 1.1 compatibility level
Failed to disable lazy refcounts
Conflicting values for qcow2 options 'overlap-check' ('%s') and 'overlap-check.template' ('%s')
Unsupported value '%s' for qcow2 option 'overlap-check'. Allowed are any of the following: none, constant, cached, all
discard-no-unref is only supported since qcow2 version 3
No encryption in image header, but options specified format '%s'
Header reported 'aes' encryption format but options specify '%s'
Header reported 'luks' encryption format but options specify '%s'
Unsupported encryption method %d
The new size must be a multiple of %u
Can't resize a v2 image which has snapshots
Preallocation can't be used for shrinking an image
Failed to discard cropped clusters
Failed to reduce the number of L2 tables
Failed to discard unused refblocks
Failed to inquire current file length
Failed to find the last cluster
Failed to truncate the tail of the image: 
Failed to resize refcount structures
Failed to allocate data clusters
clusters_allocated == nb_new_data_clusters
Failed to resize underlying file: 
Failed to zero out new clusters
Failed to zero out the new area
Failed to flush the preallocated area to disk
Failed to update the image size
s->data_file == state->bs->file
Unsupported cluster size: 2^%u
qcow2 header exceeds cluster size
Could not read unknown qcow2 header fields
Unknown incompatible feature: %lx
Unsupported qcow2 feature(s): %s
qcow2: Image is corrupt; cannot be opened read/write
Unsupported subcluster size: %d
Reference count entry width too large; may not exceed 64 bits
Use of AES-CBC encrypted qcow2 images is no longer supported in system emulators
You can use 'qemu-img convert' to convert your image to an alternative supported format, such as unencrypted qcow2, or raw with the LUKS format instead.
Image does not contain a reference count table
Could not initialize refcount handling
'data-file' can only be set for images with an external data file
data-file-raw requires a data file
Missing CRYPTO header for crypt method %d
Could not read backing file name
'data-file' is required for this image
Could not reopen qcow2 layer: 
3 + l1_clusters <= s->refcount_block_size
First cluster in emptied image is in use
Invalid compatibility level: '%s'
Different refcount widths than 16 bits require compatibility level 1.1 or above (use compat=1.1 or greater)
The image size is too large (try using a larger cluster size)
qcow2: Marking image as corrupt: %s; further corruption events will be suppressed
qcow2: Image is corrupt: %s; further non-fatal corruption events will be suppressed
Compatibility level (v2 [0.10] or v3 [1.1])
Image format of the base image
File name of an external data file
The external data file must stay valid as a raw image
Width of a reference count entry in bits
Encrypt the image with format 'aes'. (Deprecated in favor of encrypt.format=aes)
Encrypt the image, format choices: 'aes', 'luks'
ID of secret providing qcow AES key or LUKS passphrase
Preallocation mode (allowed values: off, metadata, falloc, full)
Compression method used for image cluster compression
overlap-check.bitmap-directory
Pass guest discard requests to the layer below
Generate discard requests when snapshot related space is freed
Generate discard requests when other clusters are freed
Do not unreference discarded clusters
Selects which overlap checks to perform from a range of templates (none, constant, cached, all)
Check for unintended writes into the main qcow2 header
Check for unintended writes into the active L1 table
Check for unintended writes into an active L2 table
Check for unintended writes into the refcount table
Check for unintended writes into a refcount block
Check for unintended writes into the snapshot table
Check for unintended writes into an inactive L1 table
Check for unintended writes into an inactive L2 table
Check for unintended writes into the bitmap directory
Maximum combined metadata (L2 tables and refcount blocks) cache size
Size of each entry in the L2 cache
Maximum refcount block cache size
Clean unused cache entries after this time (in seconds)
ID of secret providing qcow2 AES key or LUKS passphrase
tb->size <= BME_MAX_TABLE_SIZE
(granularity & (granularity - 1)) == 0
Granularity is under minimum (%llu bytes)
Too much space will be occupied by the bitmap. Use larger granularity
Name length exceeds maximum (%u characters)
Requested bitmap directory size is zero
Requested bitmap directory size is too big
Failed to allocate space for bitmap directory
Failed to read bitmap directory
More bitmaps found than specified in header extension
Bitmap extra data is not supported
Bitmap '%.*s' doesn't satisfy the constraints
Less bitmaps found than specified in header extension
Could not read bitmap_table table from image for bitmap '%s'
check_table_entry(entry, s->cluster_size) == 0
Could not read bitmap '%s' from image
Unexpected bitmap '%s' in image '%s'
Corruption: bitmap '%s' is not marked IN_USE in the image '%s' and not marked readonly in RAM
Corruption: bitmap '%s' is inconsistent but is not marked IN_USE in the image '%s'
Corruption: bitmap '%s' is marked IN_USE in the image '%s' but it is readonly and consistent in RAM
Failed to reopen bitmaps rw: no write access the protocol file
Cannot update bitmap directory
Cannot resize qcow2 with persistent bitmaps that were not loaded into memory
Failed to update bitmap extension
Bitmap '%s' doesn't satisfy the constraints: 
Bitmap '%s' already exists in the image
DIV_ROUND_UP(bm_size, limit) == tb_size
Failed to allocate clusters for bitmap '%s'
Failed to write bitmap '%s' to file
Cannot store dirty bitmaps in qcow2 v2 files
Maximum number of persistent bitmaps is already reached
Not enough space in the bitmap directory
Can't make bitmap '%s' persistent in '%s': 
idx >= 0 && idx < c->size && table_offset % c->table_size == 0
table_size >= (1 << MIN_CLUSTER_BITS)
%d@%zu.%06zu:qcow2_cache_flush co %p is_l2_cache %d
qcow2_cache_flush co %p is_l2_cache %d
%d@%zu.%06zu:qcow2_cache_entry_flush co %p is_l2_cache %d index %d
qcow2_cache_entry_flush co %p is_l2_cache %d index %d
%d@%zu.%06zu:qcow2_cache_get co %p is_l2_cache %d offset 0x%lx read_from_disk %d
qcow2_cache_get co %p is_l2_cache %d offset 0x%lx read_from_disk %d
Cannot get entry from %s cache: Offset %#lx is unaligned
%d@%zu.%06zu:qcow2_cache_get_replace_entry co %p is_l2_cache %d index %d
qcow2_cache_get_replace_entry co %p is_l2_cache %d index %d
%d@%zu.%06zu:qcow2_cache_get_read co %p is_l2_cache %d index %d
qcow2_cache_get_read co %p is_l2_cache %d index %d
%d@%zu.%06zu:qcow2_cache_get_done co %p is_l2_cache %d index %d
qcow2_cache_get_done co %p is_l2_cache %d index %d
src_cluster_offset <= INT64_MAX
src_cluster_offset + offset_in_cluster <= INT64_MAX
L2 table offset %#lx unaligned (L1 index: %#x)
(offset & L2E_OFFSET_MASK) == offset
Cluster allocation offset %#lx unaligned (L2 offset: %#lx, L2 index: %#x)
sc_index < s->subclusters_per_cluster
nb_clusters <= s->l2_slice_size - l2_index
Invalid cluster entry found (L2 offset: %#lx, L2 index: %#x)
L2 table offset %#lx unaligned (L1 index: %#lx)
%d@%zu.%06zu:qcow2_l2_allocate bs %p l1_index %d
qcow2_l2_allocate bs %p l1_index %d
(l2_offset & L1E_OFFSET_MASK) == l2_offset
Preventing invalid allocation of L2 table at offset 0
%d@%zu.%06zu:qcow2_l2_allocate_get_empty bs %p l1_index %d
qcow2_l2_allocate_get_empty bs %p l1_index %d
%d@%zu.%06zu:qcow2_l2_allocate_write_l2 bs %p l1_index %d
qcow2_l2_allocate_write_l2 bs %p l1_index %d
%d@%zu.%06zu:qcow2_l2_allocate_write_l1 bs %p l1_index %d
qcow2_l2_allocate_write_l1 bs %p l1_index %d
%d@%zu.%06zu:qcow2_l2_allocate_done bs %p l1_index %d ret %d
qcow2_l2_allocate_done bs %p l1_index %d ret %d
offset_into_cluster(s, l2_offset) == 0
nb_subclusters > 0 && nb_subclusters < s->subclusters_per_cluster
sc + nb_subclusters <= s->subclusters_per_cluster
offset_into_subcluster(s, offset) == 0
Zero cluster entry found in pre-v3 image (L2 offset: %#lx, L2 index: %#x)
Compressed cluster entry found in image with external data file (L2 offset: %#lx, L2 index: %#x)
External data file host cluster offset %#lx does not match guest cluster offset: %#lx, L2 index: %#x)
*l2_index + nb_clusters <= s->l2_slice_size
Invalid cluster entry found  (L2 offset: %#lx, L2 index: %#x)
bytes_available - offset_in_cluster <= UINT_MAX
(cluster_offset & s->cluster_offset_mask) == cluster_offset
(nb_csectors & s->csize_mask) == nb_csectors
%d@%zu.%06zu:qcow2_cluster_link_l2 co %p nb_clusters %d
qcow2_cluster_link_l2 co %p nb_clusters %d
start->nb_bytes <= UINT_MAX - end->nb_bytes
start->nb_bytes + end->nb_bytes <= UINT_MAX - data_bytes
start->offset + start->nb_bytes <= end->offset
align > 0 && align <= UINT_MAX
QEMU_ALIGN_UP(start->nb_bytes, align) <= UINT_MAX - end->nb_bytes
l2_index + m->nb_clusters <= s->l2_slice_size
m->cow_end.offset + m->cow_end.nb_bytes <= m->nb_clusters << s->cluster_bits
%d@%zu.%06zu:qcow2_alloc_clusters_offset co %p offset 0x%lx bytes %d
qcow2_alloc_clusters_offset co %p offset 0x%lx bytes %d
%d@%zu.%06zu:qcow2_handle_copied co %p guest_offset 0x%lx host_offset 0x%lx bytes 0x%lx
qcow2_handle_copied co %p guest_offset 0x%lx host_offset 0x%lx bytes 0x%lx
*host_offset == INV_OFFSET || offset_into_cluster(s, guest_offset) == offset_into_cluster(s, *host_offset)
%s cluster offset %#lx unaligned (guest offset: %#lx)
%d@%zu.%06zu:qcow2_handle_alloc co %p guest_offset 0x%lx host_offset 0x%lx bytes 0x%lx
qcow2_handle_alloc co %p guest_offset 0x%lx host_offset 0x%lx bytes 0x%lx
%d@%zu.%06zu:qcow2_do_alloc_clusters_offset co %p guest_offset 0x%lx host_offset 0x%lx nb_clusters %d
qcow2_do_alloc_clusters_offset co %p guest_offset 0x%lx host_offset 0x%lx nb_clusters %d
*host_offset == INV_OFFSET || *host_offset == start_of_cluster(s, guest_offset)
%d@%zu.%06zu:qcow2_cluster_alloc_phys co %p
qcow2_cluster_alloc_phys co %p
alloc_cluster_offset != INV_OFFSET
offset_into_cluster(s, *host_offset) == offset_into_cluster(s, offset)
QEMU_IS_ALIGNED(end_offset, s->cluster_size) || end_offset == bs->total_sectors << BDRV_SECTOR_BITS
offset_into_subcluster(s, end_offset) == 0 || end_offset >= bs->total_sectors << BDRV_SECTOR_BITS
qcow2_get_cluster_type(bs, l2_entry) == QCOW2_CLUSTER_COMPRESSED
d->bytes + length == new_end - new_start
p->offset == d->offset + d->bytes || d->offset == p->offset + p->bytes
Refblock offset %#lx unaligned (reftable index: %#lx)
Image is corrupt (unaligned refblock offset)
Cannot decrease refcount entry width to %i bits: Cluster at offset %#lx has a refcount of %lu
entries < (UINT64_C(1) << (64 - 9))
s->refcount_order >= 0 && s->refcount_order <= 6
s->refcount_table_size <= INT_MAX / REFTABLE_ENTRY_SIZE
%d@%zu.%06zu:qcow2_process_discards_failed_region offset 0x%lx bytes 0x%lx ret %d
qcow2_process_discards_failed_region offset 0x%lx bytes 0x%lx ret %d
qcow2_free_clusters failed: %s
!(start_offset % s->cluster_size)
new_refblock_index < total_refblock_count
s->get_refcount(refblock_data, j) == 0
Refblock offset %#lx unaligned (reftable index: %#x)
(new_block & REFT_OFFSET_MASK) == new_block
Preventing invalid allocation of refcount block at offset 0
This operation would make the refcount table grow beyond the maximum size supported by QEMU, aborting
Failed to increase reftable buffer size
size > 0 && size <= s->cluster_size
!s->free_byte_offset || offset_into_cluster(s, s->free_byte_offset)
Preventing invalid allocation of compressed cluster at offset 0
Can't get refcount for cluster %ld: %s
%s cluster %ld refcount=%lu reference=%lu
Cannot free unaligned cluster %#llx
ERROR: counting reference for region exceeding the end of the file by one cluster or more: offset 0x%lx size 0x%lx
ERROR: overflow cluster offset=0x%lx
Use qemu-img amend to increase the refcount entry width or qemu-img convert to create a clean copy if the image cannot be opened for writing
last_entry < s->refcount_table_size
last_entry + 1 == s->refcount_table_size || (s->refcount_table[last_entry + 1] & REFT_OFFSET_MASK) == 0
Preventing invalid write on metadata (overlaps with %s)
ERROR allocating reftable memory
ERROR: I/O error in check_refcounts_l1
ERROR found L1 entry with reserved bits set: %lx
ERROR l2_offset=%lx: Table is not cluster aligned; L1 entry corrupted
ERROR: I/O error in check_refcounts_l2
ERROR: coffset=0x%lx: copied flag must never be set for compressed clusters
ERROR compressed cluster %d with data file, entry=0x%lx
ERROR compressed cluster %d with non-zero subcluster allocation bitmap, entry=0x%lx
ERROR offset=%lx: Allocated cluster has corrupted subcluster allocation bitmap
%s offset=%lx: Preallocated cluster is not properly aligned; L2 entry corrupted.
ERROR: Failed to overwrite L2 table entry: %s
ERROR offset=%lx: Data cluster is not properly aligned; L2 entry corrupted.
ERROR: Unallocated cluster has non-zero subcluster allocation map
ERROR found l2 entry with reserved bits set: %lx
ERROR %d snapshots in image with data file
ERROR snapshot %s (%s) l1_offset=%#lx: L1 table is not cluster aligned; snapshot table entry corrupted
ERROR snapshot %s (%s) l1_size=%#x: L1 table is too large; snapshot table entry corrupted
ERROR refcount table entry %ld has reserved bits set
ERROR refcount block %ld is not cluster aligned; refcount table entry corrupted
%s refcount block %ld is outside image
new_nb_clusters >= *nb_clusters
ERROR could not resize image: %s
ERROR refcount block %ld refcount=%lu
Rebuilding refcount structure
offset_into_cluster(s, reftable_offset) == 0
ERROR rebuilt refcount structure is still broken
ERROR need to rebuild refcount structures
ERROR: Could not read L2 table: %s
ERROR: Could not write L2 table; metadata overlap check failed: %s
ERROR: Could not write L2 table: %s
%s OFLAG_COPIED data cluster: l2_entry=%lx refcount=%lu
%s OFLAG_COPIED L2 cluster: l1_index=%d l1_entry=%lx refcount=%lu
refcount_order >= 0 && refcount_order <= 6
Failed to allocate the new reftable
Failed to write the new reftable
Failed to flush the refblock cache
Failed to update the qcow2 header
Refblock at %#lx is not covered by the refcount structures
Invalid refcount: refblock offset %#lx, reftable index %u, block offset %#lx, refcount %#lx
There are no references in the refcount table.
/home/virus/AMD/AMD/include/qemu/coroutine.h
qatomic_read(&mutex->locked) && mutex->holder == qemu_coroutine_self()
Too much extra metadata in snapshot table entry %i
You can force-remove this extra metadata with qemu-img check -r all
Discarding too much extra metadata in snapshot table entry %i (%u > %u)
table_length == offset - s->snapshots_offset
You can force-remove all %u overhanging snapshots with qemu-img check -r all
Discarding %u overhanging snapshots (snapshot table is too big)
offset - s->snapshots_offset <= INT_MAX
id_str_size <= UINT16_MAX && name_size <= UINT16_MAX
unknown_extra_data_size <= BDRV_REQUEST_MAX_BYTES
ERROR failed to read the snapshot table pointer from the image header: %s
Discarding %u overhanging snapshots
ERROR failed to read the snapshot table: 
ERROR failed to update the snapshot count in the image header: %s
%s snapshot table entry %i is incomplete
ERROR failed to update snapshot table: %s
Failed to remove snapshot from snapshot list
Failed to free the cluster and L1 table
Failed to update snapshot status in disk
Failed to read l1 table for snapshot
QEMU_IS_ALIGNED(guest_offset, sector_size)
QEMU_IS_ALIGNED(host_offset, sector_size)
QEMU_IS_ALIGNED(len, sector_size)
dest->iov[i].iov_len == source->iov[i].iov_len
Cannot generate a base directory for quorum nodes
Option children is not a valid array
Number of provided children must be 1 or more
threshold may not exceed children count
Please set read-pattern as fifo or quorum
blkverify=on can only be set if there are exactly two files and vote-threshold is 2
rewrite-corrupted=on cannot be used with blkverify=on
acb->success_count <= s->num_children
The number of children cannot be lower than the vote threshold %d
quorum: offset=%lu bytes=%lu contents mismatch at offset %lu
a->iov[i].iov_len == b->iov[i].iov_len
Cannot add a child to a quorum in blkverify mode
s->num_children <= INT_MAX / sizeof(BdrvChild *)
The number of vote needed for reaching quorum
Trigger block verify mode if set
Rewrite corrupted block on read quorum
Allowed pattern: quorum, fifo. Quorum is default
Cannot resize fixed-size raw disks
Disk size too large for the chosen offset
offset == 0 && bytes >= BLOCK_PROBE_BUF_SIZE
Offset (%lu) cannot be greater than size of the containing file (%ld)
The sum of offset (%lu) and size (%lu) has to be smaller or equal to the  actual size of the containing file (%ld)
Specified size is not multiple of %llu
WARNING: Image format was not specified for '%s' and probing guessed raw.
         Automatically detecting the format is dangerous for raw images, write operations on block 0 will be restricted.
         Specify the 'raw' format explicitly to remove the restrictions.
Cannot use offset/size with SCSI generic devices
offset in the disk where the image starts
new_bytes > 0 && new_bytes < req->bytes
At least one device is required for snapshot
Device has active dirty bitmaps
bdrv_primary_bs(bs) == fallback_bs
Block driver does not support snapshots
snapshot_id and name are both NULL
Block format '%s' used by device '%s' does not support internal snapshot deletion
Block format '%s' used by device '%s' does not support temporarily loading internal snapshots
Device '%s' is writable but does not support snapshots
Could not delete snapshot '%s' on '%s': 
Could not load snapshot '%s' on '%s': 
Could not create snapshot '%s' on '%s'
vmstate block device '%s' does not support snapshots
vmstate block device '%s' does not exist
no block device can store vmstate for snapshot
Please specify a throttle group
Throttle group '%s' does not exist
token == tgm || tgm_has_pending_reqs(token, direction)
!timer_pending(tgm->throttle_timers.timers[direction])
/home/virus/AMD/AMD/include/block/throttle-groups.h
Property cannot be set after initialization
Property values cannot be negative
%s value must be in therange [0, %u]
A group with this name already exists
qemu_co_queue_empty(&tgm->throttled_reqs[dir])
!timer_pending(tgm->throttle_timers.timers[dir])
opts->driver == BLOCKDEV_DRIVER_QCOW
Image size is too small, cannot be zero length
unrecognized backing format '%s'
create_options->driver == BLOCKDEV_DRIVER_QCOW
qcow (v%d) does not support qcow version %u
Try the 'qcow2' driver instead.
Image size is too small (must be at least 2 bytes)
Cluster size must be between 512 and 64k
L2 table size must be between 512 and 64k
Use of AES-CBC encrypted qcow images is no longer supported in system emulators
You can use 'qemu-img convert' to convert your image to an alternative supported format, such as unencrypted qcow, or raw with the LUKS format instead.
invalid encryption method in qcow header
Could not allocate memory for L1 table
Could not allocate L2 table cache
The qcow format used by node '%s' does not support live migration
QEMU_IS_ALIGNED(n_start | n_end, BDRV_SECTOR_SIZE)
Encrypt the image, format choices: 'aes'
ID of the secret that provides the AES encryption key
ERROR: block index %u also used by %u
ERROR: block index %u too large, is %u
ERROR: allocated blocks mismatch, is %u, should be %u
create_options->driver == BLOCKDEV_DRIVER_VDI
Preallocation mode not supported for vdi
Unsupported VDI image size (size is 0x%lx, max supported is 0x%lx)
<<< QEMU VM Virtual Disk Image >>>
Failed to statically allocate file
Image not in VDI format (bad signature %08x)
unsupported VDI image (version %u.%u)
unsupported VDI image (unaligned block map offset 0x%x)
unsupported VDI image (unaligned data offset 0x%x)
unsupported VDI image (sector size %u is not %llu)
unsupported VDI image (block size %u is not %u)
unsupported VDI image (disk size %lu, image bitmap has room for %lu)
unsupported VDI image (non-NULL link UUID)
unsupported VDI image (non-NULL parent UUID)
unsupported VDI image (too many blocks %u, max is %u)
The vdi format used by node '%s' does not support live migration
VDI static (pre-allocated) image
Invalid VHDX log descriptor entry signature 0x%x
VHDX image file '%s' opened read-only, but contains a log that needs to be replayed
To replay the log, run:
qemu-img check -r all '%s'
Could not determinate VHDX image file size.
VHDX BAT entry %lu offset overflow.
VHDX BAT entry %lu start offset %lu points after end of file (%li). Image has probably been truncated.
VHDX BAT entry %lu end offset %lu points after end of file (%li). Image has probably been truncated.
VHDX region %lu-%lu overlaps with region %lu-%.lu
size > (crc_offset + sizeof(crc))
opts->driver == BLOCKDEV_DRIVER_VHDX
Image size too large; max of 64TB
Log size must be smaller than 4 GB
Log size must be a multiple of 1 MB
Block size must be a multiple of 1 MB
Block size must be a power of two
Block size must not exceed %ld
Failed to write file signature
!QLIST_NEXT(child, next_parent)
Failed to allocate memory for the BAT
Failed to write first region table
Failed to write second region table
create_options->driver == BLOCKDEV_DRIVER_VHDX
The vhdx format used by node '%s' does not support live migration
Virtual disk size; max of 64TB.
Block Size; min 1MB, max 256MB. 0 means auto-calculate based on image size.
VHDX format type, can be either 'dynamic' or 'fixed'. Default is 'dynamic'.
Force use of payload blocks of type 'ZERO'. Non-standard, but default.  Do not set to 'off' when using 'qemu-img convert' with subformat=dynamic.
File is too small, not a valid image
Invalid granularity, image may be corrupt
failed to write VMDK grain directory
failed to write VMDK backup grain directory
Could not read l1 table from extent '%s'
extent->entry_size == sizeof(uint32_t)
Could not read l1 backup table from extent '%s'
%10s %ld %10s "%511[^
"]" %ld
Cannot use relative paths with VMDK descriptor file '%s': 
No write support for seSparse images available
Could not read const header from file '%s'
Bad const header magic: 0x%016lx
Unsupported grain table size: %lu
Unsupported reserved bits: 0x%016lx 0x%016lx 0x%016lx 0x%016lx
Unsupported non-zero const header padding
Could not read volatile header from file '%s'
Bad volatile header magic: 0x%016lx
Image is dirty, Replaying journal not supported
Unsupported non-zero volatile header padding
Could not read header from file '%s'
VMDK version 3 must be read only
File truncated, expecting at least %ld bytes
The vmdk format used by node '%s' does not support live migration
compat6 cannot be enabled with hwversion set
Flat image can't have backing file
Flat image can't enable zeroed grain
Invalid backing file format: %s. Must be vmdk
List of extents contains unused extents
# Disk DescriptorFile
version=1
CID=%x
parentCID=%x
createType="%s"
# Extent description
# The Disk Data Base
#DDB
ddb.virtualHWVersion = "%s"
ddb.geometry.cylinders = "%ld"
ddb.geometry.heads = "%u"
ddb.geometry.sectors = "63"
ddb.adapterType = "%s"
ddb.toolsVersion = "%s"
backing_file must be a vmdk image
Image size must be a multiple of 512 bytes
extent->entry_size == sizeof(uint64_t)
skip_end_bytes <= cluster_bytes
ERROR: could not find extent for sector %ld
ERROR: could not get cluster_offset for sector %ld
ERROR: could not get extent file length for sector %ld
ERROR: cluster offset for sector %ld points after EOF
Wrong offset: offset=0x%lx total_sectors=0x%lx
Could not write to allocated cluster for streamOptimized
Virtual adapter type, can be one of ide (default), lsilogic, buslogic or legacyESX
VMDK flat extent format, can be one of {monolithicSparse (default) | monolithicFlat | twoGbMaxExtentSparse | twoGbMaxExtentFlat | streamOptimized} 
Enable efficient zero writes using the zeroed-grain GTE feature
Disk size is too large, max size is 2040 GiB
opts->driver == BLOCKDEV_DRIVER_VPC
The requested image size cannot be represented in CHS geometry
Try size=%llu or force-size=on (the latter makes the image incompatible with Virtual PC)
Unable to create or write VHD header
create_options->driver == BLOCKDEV_DRIVER_VPC
s->pagetable[index] == 0xFFFFFFFF
Invalid size calculation mode: '%s'
File too small for a VHD header
Error reading dynamic VHD header
Max Table Entries too large (%d)
Unable to allocate memory for page table
block-vpc: free_data_block_offset points after the end of file. The image has been truncated.
The vpc format used by node '%s' does not support live migration
Type of virtual hard disk format. Supported formats are {dynamic (default) | fixed} 
Force disk size calculation to use the actual size specified, rather than using the nearest CHS-based calculation
Force disk size calculation to use either CHS geometry, or use the disk current_size specified in the VHD footer. {chs, current_size}
#!/bin/sh
#V2.0 Format
modprobe cloop file=$0 && mount -r -t iso9660 /dev/cloop $1
block_size %u must be a multiple of 512
block_size %u must be %u MB or less
n_blocks %u must be %zu or less
image requires too many offsets, try increasing block size
Could not allocate offsets table
offsets not monotonically increasing at index %u, image file is corrupt
invalid compressed block size at index %u, image file is corrupt
Could not allocate compressed_block
Could not allocate uncompressed_block
Could not allocate memory for catalog
Extent size must be at least 512
Extent size %u is not a power of two
Catalog size is too small for this disk size
File name string must start with 'fat:'
mapping->begin<=cluster_num && mapping->end>cluster_num
offset/array->item_size < array->next
!s->current_mapping || s->current_fd || (s->current_mapping->mode & MODE_DIRECTORY)
((s->cluster-(unsigned char*)s->directory.pointer)%s->cluster_size)==0
(char*)s->cluster+s->cluster_size <= s->directory.pointer+s->directory.next*s->directory.item_size
mapping->begin == first_cluster
(offset % array->item_size) == 0
mapping == array_get(&(s->mapping), s->mapping.next - 1) || mapping[1].begin >= c
(offset % s->cluster_size) == 0
Could not open %s... (%s, %d)
(size - offset == 0 && fat_eof(s, c)) || (size > offset && c >=2 && !fat_eof(s, c))
mapping->info.dir.first_dir_index < s->directory.next
mapping->mode & MODE_DIRECTORY
dir_index == 0 || is_directory(direntry)
!memcmp(first_direntry->name, s->volume_label, 11)
vvfat block driver requires a 'dir' option
vvfat label cannot be longer than 11 bytes
FAT32 has not been tested. You are welcome to do so!
Valid FAT types are only 12, 16 and 32
Unable to set VVFAT to 'rw' when drive is read-only
Too many entries in root directory
vvfat: invalid UTF-8 name: %s
mapping->mode == MODE_UNDEFINED
Directory does not fit in FAT%d (capacity %.2f MB)
The vvfat (rw) format used by node '%s' does not support live migration
cluster %d used more than once
mapping->first_mapping_index == -1 || mapping->info.file.offset > 0
Tried to write to protected bootsector
Tried to write to write-protected file %s
tried to write to write-protected file
Error writing to qcow backend
commit->path || commit->action == ACTION_WRITEOUT
!strncmp(m->path, mapping->path, l2)
Fatal: error while committing (%d)
Host directory to map to the vvfat device
Create a floppy rather than a hard disk image
Use a volume label other than QEMU VVFAT
Failed to get file size while reading UDIF trailer
dmg file must be at least 512 bytes long
Failed while reading UDIF trailer
Could not locate UDIF trailer in dmg file
dmg-bzip2 module is missing, accessing bzip2 compressed blocks will result in I/O errors
dmg-lzfse module is missing, accessing lzfse compressed blocks will result in I/O errors
Image contains chunks of unknown type %x, accessing them will result in I/O errors
sector count %lu for chunk %u is larger than max (%u)
length %lu for chunk %u is larger than max (%u)
%d@%zu.%06zu:qed_alloc_l2_cache_entry l2_cache %p entry %p
qed_alloc_l2_cache_entry l2_cache %p entry %p
%d@%zu.%06zu:qed_unref_l2_cache_entry entry %p ref %d
qed_unref_l2_cache_entry entry %p ref %d
%d@%zu.%06zu:qed_find_l2_cache_entry l2_cache %p entry %p offset %lu ref %d
qed_find_l2_cache_entry l2_cache %p entry %p offset %lu ref %d
%d@%zu.%06zu:qed_write_table s %p offset %lu table %p index %u n %u
qed_write_table s %p offset %lu table %p index %u n %u
%d@%zu.%06zu:qed_write_table_cb s %p table %p flush %d ret %d
qed_write_table_cb s %p table %p flush %d ret %d
%d@%zu.%06zu:qed_read_table s %p offset %lu table %p
qed_read_table s %p offset %lu table %p
%d@%zu.%06zu:qed_read_table_cb s %p table %p ret %d
qed_read_table_cb s %p table %p ret %d
%d@%zu.%06zu:qed_cancel_need_check_timer s %p
qed_cancel_need_check_timer s %p
%d@%zu.%06zu:qed_start_need_check_timer s %p
qed_start_need_check_timer s %p
s->allocating_write_reqs_plugged
%d@%zu.%06zu:qed_aio_write_main s %p acb %p ret %d offset %lu len %zu
qed_aio_write_main s %p acb %p ret %d offset %lu len %zu
opts->driver == BLOCKDEV_DRIVER_QED
QED cluster size must be within range [%u, %u] and power of 2
QED table size must be within range [%u, %u] and power of 2
QED image size must be a non-zero multiple of cluster size and less than %lu bytes
create_options->driver == BLOCKDEV_DRIVER_QED
s->allocating_acb || s->allocating_write_reqs_plugged
%d@%zu.%06zu:qed_need_check_timer_cb s %p
!s->allocating_write_reqs_plugged
%d@%zu.%06zu:qed_aio_setup s %p acb %p sector_num %ld nb_sectors %d opaque %p flags 0x%x
qed_aio_setup s %p acb %p sector_num %ld nb_sectors %d opaque %p flags 0x%x
%d@%zu.%06zu:qed_aio_next_io s %p acb %p ret %d cur_pos %lu
qed_aio_next_io s %p acb %p ret %d cur_pos %lu
%d@%zu.%06zu:qed_aio_write_data s %p acb %p ret %d offset %lu len %zu
qed_aio_write_data s %p acb %p ret %d offset %lu len %zu
%d@%zu.%06zu:qed_aio_write_prefill s %p acb %p start %lu len %zu offset %lu
qed_aio_write_prefill s %p acb %p start %lu len %zu offset %lu
%d@%zu.%06zu:qed_aio_write_postfill s %p acb %p start %lu len %zu offset %lu
qed_aio_write_postfill s %p acb %p start %lu len %zu offset %lu
%d@%zu.%06zu:qed_aio_read_data s %p acb %p ret %d offset %lu len %zu
qed_aio_read_data s %p acb %p ret %d offset %lu len %zu
%d@%zu.%06zu:qed_aio_complete s %p acb %p ret %d
qed_aio_complete s %p acb %p ret %d
Shrinking images is currently not supported
QED backing filename offset is invalid
Failed to read backing filename
L1/L2 table size (in clusters)
%s space leaked at the end of the image %ld
QEMU_IS_ALIGNED(offset | bytes, BDRV_SECTOR_SIZE)
opts->driver == BLOCKDEV_DRIVER_PARALLELS
Image size is too large for this cluster size
Cluster size must be a multiple of 512 bytes
Failed to create Parallels image
idx < s->bat_size && idx + to_allocate <= s->bat_size
%s data_off field has incorrect value
%s duplicate offset in BAT entry %u
%s cluster %u is outside image
%s image was not closed correctly
Invalid image: Zero sectors per track
Invalid image: Too big cluster
Format Extension ignored in RW mode
The Parallels format used by node '%s' does not support live migration
Could not repair corrupted image
Preallocation size on image expansion
Preallocation mode on image expansion (allowed values: falloc, truncate)
Failed to read Format Extension cluster
Wrong parallels Format Extension magic: 0x%lx, expected: 0x%llx
Wrong checksum in Format Extension header. Format extension is corrupted.
Can not read feature header, as remaining bytes (%d) in Format Extension is less than Feature header size (%zu)
Flags for extension feature are unsupported
Feature data_size exceedes Format Extension cluster
Too small Bitmap Feature area in Parallels Format Extension: %zu bytes, expected at least %zu bytes
Bitmap size (in sectors) %ld differs from disk size in sectors %ld
Bitmaps feature corrupted: l1 table exceeds extension data_size
Bitmap table size %u does not correspond to bitmap size and cluster size. Expected %lu
Failed to read bitmap data cluster
!(bs->open_flags & BDRV_O_RDWR)
%d: ioctl BLKREPORTZONE at %ld failed %d
%d@%zu.%06zu:file_flush_fdatasync_failed errno %d
file_flush_fdatasync_failed errno %d
%d@%zu.%06zu:zbd_zone_report bs %p report %d zones starting at sector offset 0x%lx
zbd_zone_report bs %p report %d zones starting at sector offset 0x%lx
req->type == BDRV_TRACKED_WRITE
req->offset + req->bytes >= offset + bytes
Failed to get shared "%s" lock
Could not find working O_DIRECT alignment
%d@%zu.%06zu:file_copy_file_range bs %p src_fd %d offset %lu dst_fd %d offset %lu bytes %lu flags %d ret %ld
file_copy_file_range bs %p src_fd %d offset %lu dst_fd %d offset %lu bytes %lu flags %d ret %ld
Cannot use preallocation for shrinking files
Could not preallocate new data
Failed to seek to the old end of file
Could not write zeros for preallocation
Unsupported preallocation mode: %s
Failed to restore old file length: %s
options->driver == BLOCKDEV_DRIVER_FILE
Is another process using the image [%s]?
Failed to set extent size hint: %s
Unable to read chunk_sectors sysfs attribute
Read 0 from chunk_sectors sysfs attribute
Unable to read nr_zones sysfs attribute
Read 0 from nr_zones sysfs attribute
sector offset %ld is not aligned to zone size %ld
number of sectors %ld is not aligned to zone size %ld
zone mgmt operations are not allowed for conventional zones
%d@%zu.%06zu:zbd_zone_mgmt bs %p %s starts at sector offset 0x%lx over a range of 0x%lx sectors
zbd_zone_mgmt bs %p %s starts at sector offset 0x%lx over a range of 0x%lx sectors
Unable to use Linux AIO, falling back to thread pool: 
%d@%zu.%06zu:zbd_zone_append_complete bs %p returns append sector 0x%lx
zbd_zone_append_complete bs %p returns append sector 0x%lx
sector offset %ld is not aligned to zone size %d
len of IOVector[%d] %ld is not aligned to block size %ld
%d@%zu.%06zu:zbd_zone_append bs %p append at sector offset 0x%lx
zbd_zone_append bs %p append at sector offset 0x%lx
File lock requested but OFD locking syscall is unavailable, falling back to POSIX file locks
Due to the implementation, locks can be lost unexpectedly.
aio=native was specified, but it requires cache.direct=on, which was not specified.
aio=io_uring was specified, but is not supported in this build.
'%s' driver requires '%s' to be a regular file
'%s' driver requires '%s' to be either a character or block device
The driver supports zoned devices, and it requires cache.direct=on, which was not specified.
%d@%zu.%06zu:file_hdev_is_sg SG device found: type=%d, version=%d
file_hdev_is_sg SG device found: type=%d, version=%d
The file descriptor is not open
Preallocation mode '%s' unsupported for this non-regular file
Resizing this file is not supported
Your file system is misbehaving: fallocate(FALLOC_FL_PUNCH_HOLE) returned EINVAL. Please report this bug to your file system vendor.
(s->open_flags & O_ASYNC) == 0
Turn off copy-on-write (valid only on btrfs)
Preallocation mode (allowed values: off, falloc, full)
Extent size hint for the image file, 0 to disable
AIO max batch size (0 = auto handled by AIO backend, default: 0)
file locking mode (on/off/auto, default: auto)
id of persistent reservation manager object (default: none)
invalidate page cache during live migration (default: on)
check that page cache was dropped on live migration (default: off)
username for CHAP authentication to target
password for CHAP authentication to target
ID of the secret providing password for CHAP authentication to target
HeaderDigest setting. {CRC32C|CRC32C-NONE|NONE-CRC32C|NONE}
Initiator iqn name to use when connecting
Request timeout in seconds (default 0 = no timeout)
%d@%zu.%06zu:nvme_submit_command s %p q #%u cid %d
nvme_submit_command s %p q #%u cid %d
%d@%zu.%06zu:nvme_submit_command_raw %02x %02x %02x %02x %02x %02x %02x %02x
nvme_submit_command_raw %02x %02x %02x %02x %02x %02x %02x %02x
%d@%zu.%06zu:nvme_free_queue_pair index %u q %p cq %p sq %p
nvme_free_queue_pair index %u q %p cq %p sq %p
%d@%zu.%06zu:nvme_process_completion s %p q #%u inflight %d
nvme_process_completion s %p q #%u inflight %d
%d@%zu.%06zu:nvme_error cmd_specific %d sq_head %d sqid %d cid %d status 0x%x
nvme_error cmd_specific %d sq_head %d sqid %d cid %d status 0x%x
NVMe: Unexpected CID in completion queue: %u, should be within: 1..%u inclusively
%d@%zu.%06zu:nvme_complete_command s %p q #%u cid %d
nvme_complete_command s %p q #%u cid %d
%d@%zu.%06zu:nvme_poll_queue s %p q #%u
%d@%zu.%06zu:nvme_handle_event s %p
Invalid namespace '%s', positive number expected
%d@%zu.%06zu:nvme_create_queue_pair index %u q %p size %zu aioctx %p fd %d
nvme_create_queue_pair index %u q %p size %zu aioctx %p fd %d
QEMU_IS_ALIGNED(qiov->size, s->page_size)
qiov->size / s->page_size <= s->page_size / sizeof(uint64_t)
%d@%zu.%06zu:nvme_dma_flush_queue_wait s %p
nvme_dma_flush_queue_wait s %p
%d@%zu.%06zu:nvme_dma_map_flush s %p
%d@%zu.%06zu:nvme_cmd_map_qiov_iov s %p iov[%d] %p pages %d
nvme_cmd_map_qiov_iov s %p iov[%d] %p pages %d
entries <= s->page_size / sizeof(uint64_t)
%d@%zu.%06zu:nvme_cmd_map_qiov s %p cmd %p req %p qiov %p entries %d
nvme_cmd_map_qiov s %p cmd %p req %p qiov %p entries %d
%d@%zu.%06zu:nvme_cmd_map_qiov_pages s %p page[%d] 0x%lx
nvme_cmd_map_qiov_pages s %p page[%d] 0x%lx
s->blkshift >= BDRV_SECTOR_BITS && s->blkshift <= 12
%d@%zu.%06zu:nvme_kick s %p q #%u
%d@%zu.%06zu:nvme_free_req_queue_wait s %p q #%u
nvme_free_req_queue_wait s %p q #%u
%d@%zu.%06zu:nvme_prw_aligned s %p is_write %d offset 0x%lx bytes %ld flags %d niov %d
nvme_prw_aligned s %p is_write %d offset 0x%lx bytes %ld flags %d niov %d
%d@%zu.%06zu:nvme_rw_done s %p is_write %d offset 0x%lx bytes %ld ret %d
nvme_rw_done s %p is_write %d offset 0x%lx bytes %ld ret %d
QEMU_IS_ALIGNED(offset, s->page_size)
QEMU_IS_ALIGNED(bytes, s->page_size)
%d@%zu.%06zu:nvme_qiov_unaligned qiov %p n %d base %p size 0x%zx align 0x%x
nvme_qiov_unaligned qiov %p n %d base %p size 0x%zx align 0x%x
%d@%zu.%06zu:nvme_prw_buffered s %p offset 0x%lx bytes %ld niov %d is_write %d
nvme_prw_buffered s %p offset 0x%lx bytes %ld niov %d is_write %d
QEMU_IS_ALIGNED(bytes, 1UL << s->blkshift)
QEMU_IS_ALIGNED(offset, 1UL << s->blkshift)
(bytes >> s->blkshift) <= UINT32_MAX
%d@%zu.%06zu:nvme_dsm s %p offset 0x%lx bytes %ld
nvme_dsm s %p offset 0x%lx bytes %ld
%d@%zu.%06zu:nvme_dsm_done s %p offset 0x%lx bytes %ld ret %d
nvme_dsm_done s %p offset 0x%lx bytes %ld ret %d
((cdw12 + 1) << s->blkshift) == bytes
%d@%zu.%06zu:nvme_write_zeroes s %p offset 0x%lx bytes %ld flags %d
nvme_write_zeroes s %p offset 0x%lx bytes %ld flags %d
%d@%zu.%06zu:nvme_controller_capability_raw 0x%08lx
nvme_controller_capability_raw 0x%08lx
Maximum Queue Entries Supported
%d@%zu.%06zu:nvme_controller_capability %s: %lu
nvme_controller_capability %s: %lu
Device doesn't support NVMe command set
%d@%zu.%06zu:nvme_controller_spec_version Specification supported: %u.%u.%u
nvme_controller_spec_version Specification supported: %u.%u.%u
Timeout while waiting for device to reset (%ld ms)
Timeout while waiting for device to start (%ld ms)
Cannot allocate buffer for identify response
Namespaces with metadata are not yet supported
Namespace has unsupported block size (2^%d)
Failed to create CQ io queue [%u]
Failed to create SQ io queue [%u]
NVMe controller doesn't support write cache configuration
Failed to configure NVMe write cache
Backup job was cancelled unexpectedly
Block replication is not running
commit_job->aio_context == qemu_get_current_aio_context()
The primary side does not support option top-id
The option mode's value should be primary or secondary
QEMU_IS_ALIGNED(count, BDRV_SECTOR_SIZE)
Block replication is running or done
The parameter mode's value is invalid, needs %d, but got %d
Active disk doesn't have backing file
Hidden disk doesn't have backing file
The secondary disk doesn't have block backend
Active disk, hidden disk, secondary disk's length are not the same
active_disk->bs->drv && hidden_disk->bs->drv
Active disk or hidden disk doesn't support make_empty
Block device is in use by internal backup job
laiocb->co->ctx == laiocb->ctx->aio_context
%s: invalid AIO request type 0x%x.
failed to initialize event notifier
failed to create linux AIO context
%s: destroy AIO context %p failed
%d@%zu.%06zu:stream_one_iteration s %p offset %ld bytes %lu is_allocated %d
stream_one_iteration s %p offset %ld bytes %lu is_allocated %d
'%s' is not in the backing chain of '%s'
%d@%zu.%06zu:stream_start bs %p base %p s %p
stream_start bs %p base %p s %p
../block/monitor/bitmap-qmp-cmds.c
Granularity must be power of 2 and at least 512
%d@%zu.%06zu:curl_read_cb just reading %zu bytes
curl_read_cb just reading %zu bytes
%d@%zu.%06zu:curl_sock_cb sock action %d on fd %d
curl_sock_cb sock action %d on fd %d
curl: further errors suppressed
curl driver does not support writes
libcurl initialization failed with %d
HTTP_READAHEAD_SIZE %zd is not a multiple of 512
timeout parameter is too large or negative
curl driver cannot handle both cookie and cookie secret
curl block driver requires an 'url' option
%s curl driver cannot handle the URL '%s' (does not start with '%s://')
%d@%zu.%06zu:curl_open opening %s
curl library initialization failed.
Server didn't report file size.
Server does not support 'range' (byte ranges).
%d@%zu.%06zu:curl_open_size size = %lu
%d@%zu.%06zu:curl_timer_cb timer callback timeout_ms %ld
curl_timer_cb timer callback timeout_ms %ld
%d@%zu.%06zu:curl_setup_preadv reading %lu at %lu (%s)
curl_setup_preadv reading %lu at %lu (%s)
%d@%zu.%06zu:curl_close close
Pass the cookie or list of cookies with each request
ID of secret used as cookie passed with each request
ID of secret used as password for HTTP auth
ID of secret used as password for HTTP proxy auth
iSCSI: Failed to unmarshall readcapacity16 data.
iSCSI: Failed to unmarshall readcapacity10 data.
iSCSI: failed to send readcapacity10/16 command
iSCSI: the target returned an invalid block size of %d.
iscsilun->block_size >= BDRV_SECTOR_SIZE || bdrv_is_sg(bs)
iSCSI: failed to unmarshall inquiry datain blob
iSCSI: Inquiry command failed : %s
nb_sectors <= BDRV_REQUEST_MAX_SECTORS
Cannot open a write protected LUN as read-write
iSCSI: ioctl error CDB exceeds max size (%d > %d)
iSCSI: Failed to allocate task for scsi command. %s
iSCSI Busy/TaskSetFull/TimeOut (retry #%u in %u ms): %s
iSCSI SYNCHRONIZECACHE10 failed: %s
QEMU_IS_ALIGNED(offset | bytes, iscsilun->block_size)
iSCSI GET_LBA_STATUS failed at lba %lu: %s
Cannot resize non-disk iSCSI devices
Need all of transport, portal and target options
00000000-0000-0000-0000-000000000000
iSCSI: Failed to create iSCSI context.
iSCSI: Failed to set target name.
'password' and 'password-secret' properties are mutually exclusive
CHAP username specified but no password was given
iSCSI block driver 'password' option is deprecated, use 'password-secret' instead
Failed to set initiator username and password
iSCSI: Failed to set session type to normal.
Invalid header-digest setting : %s
iSCSI: Failed to connect to LUN : %s
iSCSI: Failed to send MODE_SENSE(6) command: %s
iSCSI: Failed MODE_SENSE(6), LUN assumed writable
iSCSI: Failed to unmarshall MODE_SENSE(6) data: %s
iSCSI misaligned request: iscsilun->block_size %u, offset %li, bytes %li
nb_sectors << BDRV_SECTOR_BITS <= bs->bl.max_transfer
iSCSI READ10/16 failed at lba %lu: %s
iSCSI: NOP timeout. Reconnecting...
iSCSI: failed to sent NOP-Out. Disabling NOP messages.
Failed to ioctl(SG_IO) to iSCSI lun. %s
bytes / iscsilun->block_size <= UINT32_MAX
iSCSI UNMAP failed at lba %lu: %s
iSCSI WRITE10/16 failed at lba %lu: %s
iSCSI WRITESAME10/16 failed at lba %lu: %s
%d@%zu.%06zu:iscsi_xcopy src_lun %p offset %lu dst_lun %p offset %lu bytes %lu ret %d
iscsi_xcopy src_lun %p offset %lu dst_lun %p offset %lu bytes %lu ret %d
%d@%zu.%06zu:ssh_getlength length=%li
%d@%zu.%06zu:sftp_error %s failed: %s (libssh error code: %d, sftp error code: %d)
sftp_error %s failed: %s (libssh error code: %d, sftp error code: %d)
%s: %s (libssh error code: %d, sftp error code: %d)
offset > 0 && offset > s->attrs->size
ssh driver does not support shrinking files
%s: %s (libssh error code: %d)
%d@%zu.%06zu:ssh_co_yield s->sock=%d rd_handler=%p wr_handler=%p
ssh_co_yield s->sock=%d rd_handler=%p wr_handler=%p
%d@%zu.%06zu:ssh_co_yield_back s->sock=%d - back
ssh_co_yield_back s->sock=%d - back
%d@%zu.%06zu:ssh_restart_coroutine co=%p
%d@%zu.%06zu:ssh_read offset=%li size=%zu
%d@%zu.%06zu:ssh_seek seeking to offset=%li
ssh_seek seeking to offset=%li
%d@%zu.%06zu:ssh_read_buf sftp_read buf=%p size=%zu (actual size=%zu)
ssh_read_buf sftp_read buf=%p size=%zu (actual size=%zu)
%d@%zu.%06zu:ssh_read_return sftp_read returned %zd (sftp error=%d)
ssh_read_return sftp_read returned %zd (sftp error=%d)
Cannot generate a base directory with host_key_check set
Cannot generate a base directory for this ssh node
Failed to parse SSH URI parameters '%s'
Unsupported parameter '%s' in URI
unknown host_key_check setting (%s)
libssh initialization failed, %d
ssh server %s does not support fsync
failed to read remote host key
failed reading the hash of the server SSH key
remote host %s key fingerprint '%s:%s' does not match host_key_check '%s:%s'
can't set TCP_NODELAY for the ssh server %s: %s
failed to initialize libssh session
failed to set the user in the libssh session
failed to set the host in the libssh session
failed to set the port in the libssh session
failed to disable the compression in the libssh session
failed to set the socket in the libssh session
failed to establish SSH session
%d@%zu.%06zu:ssh_server_status server status=%d
ssh_server_status server status=%d
%d@%zu.%06zu:ssh_check_host_key_knownhosts host key OK
ssh_check_host_key_knownhosts host key OK
host key (%s key with fingerprint %s) does not match the one in known_hosts; this may be a possible attack
host key does not match the one in known_hosts; this may be a possible attack
host key for this server not found, another type exists
no host key was found in known_hosts
error while checking for known server (%d)
failed to authenticate using none authentication
%d@%zu.%06zu:ssh_auth_methods auth methods=0x%x
ssh_auth_methods auth methods=0x%x
failed to authenticate using publickey authentication and the identities held by your ssh-agent
failed to authenticate using publickey authentication
failed to initialize sftp handle
%d@%zu.%06zu:ssh_connect_to_ssh opening file %s flags=0x%x creat_mode=0%o
ssh_connect_to_ssh opening file %s flags=0x%x creat_mode=0%o
failed to open remote file '%s'
failed to read file attributes
options->driver == BLOCKDEV_DRIVER_SSH
%d@%zu.%06zu:ssh_co_create_opts total_size=%lu
ssh_co_create_opts total_size=%lu
%d@%zu.%06zu:ssh_write offset=%li size=%zu
ssh_write offset=%li size=%zu
%d@%zu.%06zu:ssh_write_buf sftp_write buf=%p size=%zu (actual size=%zu)
ssh_write_buf sftp_write buf=%p size=%zu (actual size=%zu)
%d@%zu.%06zu:ssh_write_return sftp_write returned %zd (sftp error=%d)
ssh_write_return sftp_write returned %zd (sftp error=%d)
Defines how and what to check the host key against
/home/virus/AMD/AMD/block/block-gen.h
Replay: get msgfd is not supported for serial devices yet
chardev '%s' is already in use
chardev: file: no filename given
chardev: mux: no chardev given
mux: base chardev %s not found
too many uses of multiplexed chardev '%s' (maximum is 4)
d->mux_bitset & (1ul << focus)
Escape-Char set to Ascii: 0x%02x
% s    save disk data back to file (if -snapshot)
% t    toggle console timestamps
% b    send break (magic sysrq)
% c    switch between console and monitor
hub: 'chardevs' list is not defined
hub: chardev can't be found by id '%s'
hub: multiplexers and hub devices can't be stacked, check chardev '%s', chardev should not be a hub device or have 'mux=on' enabled
hub: too many uses of chardevs '%s' (maximum is 4)
chardev: pipe: no device path given
size of ringbuf chardev must be power of two
size must be greater than zero
/home/virus/AMD/AMD/include/chardev/char-fd.h
chardev: serial/tty: no device path given
None or one of 'path', 'fd' or 'host' option required.
chardev: socket: no port given
'delay' and 'nodelay' are mutually exclusive
/home/virus/AMD/AMD/include/chardev/char-socket.h
s->state == TCP_CHARDEV_STATE_CONNECTING
s->state == TCP_CHARDEV_STATE_DISCONNECTED
%d@%zu.%06zu:chr_socket_disconnect chardev socket disconnect %p (%s)
chr_socket_disconnect chardev socket disconnect %p (%s)
%d@%zu.%06zu:chr_socket_poll_err chardev socket poll error %p (%s)
chr_socket_poll_err chardev socket poll error %p (%s)
%d@%zu.%06zu:chr_socket_recv_err chardev socket recv error %p (%s): %s
chr_socket_recv_err chardev socket recv error %p (%s): %s
%d@%zu.%06zu:chr_socket_recv_eof chardev socket recv end-of-file %p (%s)
chr_socket_recv_eof chardev socket recv end-of-file %p (%s)
%d@%zu.%06zu:chr_socket_hangup chardev socket hangup %p (%s)
chr_socket_hangup chardev socket hangup %p (%s)
%d@%zu.%06zu:chr_socket_ws_handshake_err chardev socket websock handshake error %p (%s): %s
chr_socket_ws_handshake_err chardev socket websock handshake error %p (%s): %s
%d@%zu.%06zu:chr_socket_tls_handshake_err chardev socket TLS handshake error %p (%s): %s
chr_socket_tls_handshake_err chardev socket TLS handshake error %p (%s): %s
%d@%zu.%06zu:chr_socket_write_err chardev socket write error %p (%s): %s
chr_socket_write_err chardev socket write error %p (%s): %s
%d@%zu.%06zu:chr_socket_tls_init_err chardev socket TLS init error %p (%s): %s
chr_socket_tls_init_err chardev socket TLS init error %p (%s): %s
Unable to connect character device %s: 
QEMU waiting for connection on: %s
'%s' option is incompatible with waiting for connection completion
Unexpected 'connecting' state without connect task while waiting for connection completion
'reconnect' option is incompatible with 'fd' address type
'tls_creds' option is incompatible with 'fd' address type as client
'tls_creds' option is incompatible with 'unix' address type
'tls_creds' option is incompatible with 'vsock' address type
'tls_authz' option requires 'tls_creds' option
'reconnect' option is incompatible with socket in server listen mode
Websocket client is not implemented
'wait' option is incompatible with socket in client connect mode
cannot use stdio with -daemonize
cannot use stdio by multiple character devices
chardev: udp: remote port not specified
'%s' is not a valid char driver name
g_str_has_prefix(object_class_get_name(klass), "chardev-")
Replay: ioctl is not supported for serial devices yet
g_str_has_prefix(typename, "chardev-")
qemu_chr_has_feature(s, QEMU_CHAR_FEATURE_GCONTEXT) || !context
mon: isn't supported in this context
'%s' is not a valid char driver
Available chardev backend types: %s
Chardev with id '%s' already exists
For mux or hub device hotswap is not supported yet
Chardev '%s' cannot be changed in record/replay mode
Chardev user does not support chardev hotswap
Chardev '%s' cannot be unplugged in record/replay mode
!"Failed to set FD nonblocking"
chardev: parallel: no device path given
char device redirected to %s (label %s)
%d@%zu.%06zu:monitor_protocol_event_emit event=%d data=%p
monitor_protocol_event_emit event=%d data=%p
%d@%zu.%06zu:monitor_protocol_event_handler event=%d data=%p
monitor_protocol_event_handler event=%d data=%p
%d@%zu.%06zu:monitor_protocol_event_queue event=%d data=%p rate=%ld
monitor_protocol_event_queue event=%d data=%p rate=%ld
!evstate || timer_pending(evstate->timer)
%d@%zu.%06zu:monitor_suspend mon %p: %d
'pretty' is not compatible with HMP monitors
%d@%zu.%06zu:monitor_qmp_respond mon %p resp: %s
monitor_qmp_respond mon %p resp: %s
Expecting capabilities negotiation with 'qmp_capabilities'
%d@%zu.%06zu:handle_qmp_command mon %p req: %s
handle_qmp_command mon %p req: %s
%d@%zu.%06zu:monitor_qmp_cmd_out_of_band %s
monitor_qmp_cmd_out_of_band %s
monitor_qmp_in_band_enqueue %p mon %p len %u
%d@%zu.%06zu:monitor_qmp_in_band_enqueue %p mon %p len %u
mon->qmp_requests->length < QMP_REQ_QUEUE_LEN_MAX
{'QMP': {'version': %p, 'capabilities': %p}}
%d@%zu.%06zu:monitor_qmp_in_band_dequeue %p len %u
monitor_qmp_in_band_dequeue %p len %u
%d@%zu.%06zu:monitor_qmp_cmd_in_band %s
%d@%zu.%06zu:monitor_qmp_err_in_band %s
qatomic_read(&qmp_dispatcher_co_busy) == true
Capabilities negotiation is already complete, command ignored
 Please set the environment variable: export V_DORA_LICENSE=your_license_key
 Invalid OR Expired License
 Please Contact Support To Renew.
 The license is Valid - Start up HVM for V-DORA QEMU
%d@%zu.%06zu:qmp_enter_query_pr_managers %s
qmp_enter_query_pr_managers %s
%d@%zu.%06zu:qmp_exit_query_pr_managers %s %d
qmp_exit_query_pr_managers %s %d
%d@%zu.%06zu:qmp_enter_eject %s
%d@%zu.%06zu:qmp_exit_eject %s %d
%d@%zu.%06zu:qmp_enter_blockdev_open_tray %s
qmp_enter_blockdev_open_tray %s
%d@%zu.%06zu:qmp_exit_blockdev_open_tray %s %d
qmp_exit_blockdev_open_tray %s %d
%d@%zu.%06zu:qmp_enter_blockdev_close_tray %s
qmp_enter_blockdev_close_tray %s
%d@%zu.%06zu:qmp_exit_blockdev_close_tray %s %d
qmp_exit_blockdev_close_tray %s %d
%d@%zu.%06zu:qmp_enter_blockdev_remove_medium %s
qmp_enter_blockdev_remove_medium %s
%d@%zu.%06zu:qmp_exit_blockdev_remove_medium %s %d
qmp_exit_blockdev_remove_medium %s %d
%d@%zu.%06zu:qmp_enter_blockdev_insert_medium %s
qmp_enter_blockdev_insert_medium %s
%d@%zu.%06zu:qmp_exit_blockdev_insert_medium %s %d
qmp_exit_blockdev_insert_medium %s %d
%d@%zu.%06zu:qmp_enter_blockdev_change_medium %s
qmp_enter_blockdev_change_medium %s
%d@%zu.%06zu:qmp_exit_blockdev_change_medium %s %d
qmp_exit_blockdev_change_medium %s %d
%d@%zu.%06zu:qmp_enter_block_set_io_throttle %s
qmp_enter_block_set_io_throttle %s
%d@%zu.%06zu:qmp_exit_block_set_io_throttle %s %d
qmp_exit_block_set_io_throttle %s %d
%d@%zu.%06zu:qmp_enter_block_latency_histogram_set %s
qmp_enter_block_latency_histogram_set %s
%d@%zu.%06zu:qmp_exit_block_latency_histogram_set %s %d
qmp_exit_block_latency_histogram_set %s %d
Invalid parameter type for '%s', expected: BlockDirtyBitmapOrStr
Invalid parameter type for '%s', expected: Qcow2OverlapChecks
Invalid parameter type for '%s', expected: BlockdevRefOrNull
Invalid parameter type for '%s', expected: BlockdevRef
%d@%zu.%06zu:qmp_enter_query_block %s
%d@%zu.%06zu:qmp_exit_query_block %s %d
%d@%zu.%06zu:qmp_enter_query_blockstats %s
qmp_enter_query_blockstats %s
%d@%zu.%06zu:qmp_exit_query_blockstats %s %d
qmp_exit_query_blockstats %s %d
%d@%zu.%06zu:qmp_enter_query_block_jobs %s
qmp_enter_query_block_jobs %s
%d@%zu.%06zu:qmp_exit_query_block_jobs %s %d
qmp_exit_query_block_jobs %s %d
%d@%zu.%06zu:qmp_enter_block_resize %s
%d@%zu.%06zu:qmp_exit_block_resize %s %d
%d@%zu.%06zu:qmp_enter_blockdev_snapshot_sync %s
qmp_enter_blockdev_snapshot_sync %s
%d@%zu.%06zu:qmp_exit_blockdev_snapshot_sync %s %d
qmp_exit_blockdev_snapshot_sync %s %d
%d@%zu.%06zu:qmp_enter_blockdev_snapshot %s
qmp_enter_blockdev_snapshot %s
%d@%zu.%06zu:qmp_exit_blockdev_snapshot %s %d
qmp_exit_blockdev_snapshot %s %d
%d@%zu.%06zu:qmp_enter_change_backing_file %s
qmp_enter_change_backing_file %s
%d@%zu.%06zu:qmp_exit_change_backing_file %s %d
qmp_exit_change_backing_file %s %d
%d@%zu.%06zu:qmp_enter_block_commit %s
%d@%zu.%06zu:qmp_exit_block_commit %s %d
%d@%zu.%06zu:qmp_enter_drive_backup %s
%d@%zu.%06zu:qmp_exit_drive_backup %s %d
%d@%zu.%06zu:qmp_enter_blockdev_backup %s
%d@%zu.%06zu:qmp_exit_blockdev_backup %s %d
qmp_exit_blockdev_backup %s %d
%d@%zu.%06zu:qmp_enter_query_named_block_nodes %s
qmp_enter_query_named_block_nodes %s
%d@%zu.%06zu:qmp_exit_query_named_block_nodes %s %d
qmp_exit_query_named_block_nodes %s %d
%d@%zu.%06zu:qmp_enter_x_debug_query_block_graph %s
qmp_enter_x_debug_query_block_graph %s
%d@%zu.%06zu:qmp_exit_x_debug_query_block_graph %s %d
qmp_exit_x_debug_query_block_graph %s %d
%d@%zu.%06zu:qmp_enter_drive_mirror %s
%d@%zu.%06zu:qmp_exit_drive_mirror %s %d
%d@%zu.%06zu:qmp_enter_block_dirty_bitmap_add %s
qmp_enter_block_dirty_bitmap_add %s
%d@%zu.%06zu:qmp_exit_block_dirty_bitmap_add %s %d
qmp_exit_block_dirty_bitmap_add %s %d
%d@%zu.%06zu:qmp_enter_block_dirty_bitmap_remove %s
qmp_enter_block_dirty_bitmap_remove %s
%d@%zu.%06zu:qmp_exit_block_dirty_bitmap_remove %s %d
qmp_exit_block_dirty_bitmap_remove %s %d
%d@%zu.%06zu:qmp_enter_block_dirty_bitmap_clear %s
qmp_enter_block_dirty_bitmap_clear %s
%d@%zu.%06zu:qmp_exit_block_dirty_bitmap_clear %s %d
qmp_exit_block_dirty_bitmap_clear %s %d
%d@%zu.%06zu:qmp_enter_block_dirty_bitmap_enable %s
qmp_enter_block_dirty_bitmap_enable %s
%d@%zu.%06zu:qmp_exit_block_dirty_bitmap_enable %s %d
qmp_exit_block_dirty_bitmap_enable %s %d
%d@%zu.%06zu:qmp_enter_block_dirty_bitmap_disable %s
qmp_enter_block_dirty_bitmap_disable %s
%d@%zu.%06zu:qmp_exit_block_dirty_bitmap_disable %s %d
qmp_exit_block_dirty_bitmap_disable %s %d
%d@%zu.%06zu:qmp_enter_block_dirty_bitmap_merge %s
qmp_enter_block_dirty_bitmap_merge %s
%d@%zu.%06zu:qmp_exit_block_dirty_bitmap_merge %s %d
qmp_exit_block_dirty_bitmap_merge %s %d
%d@%zu.%06zu:qmp_enter_x_debug_block_dirty_bitmap_sha256 %s
qmp_enter_x_debug_block_dirty_bitmap_sha256 %s
%d@%zu.%06zu:qmp_exit_x_debug_block_dirty_bitmap_sha256 %s %d
qmp_exit_x_debug_block_dirty_bitmap_sha256 %s %d
%d@%zu.%06zu:qmp_enter_blockdev_mirror %s
%d@%zu.%06zu:qmp_exit_blockdev_mirror %s %d
qmp_exit_blockdev_mirror %s %d
%d@%zu.%06zu:qmp_enter_block_stream %s
%d@%zu.%06zu:qmp_exit_block_stream %s %d
%d@%zu.%06zu:qmp_enter_block_job_set_speed %s
qmp_enter_block_job_set_speed %s
%d@%zu.%06zu:qmp_exit_block_job_set_speed %s %d
qmp_exit_block_job_set_speed %s %d
%d@%zu.%06zu:qmp_enter_block_job_cancel %s
qmp_enter_block_job_cancel %s
%d@%zu.%06zu:qmp_exit_block_job_cancel %s %d
qmp_exit_block_job_cancel %s %d
%d@%zu.%06zu:qmp_enter_block_job_pause %s
%d@%zu.%06zu:qmp_exit_block_job_pause %s %d
qmp_exit_block_job_pause %s %d
%d@%zu.%06zu:qmp_enter_block_job_resume %s
qmp_enter_block_job_resume %s
%d@%zu.%06zu:qmp_exit_block_job_resume %s %d
qmp_exit_block_job_resume %s %d
%d@%zu.%06zu:qmp_enter_block_job_complete %s
qmp_enter_block_job_complete %s
%d@%zu.%06zu:qmp_exit_block_job_complete %s %d
qmp_exit_block_job_complete %s %d
%d@%zu.%06zu:qmp_enter_block_job_dismiss %s
qmp_enter_block_job_dismiss %s
%d@%zu.%06zu:qmp_exit_block_job_dismiss %s %d
qmp_exit_block_job_dismiss %s %d
%d@%zu.%06zu:qmp_enter_block_job_finalize %s
qmp_enter_block_job_finalize %s
%d@%zu.%06zu:qmp_exit_block_job_finalize %s %d
qmp_exit_block_job_finalize %s %d
%d@%zu.%06zu:qmp_enter_block_job_change %s
qmp_enter_block_job_change %s
%d@%zu.%06zu:qmp_exit_block_job_change %s %d
qmp_exit_block_job_change %s %d
%d@%zu.%06zu:qmp_enter_blockdev_add %s
%d@%zu.%06zu:qmp_exit_blockdev_add %s %d
%d@%zu.%06zu:qmp_enter_blockdev_reopen %s
%d@%zu.%06zu:qmp_exit_blockdev_reopen %s %d
qmp_exit_blockdev_reopen %s %d
%d@%zu.%06zu:qmp_enter_blockdev_del %s
%d@%zu.%06zu:qmp_exit_blockdev_del %s %d
%d@%zu.%06zu:qmp_enter_blockdev_set_active %s
qmp_enter_blockdev_set_active %s
%d@%zu.%06zu:qmp_exit_blockdev_set_active %s %d
qmp_exit_blockdev_set_active %s %d
%d@%zu.%06zu:qmp_enter_blockdev_create %s
%d@%zu.%06zu:qmp_exit_blockdev_create %s %d
qmp_exit_blockdev_create %s %d
%d@%zu.%06zu:qmp_enter_x_blockdev_amend %s
qmp_enter_x_blockdev_amend %s
%d@%zu.%06zu:qmp_exit_x_blockdev_amend %s %d
qmp_exit_x_blockdev_amend %s %d
%d@%zu.%06zu:qmp_enter_block_set_write_threshold %s
qmp_enter_block_set_write_threshold %s
%d@%zu.%06zu:qmp_exit_block_set_write_threshold %s %d
qmp_exit_block_set_write_threshold %s %d
%d@%zu.%06zu:qmp_enter_x_blockdev_change %s
qmp_enter_x_blockdev_change %s
%d@%zu.%06zu:qmp_exit_x_blockdev_change %s %d
qmp_exit_x_blockdev_change %s %d
%d@%zu.%06zu:qmp_enter_x_blockdev_set_iothread %s
qmp_enter_x_blockdev_set_iothread %s
%d@%zu.%06zu:qmp_exit_x_blockdev_set_iothread %s %d
qmp_exit_x_blockdev_set_iothread %s %d
%d@%zu.%06zu:qmp_enter_blockdev_snapshot_internal_sync %s
qmp_enter_blockdev_snapshot_internal_sync %s
%d@%zu.%06zu:qmp_exit_blockdev_snapshot_internal_sync %s %d
qmp_exit_blockdev_snapshot_internal_sync %s %d
%d@%zu.%06zu:qmp_enter_blockdev_snapshot_delete_internal_sync %s
qmp_enter_blockdev_snapshot_delete_internal_sync %s
%d@%zu.%06zu:qmp_exit_blockdev_snapshot_delete_internal_sync %s %d
qmp_exit_blockdev_snapshot_delete_internal_sync %s %d
qapi/qapi-visit-block-export.c
%d@%zu.%06zu:qmp_enter_nbd_server_start %s
qmp_enter_nbd_server_start %s
%d@%zu.%06zu:qmp_exit_nbd_server_start %s %d
qmp_exit_nbd_server_start %s %d
%d@%zu.%06zu:qmp_enter_nbd_server_add %s
%d@%zu.%06zu:qmp_exit_nbd_server_add %s %d
qmp_exit_nbd_server_add %s %d
%d@%zu.%06zu:qmp_enter_nbd_server_remove %s
qmp_enter_nbd_server_remove %s
%d@%zu.%06zu:qmp_exit_nbd_server_remove %s %d
qmp_exit_nbd_server_remove %s %d
%d@%zu.%06zu:qmp_enter_nbd_server_stop %s
%d@%zu.%06zu:qmp_exit_nbd_server_stop %s %d
qmp_exit_nbd_server_stop %s %d
%d@%zu.%06zu:qmp_enter_block_export_add %s
qmp_enter_block_export_add %s
%d@%zu.%06zu:qmp_exit_block_export_add %s %d
qmp_exit_block_export_add %s %d
%d@%zu.%06zu:qmp_enter_block_export_del %s
qmp_enter_block_export_del %s
%d@%zu.%06zu:qmp_exit_block_export_del %s %d
qmp_exit_block_export_del %s %d
%d@%zu.%06zu:qmp_enter_query_block_exports %s
qmp_enter_query_block_exports %s
%d@%zu.%06zu:qmp_exit_query_block_exports %s %d
qmp_exit_query_block_exports %s %d
%d@%zu.%06zu:qmp_enter_query_chardev %s
%d@%zu.%06zu:qmp_exit_query_chardev %s %d
%d@%zu.%06zu:qmp_enter_query_chardev_backends %s
qmp_enter_query_chardev_backends %s
%d@%zu.%06zu:qmp_exit_query_chardev_backends %s %d
qmp_exit_query_chardev_backends %s %d
%d@%zu.%06zu:qmp_enter_ringbuf_write %s
%d@%zu.%06zu:qmp_exit_ringbuf_write %s %d
%d@%zu.%06zu:qmp_enter_ringbuf_read %s
%d@%zu.%06zu:qmp_exit_ringbuf_read %s %d
%d@%zu.%06zu:qmp_enter_chardev_add %s
%d@%zu.%06zu:qmp_exit_chardev_add %s %d
%d@%zu.%06zu:qmp_enter_chardev_change %s
%d@%zu.%06zu:qmp_exit_chardev_change %s %d
qmp_exit_chardev_change %s %d
%d@%zu.%06zu:qmp_enter_chardev_remove %s
%d@%zu.%06zu:qmp_exit_chardev_remove %s %d
qmp_exit_chardev_remove %s %d
%d@%zu.%06zu:qmp_enter_chardev_send_break %s
qmp_enter_chardev_send_break %s
%d@%zu.%06zu:qmp_exit_chardev_send_break %s %d
qmp_exit_chardev_send_break %s %d
Invalid parameter type for '%s', expected: StrOrNull
%d@%zu.%06zu:qmp_enter_qmp_capabilities %s
qmp_enter_qmp_capabilities %s
%d@%zu.%06zu:qmp_exit_qmp_capabilities %s %d
qmp_exit_qmp_capabilities %s %d
%d@%zu.%06zu:qmp_enter_query_version %s
%d@%zu.%06zu:qmp_exit_query_version %s %d
%d@%zu.%06zu:qmp_enter_query_commands %s
%d@%zu.%06zu:qmp_exit_query_commands %s %d
qmp_exit_query_commands %s %d
%d@%zu.%06zu:qmp_enter_quit %s
%d@%zu.%06zu:qmp_exit_quit %s %d
%d@%zu.%06zu:qmp_enter_cxl_inject_general_media_event %s
qmp_enter_cxl_inject_general_media_event %s
%d@%zu.%06zu:qmp_exit_cxl_inject_general_media_event %s %d
qmp_exit_cxl_inject_general_media_event %s %d
%d@%zu.%06zu:qmp_enter_cxl_inject_dram_event %s
qmp_enter_cxl_inject_dram_event %s
%d@%zu.%06zu:qmp_exit_cxl_inject_dram_event %s %d
qmp_exit_cxl_inject_dram_event %s %d
%d@%zu.%06zu:qmp_enter_cxl_inject_memory_module_event %s
qmp_enter_cxl_inject_memory_module_event %s
%d@%zu.%06zu:qmp_exit_cxl_inject_memory_module_event %s %d
qmp_exit_cxl_inject_memory_module_event %s %d
%d@%zu.%06zu:qmp_enter_cxl_inject_poison %s
qmp_enter_cxl_inject_poison %s
%d@%zu.%06zu:qmp_exit_cxl_inject_poison %s %d
qmp_exit_cxl_inject_poison %s %d
%d@%zu.%06zu:qmp_enter_cxl_inject_uncorrectable_errors %s
qmp_enter_cxl_inject_uncorrectable_errors %s
%d@%zu.%06zu:qmp_exit_cxl_inject_uncorrectable_errors %s %d
qmp_exit_cxl_inject_uncorrectable_errors %s %d
%d@%zu.%06zu:qmp_enter_cxl_inject_correctable_error %s
qmp_enter_cxl_inject_correctable_error %s
%d@%zu.%06zu:qmp_exit_cxl_inject_correctable_error %s %d
qmp_exit_cxl_inject_correctable_error %s %d
%d@%zu.%06zu:qmp_enter_cxl_add_dynamic_capacity %s
qmp_enter_cxl_add_dynamic_capacity %s
%d@%zu.%06zu:qmp_exit_cxl_add_dynamic_capacity %s %d
qmp_exit_cxl_add_dynamic_capacity %s %d
%d@%zu.%06zu:qmp_enter_cxl_release_dynamic_capacity %s
qmp_enter_cxl_release_dynamic_capacity %s
%d@%zu.%06zu:qmp_exit_cxl_release_dynamic_capacity %s %d
qmp_exit_cxl_release_dynamic_capacity %s %d
%d@%zu.%06zu:qmp_enter_dump_guest_memory %s
qmp_enter_dump_guest_memory %s
%d@%zu.%06zu:qmp_exit_dump_guest_memory %s %d
qmp_exit_dump_guest_memory %s %d
%d@%zu.%06zu:qmp_enter_query_dump %s
%d@%zu.%06zu:qmp_exit_query_dump %s %d
%d@%zu.%06zu:qmp_enter_query_dump_guest_memory_capability %s
qmp_enter_query_dump_guest_memory_capability %s
%d@%zu.%06zu:qmp_exit_query_dump_guest_memory_capability %s %d
qmp_exit_query_dump_guest_memory_capability %s %d
%d@%zu.%06zu:qmp_enter_query_qmp_schema %s
qmp_enter_query_qmp_schema %s
%d@%zu.%06zu:qmp_exit_query_qmp_schema %s %d
qmp_exit_query_qmp_schema %s %d
%d@%zu.%06zu:qmp_enter_job_pause %s
%d@%zu.%06zu:qmp_exit_job_pause %s %d
%d@%zu.%06zu:qmp_enter_job_resume %s
%d@%zu.%06zu:qmp_exit_job_resume %s %d
%d@%zu.%06zu:qmp_enter_job_cancel %s
%d@%zu.%06zu:qmp_exit_job_cancel %s %d
%d@%zu.%06zu:qmp_enter_job_complete %s
%d@%zu.%06zu:qmp_exit_job_complete %s %d
%d@%zu.%06zu:qmp_enter_job_dismiss %s
%d@%zu.%06zu:qmp_exit_job_dismiss %s %d
%d@%zu.%06zu:qmp_enter_job_finalize %s
%d@%zu.%06zu:qmp_exit_job_finalize %s %d
%d@%zu.%06zu:qmp_enter_query_jobs %s
%d@%zu.%06zu:qmp_exit_query_jobs %s %d
qapi/qapi-visit-machine-common.c
%d@%zu.%06zu:qmp_enter_query_cpus_fast %s
%d@%zu.%06zu:qmp_exit_query_cpus_fast %s %d
qmp_exit_query_cpus_fast %s %d
%d@%zu.%06zu:qmp_enter_query_machines %s
%d@%zu.%06zu:qmp_exit_query_machines %s %d
qmp_exit_query_machines %s %d
%d@%zu.%06zu:qmp_enter_query_current_machine %s
qmp_enter_query_current_machine %s
%d@%zu.%06zu:qmp_exit_query_current_machine %s %d
qmp_exit_query_current_machine %s %d
%d@%zu.%06zu:qmp_enter_query_target %s
%d@%zu.%06zu:qmp_exit_query_target %s %d
%d@%zu.%06zu:qmp_enter_query_uuid %s
%d@%zu.%06zu:qmp_exit_query_uuid %s %d
%d@%zu.%06zu:qmp_enter_query_vm_generation_id %s
qmp_enter_query_vm_generation_id %s
%d@%zu.%06zu:qmp_exit_query_vm_generation_id %s %d
qmp_exit_query_vm_generation_id %s %d
%d@%zu.%06zu:qmp_enter_system_reset %s
%d@%zu.%06zu:qmp_exit_system_reset %s %d
%d@%zu.%06zu:qmp_enter_system_powerdown %s
qmp_enter_system_powerdown %s
%d@%zu.%06zu:qmp_exit_system_powerdown %s %d
qmp_exit_system_powerdown %s %d
%d@%zu.%06zu:qmp_enter_system_wakeup %s
%d@%zu.%06zu:qmp_exit_system_wakeup %s %d
%d@%zu.%06zu:qmp_enter_inject_nmi %s
%d@%zu.%06zu:qmp_exit_inject_nmi %s %d
%d@%zu.%06zu:qmp_enter_query_kvm %s
%d@%zu.%06zu:qmp_exit_query_kvm %s %d
%d@%zu.%06zu:qmp_enter_memsave %s
%d@%zu.%06zu:qmp_exit_memsave %s %d
%d@%zu.%06zu:qmp_enter_pmemsave %s
%d@%zu.%06zu:qmp_exit_pmemsave %s %d
%d@%zu.%06zu:qmp_enter_query_memdev %s
%d@%zu.%06zu:qmp_exit_query_memdev %s %d
%d@%zu.%06zu:qmp_enter_query_hotpluggable_cpus %s
qmp_enter_query_hotpluggable_cpus %s
%d@%zu.%06zu:qmp_exit_query_hotpluggable_cpus %s %d
qmp_exit_query_hotpluggable_cpus %s %d
%d@%zu.%06zu:qmp_enter_set_numa_node %s
%d@%zu.%06zu:qmp_exit_set_numa_node %s %d
%d@%zu.%06zu:qmp_enter_balloon %s
%d@%zu.%06zu:qmp_exit_balloon %s %d
%d@%zu.%06zu:qmp_enter_query_balloon %s
%d@%zu.%06zu:qmp_exit_query_balloon %s %d
%d@%zu.%06zu:qmp_enter_query_hv_balloon_status_report %s
qmp_enter_query_hv_balloon_status_report %s
%d@%zu.%06zu:qmp_exit_query_hv_balloon_status_report %s %d
qmp_exit_query_hv_balloon_status_report %s %d
%d@%zu.%06zu:qmp_enter_query_memory_size_summary %s
qmp_enter_query_memory_size_summary %s
%d@%zu.%06zu:qmp_exit_query_memory_size_summary %s %d
qmp_exit_query_memory_size_summary %s %d
%d@%zu.%06zu:qmp_enter_query_memory_devices %s
qmp_enter_query_memory_devices %s
%d@%zu.%06zu:qmp_exit_query_memory_devices %s %d
qmp_exit_query_memory_devices %s %d
%d@%zu.%06zu:qmp_enter_x_query_irq %s
%d@%zu.%06zu:qmp_exit_x_query_irq %s %d
%d@%zu.%06zu:qmp_enter_x_query_jit %s
%d@%zu.%06zu:qmp_exit_x_query_jit %s %d
%d@%zu.%06zu:qmp_enter_x_query_numa %s
%d@%zu.%06zu:qmp_exit_x_query_numa %s %d
%d@%zu.%06zu:qmp_enter_x_query_opcount %s
%d@%zu.%06zu:qmp_exit_x_query_opcount %s %d
qmp_exit_x_query_opcount %s %d
%d@%zu.%06zu:qmp_enter_x_query_ramblock %s
qmp_enter_x_query_ramblock %s
%d@%zu.%06zu:qmp_exit_x_query_ramblock %s %d
qmp_exit_x_query_ramblock %s %d
%d@%zu.%06zu:qmp_enter_x_query_roms %s
%d@%zu.%06zu:qmp_exit_x_query_roms %s %d
%d@%zu.%06zu:qmp_enter_x_query_usb %s
%d@%zu.%06zu:qmp_exit_x_query_usb %s %d
%d@%zu.%06zu:qmp_enter_dumpdtb %s
%d@%zu.%06zu:qmp_exit_dumpdtb %s %d
%d@%zu.%06zu:qmp_enter_x_query_interrupt_controllers %s
qmp_enter_x_query_interrupt_controllers %s
%d@%zu.%06zu:qmp_exit_x_query_interrupt_controllers %s %d
qmp_exit_x_query_interrupt_controllers %s %d
%d@%zu.%06zu:qmp_enter_query_migrate %s
%d@%zu.%06zu:qmp_exit_query_migrate %s %d
%d@%zu.%06zu:qmp_enter_migrate_set_capabilities %s
qmp_enter_migrate_set_capabilities %s
%d@%zu.%06zu:qmp_exit_migrate_set_capabilities %s %d
qmp_exit_migrate_set_capabilities %s %d
%d@%zu.%06zu:qmp_enter_query_migrate_capabilities %s
qmp_enter_query_migrate_capabilities %s
%d@%zu.%06zu:qmp_exit_query_migrate_capabilities %s %d
qmp_exit_query_migrate_capabilities %s %d
%d@%zu.%06zu:qmp_enter_migrate_set_parameters %s
qmp_enter_migrate_set_parameters %s
%d@%zu.%06zu:qmp_exit_migrate_set_parameters %s %d
qmp_exit_migrate_set_parameters %s %d
%d@%zu.%06zu:qmp_enter_query_migrate_parameters %s
qmp_enter_query_migrate_parameters %s
%d@%zu.%06zu:qmp_exit_query_migrate_parameters %s %d
qmp_exit_query_migrate_parameters %s %d
%d@%zu.%06zu:qmp_enter_migrate_start_postcopy %s
qmp_enter_migrate_start_postcopy %s
%d@%zu.%06zu:qmp_exit_migrate_start_postcopy %s %d
qmp_exit_migrate_start_postcopy %s %d
%d@%zu.%06zu:qmp_enter_x_colo_lost_heartbeat %s
qmp_enter_x_colo_lost_heartbeat %s
%d@%zu.%06zu:qmp_exit_x_colo_lost_heartbeat %s %d
qmp_exit_x_colo_lost_heartbeat %s %d
%d@%zu.%06zu:qmp_enter_migrate_cancel %s
%d@%zu.%06zu:qmp_exit_migrate_cancel %s %d
qmp_exit_migrate_cancel %s %d
%d@%zu.%06zu:qmp_enter_migrate_continue %s
qmp_enter_migrate_continue %s
%d@%zu.%06zu:qmp_exit_migrate_continue %s %d
qmp_exit_migrate_continue %s %d
%d@%zu.%06zu:qmp_enter_migrate %s
%d@%zu.%06zu:qmp_exit_migrate %s %d
%d@%zu.%06zu:qmp_enter_migrate_incoming %s
qmp_enter_migrate_incoming %s
%d@%zu.%06zu:qmp_exit_migrate_incoming %s %d
qmp_exit_migrate_incoming %s %d
%d@%zu.%06zu:qmp_enter_xen_save_devices_state %s
qmp_enter_xen_save_devices_state %s
%d@%zu.%06zu:qmp_exit_xen_save_devices_state %s %d
qmp_exit_xen_save_devices_state %s %d
%d@%zu.%06zu:qmp_enter_xen_set_global_dirty_log %s
qmp_enter_xen_set_global_dirty_log %s
%d@%zu.%06zu:qmp_exit_xen_set_global_dirty_log %s %d
qmp_exit_xen_set_global_dirty_log %s %d
%d@%zu.%06zu:qmp_enter_xen_load_devices_state %s
qmp_enter_xen_load_devices_state %s
%d@%zu.%06zu:qmp_exit_xen_load_devices_state %s %d
qmp_exit_xen_load_devices_state %s %d
%d@%zu.%06zu:qmp_enter_xen_set_replication %s
qmp_enter_xen_set_replication %s
%d@%zu.%06zu:qmp_exit_xen_set_replication %s %d
qmp_exit_xen_set_replication %s %d
%d@%zu.%06zu:qmp_enter_query_xen_replication_status %s
qmp_enter_query_xen_replication_status %s
%d@%zu.%06zu:qmp_exit_query_xen_replication_status %s %d
qmp_exit_query_xen_replication_status %s %d
%d@%zu.%06zu:qmp_enter_xen_colo_do_checkpoint %s
qmp_enter_xen_colo_do_checkpoint %s
%d@%zu.%06zu:qmp_exit_xen_colo_do_checkpoint %s %d
qmp_exit_xen_colo_do_checkpoint %s %d
%d@%zu.%06zu:qmp_enter_query_colo_status %s
qmp_enter_query_colo_status %s
%d@%zu.%06zu:qmp_exit_query_colo_status %s %d
qmp_exit_query_colo_status %s %d
%d@%zu.%06zu:qmp_enter_migrate_recover %s
%d@%zu.%06zu:qmp_exit_migrate_recover %s %d
qmp_exit_migrate_recover %s %d
%d@%zu.%06zu:qmp_enter_migrate_pause %s
%d@%zu.%06zu:qmp_exit_migrate_pause %s %d
%d@%zu.%06zu:qmp_enter_calc_dirty_rate %s
%d@%zu.%06zu:qmp_exit_calc_dirty_rate %s %d
qmp_exit_calc_dirty_rate %s %d
%d@%zu.%06zu:qmp_enter_query_dirty_rate %s
qmp_enter_query_dirty_rate %s
%d@%zu.%06zu:qmp_exit_query_dirty_rate %s %d
qmp_exit_query_dirty_rate %s %d
%d@%zu.%06zu:qmp_enter_set_vcpu_dirty_limit %s
qmp_enter_set_vcpu_dirty_limit %s
%d@%zu.%06zu:qmp_exit_set_vcpu_dirty_limit %s %d
qmp_exit_set_vcpu_dirty_limit %s %d
%d@%zu.%06zu:qmp_enter_cancel_vcpu_dirty_limit %s
qmp_enter_cancel_vcpu_dirty_limit %s
%d@%zu.%06zu:qmp_exit_cancel_vcpu_dirty_limit %s %d
qmp_exit_cancel_vcpu_dirty_limit %s %d
%d@%zu.%06zu:qmp_enter_query_vcpu_dirty_limit %s
qmp_enter_query_vcpu_dirty_limit %s
%d@%zu.%06zu:qmp_exit_query_vcpu_dirty_limit %s %d
qmp_exit_query_vcpu_dirty_limit %s %d
%d@%zu.%06zu:qmp_enter_query_migrationthreads %s
qmp_enter_query_migrationthreads %s
%d@%zu.%06zu:qmp_exit_query_migrationthreads %s %d
qmp_exit_query_migrationthreads %s %d
%d@%zu.%06zu:qmp_enter_snapshot_save %s
%d@%zu.%06zu:qmp_exit_snapshot_save %s %d
%d@%zu.%06zu:qmp_enter_snapshot_load %s
%d@%zu.%06zu:qmp_exit_snapshot_load %s %d
%d@%zu.%06zu:qmp_enter_snapshot_delete %s
%d@%zu.%06zu:qmp_exit_snapshot_delete %s %d
qmp_exit_snapshot_delete %s %d
%d@%zu.%06zu:qmp_enter_add_client %s
%d@%zu.%06zu:qmp_exit_add_client %s %d
%d@%zu.%06zu:qmp_enter_query_name %s
%d@%zu.%06zu:qmp_exit_query_name %s %d
%d@%zu.%06zu:qmp_enter_query_iothreads %s
%d@%zu.%06zu:qmp_exit_query_iothreads %s %d
qmp_exit_query_iothreads %s %d
%d@%zu.%06zu:qmp_enter_stop %s
%d@%zu.%06zu:qmp_exit_stop %s %d
%d@%zu.%06zu:qmp_enter_cont %s
%d@%zu.%06zu:qmp_exit_cont %s %d
%d@%zu.%06zu:qmp_enter_x_exit_preconfig %s
qmp_enter_x_exit_preconfig %s
%d@%zu.%06zu:qmp_exit_x_exit_preconfig %s %d
qmp_exit_x_exit_preconfig %s %d
%d@%zu.%06zu:qmp_enter_human_monitor_command %s
qmp_enter_human_monitor_command %s
%d@%zu.%06zu:qmp_exit_human_monitor_command %s %d
qmp_exit_human_monitor_command %s %d
%d@%zu.%06zu:qmp_enter_getfd %s
%d@%zu.%06zu:qmp_exit_getfd %s %d
%d@%zu.%06zu:qmp_enter_closefd %s
%d@%zu.%06zu:qmp_exit_closefd %s %d
%d@%zu.%06zu:qmp_enter_add_fd %s
%d@%zu.%06zu:qmp_exit_add_fd %s %d
%d@%zu.%06zu:qmp_enter_remove_fd %s
%d@%zu.%06zu:qmp_exit_remove_fd %s %d
%d@%zu.%06zu:qmp_enter_query_fdsets %s
%d@%zu.%06zu:qmp_exit_query_fdsets %s %d
%d@%zu.%06zu:qmp_enter_query_command_line_options %s
qmp_enter_query_command_line_options %s
%d@%zu.%06zu:qmp_exit_query_command_line_options %s %d
qmp_exit_query_command_line_options %s %d
%d@%zu.%06zu:qmp_enter_set_link %s
%d@%zu.%06zu:qmp_exit_set_link %s %d
%d@%zu.%06zu:qmp_enter_netdev_add %s
%d@%zu.%06zu:qmp_exit_netdev_add %s %d
%d@%zu.%06zu:qmp_enter_netdev_del %s
%d@%zu.%06zu:qmp_exit_netdev_del %s %d
%d@%zu.%06zu:qmp_enter_query_rx_filter %s
%d@%zu.%06zu:qmp_exit_query_rx_filter %s %d
qmp_exit_query_rx_filter %s %d
%d@%zu.%06zu:qmp_enter_announce_self %s
%d@%zu.%06zu:qmp_exit_announce_self %s %d
%d@%zu.%06zu:qmp_enter_qom_list %s
%d@%zu.%06zu:qmp_exit_qom_list %s %d
%d@%zu.%06zu:qmp_enter_qom_get %s
%d@%zu.%06zu:qmp_exit_qom_get %s %d
%d@%zu.%06zu:qmp_enter_qom_set %s
%d@%zu.%06zu:qmp_exit_qom_set %s %d
%d@%zu.%06zu:qmp_enter_qom_list_types %s
%d@%zu.%06zu:qmp_exit_qom_list_types %s %d
qmp_exit_qom_list_types %s %d
%d@%zu.%06zu:qmp_enter_qom_list_properties %s
qmp_enter_qom_list_properties %s
%d@%zu.%06zu:qmp_exit_qom_list_properties %s %d
qmp_exit_qom_list_properties %s %d
%d@%zu.%06zu:qmp_enter_object_add %s
%d@%zu.%06zu:qmp_exit_object_add %s %d
%d@%zu.%06zu:qmp_enter_object_del %s
%d@%zu.%06zu:qmp_exit_object_del %s %d
%d@%zu.%06zu:qmp_enter_query_replay %s
%d@%zu.%06zu:qmp_exit_query_replay %s %d
%d@%zu.%06zu:qmp_enter_replay_break %s
%d@%zu.%06zu:qmp_exit_replay_break %s %d
%d@%zu.%06zu:qmp_enter_replay_delete_break %s
qmp_enter_replay_delete_break %s
%d@%zu.%06zu:qmp_exit_replay_delete_break %s %d
qmp_exit_replay_delete_break %s %d
%d@%zu.%06zu:qmp_enter_replay_seek %s
%d@%zu.%06zu:qmp_exit_replay_seek %s %d
%d@%zu.%06zu:qmp_enter_query_status %s
%d@%zu.%06zu:qmp_exit_query_status %s %d
%d@%zu.%06zu:qmp_enter_watchdog_set_action %s
qmp_enter_watchdog_set_action %s
%d@%zu.%06zu:qmp_exit_watchdog_set_action %s %d
qmp_exit_watchdog_set_action %s %d
%d@%zu.%06zu:qmp_enter_set_action %s
%d@%zu.%06zu:qmp_exit_set_action %s %d
Invalid parameter type for '%s', expected: StatsValue
%d@%zu.%06zu:qmp_enter_query_stats %s
%d@%zu.%06zu:qmp_exit_query_stats %s %d
%d@%zu.%06zu:qmp_enter_query_stats_schemas %s
qmp_enter_query_stats_schemas %s
%d@%zu.%06zu:qmp_exit_query_stats_schemas %s %d
qmp_exit_query_stats_schemas %s %d
%d@%zu.%06zu:qmp_enter_trace_event_get_state %s
qmp_enter_trace_event_get_state %s
%d@%zu.%06zu:qmp_exit_trace_event_get_state %s %d
qmp_exit_trace_event_get_state %s %d
%d@%zu.%06zu:qmp_enter_trace_event_set_state %s
qmp_enter_trace_event_set_state %s
%d@%zu.%06zu:qmp_exit_trace_event_set_state %s %d
qmp_exit_trace_event_set_state %s %d
%d@%zu.%06zu:qmp_enter_transaction %s
%d@%zu.%06zu:qmp_exit_transaction %s %d
%d@%zu.%06zu:qmp_enter_x_query_virtio %s
%d@%zu.%06zu:qmp_exit_x_query_virtio %s %d
qmp_exit_x_query_virtio %s %d
%d@%zu.%06zu:qmp_enter_x_query_virtio_status %s
qmp_enter_x_query_virtio_status %s
%d@%zu.%06zu:qmp_exit_x_query_virtio_status %s %d
qmp_exit_x_query_virtio_status %s %d
%d@%zu.%06zu:qmp_enter_x_query_virtio_queue_status %s
qmp_enter_x_query_virtio_queue_status %s
%d@%zu.%06zu:qmp_exit_x_query_virtio_queue_status %s %d
qmp_exit_x_query_virtio_queue_status %s %d
%d@%zu.%06zu:qmp_enter_x_query_virtio_vhost_queue_status %s
qmp_enter_x_query_virtio_vhost_queue_status %s
%d@%zu.%06zu:qmp_exit_x_query_virtio_vhost_queue_status %s %d
qmp_exit_x_query_virtio_vhost_queue_status %s %d
%d@%zu.%06zu:qmp_enter_x_query_virtio_queue_element %s
qmp_enter_x_query_virtio_queue_element %s
%d@%zu.%06zu:qmp_exit_x_query_virtio_queue_element %s %d
qmp_exit_x_query_virtio_queue_element %s %d
%d@%zu.%06zu:qmp_enter_yank %s
%d@%zu.%06zu:qmp_exit_yank %s %d
%d@%zu.%06zu:qmp_enter_query_yank %s
%d@%zu.%06zu:qmp_exit_query_yank %s %d
%d@%zu.%06zu:qmp_enter_query_acpi_ospm_status %s
qmp_enter_query_acpi_ospm_status %s
%d@%zu.%06zu:qmp_exit_query_acpi_ospm_status %s %d
qmp_exit_query_acpi_ospm_status %s %d
%d@%zu.%06zu:qmp_enter_query_audiodevs %s
%d@%zu.%06zu:qmp_exit_query_audiodevs %s %d
qmp_exit_query_audiodevs %s %d
%d@%zu.%06zu:qmp_enter_query_cryptodev %s
%d@%zu.%06zu:qmp_exit_query_cryptodev %s %d
qmp_exit_query_cryptodev %s %d
%d@%zu.%06zu:qmp_enter_device_list_properties %s
qmp_enter_device_list_properties %s
%d@%zu.%06zu:qmp_exit_device_list_properties %s %d
qmp_exit_device_list_properties %s %d
%d@%zu.%06zu:qmp_enter_device_del %s
%d@%zu.%06zu:qmp_exit_device_del %s %d
%d@%zu.%06zu:qmp_enter_device_sync_config %s
qmp_enter_device_sync_config %s
%d@%zu.%06zu:qmp_exit_device_sync_config %s %d
qmp_exit_device_sync_config %s %d
%d@%zu.%06zu:qmp_enter_query_pci %s
%d@%zu.%06zu:qmp_exit_query_pci %s %d
%d@%zu.%06zu:qmp_enter_query_rocker %s
%d@%zu.%06zu:qmp_exit_query_rocker %s %d
%d@%zu.%06zu:qmp_enter_query_rocker_ports %s
qmp_enter_query_rocker_ports %s
%d@%zu.%06zu:qmp_exit_query_rocker_ports %s %d
qmp_exit_query_rocker_ports %s %d
%d@%zu.%06zu:qmp_enter_query_rocker_of_dpa_flows %s
qmp_enter_query_rocker_of_dpa_flows %s
%d@%zu.%06zu:qmp_exit_query_rocker_of_dpa_flows %s %d
qmp_exit_query_rocker_of_dpa_flows %s %d
%d@%zu.%06zu:qmp_enter_query_rocker_of_dpa_groups %s
qmp_enter_query_rocker_of_dpa_groups %s
%d@%zu.%06zu:qmp_exit_query_rocker_of_dpa_groups %s %d
qmp_exit_query_rocker_of_dpa_groups %s %d
%d@%zu.%06zu:qmp_enter_query_tpm_models %s
qmp_enter_query_tpm_models %s
%d@%zu.%06zu:qmp_exit_query_tpm_models %s %d
qmp_exit_query_tpm_models %s %d
%d@%zu.%06zu:qmp_enter_query_tpm_types %s
%d@%zu.%06zu:qmp_exit_query_tpm_types %s %d
qmp_exit_query_tpm_types %s %d
%d@%zu.%06zu:qmp_enter_query_tpm %s
%d@%zu.%06zu:qmp_exit_query_tpm %s %d
%d@%zu.%06zu:qmp_enter_set_password %s
%d@%zu.%06zu:qmp_exit_set_password %s %d
%d@%zu.%06zu:qmp_enter_expire_password %s
%d@%zu.%06zu:qmp_exit_expire_password %s %d
qmp_exit_expire_password %s %d
%d@%zu.%06zu:qmp_enter_screendump %s
%d@%zu.%06zu:qmp_exit_screendump %s %d
%d@%zu.%06zu:qmp_enter_query_spice %s
%d@%zu.%06zu:qmp_exit_query_spice %s %d
%d@%zu.%06zu:qmp_enter_query_vnc %s
%d@%zu.%06zu:qmp_exit_query_vnc %s %d
%d@%zu.%06zu:qmp_enter_query_vnc_servers %s
qmp_enter_query_vnc_servers %s
%d@%zu.%06zu:qmp_exit_query_vnc_servers %s %d
qmp_exit_query_vnc_servers %s %d
%d@%zu.%06zu:qmp_enter_change_vnc_password %s
qmp_enter_change_vnc_password %s
%d@%zu.%06zu:qmp_exit_change_vnc_password %s %d
qmp_exit_change_vnc_password %s %d
%d@%zu.%06zu:qmp_enter_query_mice %s
%d@%zu.%06zu:qmp_exit_query_mice %s %d
%d@%zu.%06zu:qmp_enter_send_key %s
%d@%zu.%06zu:qmp_exit_send_key %s %d
%d@%zu.%06zu:qmp_enter_input_send_event %s
qmp_enter_input_send_event %s
%d@%zu.%06zu:qmp_exit_input_send_event %s %d
qmp_exit_input_send_event %s %d
%d@%zu.%06zu:qmp_enter_query_display_options %s
qmp_enter_query_display_options %s
%d@%zu.%06zu:qmp_exit_query_display_options %s %d
qmp_exit_query_display_options %s %d
%d@%zu.%06zu:qmp_enter_display_reload %s
%d@%zu.%06zu:qmp_exit_display_reload %s %d
qmp_exit_display_reload %s %d
%d@%zu.%06zu:qmp_enter_display_update %s
%d@%zu.%06zu:qmp_exit_display_update %s %d
qmp_exit_display_update %s %d
%d@%zu.%06zu:qmp_enter_client_migrate_info %s
qmp_enter_client_migrate_info %s
%d@%zu.%06zu:qmp_exit_client_migrate_info %s %d
qmp_exit_client_migrate_info %s %d
qcrypto_tls_cipher_suite_count
qcrypto_tls_cipher_suite_priority
qcrypto_tls_session_check_creds
qcrypto_tls_creds_x509_load_cert_list
qcrypto_tls_creds_x509_load_cert
qcrypto_tls_creds_x509_check_key_purpose
qcrypto_tls_creds_x509_check_key_usage
qcrypto_tls_creds_x509_check_basic_constraints
object_class_dynamic_cast_assert
monitor_protocol_event_handler
gdbstub_err_checksum_incorrect
file_FindEjectableOpticalMedia
nbd_extended_headers_compliance
nbd_structured_read_compliance
nbd_parse_blockstatus_compliance
nvme_controller_capability_raw
qcow2_process_discards_failed_region
qcow2_do_alloc_clusters_offset
spice_vmc_unregister_interface
qio_channel_websock_payload_decode
qio_channel_websock_header_full_decode
qio_channel_websock_header_partial_decode
qio_channel_websock_http_request
qio_channel_websock_http_greeting
qio_channel_websock_handshake_complete
qio_channel_websock_handshake_fail
qio_channel_websock_handshake_reply
qio_channel_websock_handshake_pending
qio_channel_websock_handshake_start
qio_channel_websock_new_server
qio_channel_tls_credentials_deny
qio_channel_tls_credentials_allow
qio_channel_tls_handshake_cancel
qio_channel_tls_handshake_complete
qio_channel_tls_handshake_fail
qio_channel_tls_handshake_pending
qio_channel_tls_handshake_start
qio_channel_socket_accept_complete
qio_channel_socket_accept_fail
qio_channel_socket_dgram_complete
qio_channel_socket_dgram_async
qio_channel_socket_listen_complete
qio_channel_socket_listen_fail
qio_channel_socket_listen_async
qio_channel_socket_listen_sync
qio_channel_socket_connect_complete
qio_channel_socket_connect_fail
qio_channel_socket_connect_async
qio_channel_socket_connect_sync
nbd_co_receive_align_compliance
nbd_co_receive_ext_payload_compliance
nbd_co_receive_request_payload_received
nbd_co_receive_request_decode_type
nbd_co_receive_block_status_payload_compliance
nbd_negotiate_new_style_size_flags
nbd_negotiate_options_check_option
nbd_negotiate_options_check_magic
nbd_negotiate_meta_query_reply
nbd_negotiate_meta_query_parse
nbd_negotiate_handle_starttls_handshake
nbd_negotiate_handle_info_block_size
nbd_negotiate_handle_info_request
nbd_negotiate_handle_info_requests
nbd_negotiate_handle_export_name_request
nbd_negotiate_handle_export_name
nbd_receive_reply_chunk_header
nbd_receive_negotiate_size_flags
nbd_receive_negotiate_server_flags
nbd_receive_starttls_tls_handshake
nbd_receive_starttls_new_client
nbd_receive_query_exports_success
nbd_receive_query_exports_start
iommufd_backend_get_dirty_bitmap
iommufd_backend_unmap_dma_non_exist
tpm_emulator_set_state_blobs_done
tpm_emulator_set_state_blobs_error
tpm_emulator_handle_device_opts_startup_error
tpm_emulator_handle_device_opts_unspec
tpm_emulator_handle_device_opts_tpm2
tpm_emulator_handle_device_opts_tpm12
tpm_emulator_lock_storage_cmd_not_supt
tpm_emulator_cancel_cmd_not_supt
tpm_emulator_get_tpm_established_flag
tpm_emulator_startup_tpm_resume
tpm_util_get_buffer_size_hdr_len2
tpm_util_get_buffer_size_hdr_len
tpm_passthrough_handle_request
cpuhp_acpi_fw_remove_invalid_cpu
cpuhp_acpi_ejecting_invalid_cpu
cpuhp_acpi_clear_inserting_evt
cpuhp_acpi_invalid_idx_selected
mhp_acpi_pc_dimm_delete_failed
mhp_acpi_ejecting_invalid_slot
mhp_acpi_invalid_slot_selected
virtio_snd_handle_pcm_start_stop
virtio_snd_handle_pcm_set_params
m25p80_programming_zero_to_one
virtio_blk_handle_zone_reset_all
virtio_blk_zone_append_complete
virtio_blk_zone_report_complete
pflash_unsupported_device_configuration
htif_uart_unknown_device_command
stm32l4x5_usart_receiver_not_enabled
stm32l4x5_usart_overrun_detected
virtio_serial_handle_control_message_port
virtio_serial_handle_control_message
virtio_serial_send_control_event
apple_gfx_iosfc_unmap_memory_region
apple_gfx_iosfc_map_memory_new_region
apple_gfx_common_realize_modes_property
qxl_render_guest_primary_resized
qxl_set_client_capabilities_unsupported_by_revision
qxl_client_monitors_config_crc
qxl_client_monitors_config_capped
qxl_client_monitors_config_unsupported_by_device
qxl_client_monitors_config_unsupported_by_guest
qxl_interrupt_client_monitors_config
qxl_spice_flush_surfaces_async
qxl_spice_destroy_surface_wait
qxl_spice_destroy_surface_wait_complete
qxl_spice_destroy_surfaces_complete
qxl_ring_cursor_req_notification
qxl_ring_command_req_notification
qxl_io_destroy_primary_ignored
qxl_interface_update_area_complete_schedule_bh
qxl_interface_update_area_complete_overflow
qxl_interface_update_area_complete_rest
qxl_interface_update_area_complete
qxl_interface_set_compression_level
qxl_interface_async_complete_io
virtio_gpu_dec_inflight_fences
virtio_gpu_inc_inflight_fences
virtio_gpu_cmd_res_xfer_fromh_3d
virtio_gpu_cmd_res_xfer_toh_3d
virtio_gpu_cmd_res_xfer_toh_2d
virtio_gpu_cmd_res_back_detach
virtio_gpu_cmd_res_back_attach
virtio_gpu_cmd_res_create_blob
virtio_gpu_cmd_set_scanout_blob
virtio_gpu_cmd_get_display_info
vmware_update_rect_delayed_flush
vmware_verify_rect_surface_bound_exceeded
vmware_verify_rect_greater_than_bound
vmware_verify_rect_less_than_zero
xilinx_axidma_loading_desc_fail
hv_balloon_remove_response_remainder
hv_balloon_remove_response_common
hv_balloon_remove_response_hole
vmbus_process_incoming_message
aspeed_i2c_bus_raise_interrupt
vtd_inv_desc_iotlb_pasid_pages
ahci_populate_sglist_bad_offset
ahci_populate_sglist_short_map
adb_device_mouse_request_change_addr_and_handler
adb_device_mouse_request_change_addr
adb_device_kbd_request_change_addr_and_handler
adb_device_kbd_request_change_addr
spapr_xive_get_os_reporting_line
spapr_xive_set_os_reporting_line
gicv3_cpuif_virt_set_maint_irq
slavio_intctlm_mem_writel_target
slavio_intctlm_mem_writel_disable
slavio_intctlm_mem_writel_enable
slavio_intctl_mem_writel_clear
ivshmem_flat_interrupt_invalid_peer
ivshmem_flat_read_write_mmr_invalid
ivshmem_flat_read_mmr_doorbell
ivshmem_flat_add_vector_success
ivshmem_flat_add_vector_failure
bcm2835_cprman_write_invalid_magic
stm32l4x5_rcc_pll_set_channel_divider
stm32l4x5_rcc_pll_channel_disable
stm32l4x5_rcc_pll_channel_enable
stm32l4x5_rcc_pll_set_vco_multiplier
allwinner_r40_dramc_detect_cell_read
allwinner_r40_dramc_detect_cell_write
allwinner_r40_dramc_offset_to_cell
allwinner_r40_dramc_detect_cells_enable
allwinner_r40_dramc_detect_cells_disable
allwinner_h3_dramc_rowmirror_enable
allwinner_h3_dramc_rowmirror_disable
npcm_gmac_packet_receiving_buffer
npcm7xx_emc_packet_filtered_out
sunhme_rx_filter_promisc_match
spapr_vlan_h_send_logical_lan_total
spapr_vlan_h_send_logical_lan_buf_desc
spapr_vlan_h_send_logical_lan_rxbufs
spapr_vlan_h_add_logical_lan_buffer
spapr_vlan_add_rxbuf_to_pool_create
spapr_vlan_receive_dma_completed
spapr_vlan_get_rx_bd_from_page_found
spapr_vlan_get_rx_bd_from_page
spapr_vlan_get_rx_bd_from_pool_found
igb_wrn_rx_desc_modes_not_supp
e1000e_irq_msix_pending_clearing
e1000e_irq_tidv_fpd_not_running
e1000e_irq_rdtr_fpd_not_running
e1000e_irq_fire_delayed_interrupts
e1000e_irq_icr_clear_icr_bit_ims
e1000e_irq_icr_clear_nonmsix_icr_read
e1000e_irq_msix_notify_postponed_vec
e1000e_irq_legacy_notify_postponed
e1000e_irq_msi_notify_postponed
e1000e_rx_metadata_ipv6_filtering_disabled
e1000e_rx_metadata_ipv6_sum_disabled
e1000e_rx_metadata_status_flags
e1000e_rx_metadata_l4_csum_validation_failed
e1000e_rx_metadata_l3_csum_validation_failed
e1000e_rx_metadata_l4_cso_disabled
e1000e_rx_metadata_l3_cso_disabled
e1000e_rx_metadata_virthdr_no_csum_info
e1000e_rx_not_written_to_guest
e1000e_wrn_nfsr_filtering_not_supported
e1000e_wrn_nfsw_filtering_not_supported
e1000e_wrn_iscsi_filtering_not_supported
e1000e_core_mdic_write_unhandled
e1000e_core_mdic_read_unhandled
e1000x_rx_flt_inexact_mismatch
net_rx_pkt_l3_csum_validate_csum
net_rx_pkt_l3_csum_validate_not_ip4
net_rx_pkt_l3_csum_validate_entry
net_rx_pkt_l4_csum_fix_udp_with_no_checksum
net_rx_pkt_l4_csum_fix_ip4_fragment
net_rx_pkt_l4_csum_fix_not_xxp
net_rx_pkt_l4_csum_calc_ph_csum
net_rx_pkt_l4_csum_calc_ip6_tcp
net_rx_pkt_l4_csum_calc_ip6_udp
net_rx_pkt_l4_csum_calc_ip4_tcp
net_rx_pkt_l4_csum_calc_ip4_udp
net_rx_pkt_l4_csum_validate_csum
net_rx_pkt_l4_csum_validate_ip4_fragment
net_rx_pkt_l4_csum_validate_udp_with_no_checksum
net_rx_pkt_l4_csum_validate_not_xxp
net_rx_pkt_l4_csum_validate_entry
allwinner_sun8i_emac_mii_read_reg
allwinner_sun8i_emac_mii_write_reg
pci_nvme_ub_db_wr_invalid_sqtail
pci_nvme_ub_db_wr_invalid_cqhead
pci_nvme_ub_mmiord_invalid_ofs
pci_nvme_ub_mmiord_misaligned32
pci_nvme_ub_mmiowr_pmrswtp_readonly
pci_nvme_ub_mmiowr_pmrebs_readonly
pci_nvme_ub_mmiowr_pmrsts_readonly
pci_nvme_ub_mmiowr_pmrcap_readonly
pci_nvme_ub_mmiowr_cmbsz_readonly
pci_nvme_ub_mmiowr_cmbloc_reserved
pci_nvme_ub_mmiowr_ssreset_unsupported
pci_nvme_ub_mmiowr_ssreset_w1c_unsupported
pci_nvme_ub_mmiowr_intmask_with_msix
pci_nvme_ub_mmiowr_misaligned32
pci_nvme_err_ignored_mmio_vf_offline
pci_nvme_err_invalid_mgmt_action
pci_nvme_err_startfail_virt_state
pci_nvme_err_startfail_zasl_too_small
pci_nvme_err_startfail_acqent_sz_zero
pci_nvme_err_startfail_asqent_sz_zero
pci_nvme_err_startfail_sqent_too_large
pci_nvme_err_startfail_sqent_too_small
pci_nvme_err_startfail_cqent_too_large
pci_nvme_err_startfail_cqent_too_small
pci_nvme_err_startfail_page_too_large
pci_nvme_err_startfail_page_too_small
pci_nvme_err_startfail_acq_misaligned
pci_nvme_err_startfail_asq_misaligned
pci_nvme_err_invalid_identify_cns
pci_nvme_err_invalid_create_cq_entry_size
pci_nvme_err_invalid_create_cq_qflags
pci_nvme_err_invalid_create_cq_vector
pci_nvme_err_invalid_create_cq_addr
pci_nvme_err_invalid_create_cq_size
pci_nvme_err_invalid_create_cq_cqid
pci_nvme_err_invalid_del_cq_notempty
pci_nvme_err_invalid_del_cq_cqid
pci_nvme_err_invalid_create_sq_qflags
pci_nvme_err_invalid_create_sq_addr
pci_nvme_err_invalid_create_sq_size
pci_nvme_err_invalid_create_sq_sqid
pci_nvme_err_invalid_create_sq_cqid
pci_nvme_err_zd_extension_map_error
pci_nvme_err_insuff_active_res
pci_nvme_err_zone_write_not_ok
pci_nvme_err_zone_invalid_write
pci_nvme_err_zone_is_read_only
pci_nvme_err_append_not_at_start
pci_nvme_err_invalid_zone_state_transition
pci_nvme_err_unaligned_zone_cmd
pci_nvme_err_invalid_log_page_offset
pci_nvme_err_invalid_lba_range
pci_nvme_err_invalid_admin_opc
pci_nvme_err_invalid_prp2_align
pci_nvme_err_invalid_prplist_ent
pci_nvme_err_invalid_sgl_excess_length
pci_nvme_err_copy_invalid_format
pci_nvme_zoned_zrwa_implicit_flush
pci_nvme_set_descriptor_extension
pci_nvme_mmio_shutdown_cleared
pci_nvme_enqueue_req_completion
pci_nvme_enqueue_event_noqueue
pci_nvme_identify_ns_descr_list
pci_nvme_identify_sec_ctrl_list
pci_nvme_identify_pri_ctrl_cap
pci_nvme_dsm_single_range_limit_exceeded
pci_nvme_dif_prchk_reftag_crc64
pci_nvme_dif_prchk_reftag_crc16
pci_nvme_dif_prchk_guard_crc64
pci_nvme_dif_prchk_guard_crc16
pci_nvme_dif_prchk_disabled_crc64
pci_nvme_dif_prchk_disabled_crc16
pci_nvme_dif_pract_generate_dif_crc64
pci_nvme_dif_pract_generate_dif_crc16
scsi_generic_ioctl_sgio_command
scsi_generic_realize_blocksize
scsi_generic_write_complete_blocksize
scsi_generic_command_complete_noio
scsi_disk_mode_select_set_blocksize
scsi_disk_mode_select_page_truncated
scsi_disk_emulate_command_FORMAT_UNIT
scsi_disk_emulate_command_UNKNOWN
scsi_disk_emulate_command_WRITE_SAME
scsi_disk_emulate_command_VERIFY
scsi_disk_emulate_command_UNMAP
scsi_disk_emulate_command_MODE_SELECT_10
scsi_disk_emulate_command_MODE_SELECT
scsi_disk_emulate_command_SEEK_10
scsi_disk_emulate_command_SAI_unsupported
scsi_disk_emulate_command_SAI_16
scsi_disk_emulate_vpd_page_b0_not_supported
scsi_disk_emulate_vpd_page_80_not_supported
lsi_execute_script_tc_cc_failed
lsi_execute_script_tc_interrupt
lsi_execute_script_tc_delayedselect_timeout
lsi_execute_script_io_disconnect
lsi_execute_script_io_selected
lsi_execute_script_io_alreadyreselected
lsi_execute_script_blockmove_badphase
lsi_execute_script_blockmove_delayed
spapr_vscsi_queue_cmd_no_drive
spapr_vscsi_command_complete_status
spapr_vscsi_command_complete_sense_data2
spapr_vscsi_command_complete_sense_data1
spapr_vscsi_srp_indirect_data_buf
spapr_vscsi_srp_indirect_data_rw
spapr_vscsi_fetch_desc_out_of_desc_boundary
spapr_vscsi_fetch_desc_out_of_desc
spapr_vscsi_fetch_desc_indirect_seg_ext
spapr_vscsi_fetch_desc_dma_read_error
spapr_vscsi_fetch_desc_out_of_range
spapr_vscsi_fetch_desc_indirect
spapr_vscsi_fetch_desc_no_data
esp_pci_error_invalid_write_dma
esp_pci_error_invalid_dma_direction
esp_command_complete_unexpected
pvscsi_process_req_descr_invalid_dir
pvscsi_process_req_descr_unknown_device
pvscsi_command_complete_sense_len
pvscsi_command_complete_data_run
pvscsi_command_complete_not_found
megasas_scsi_target_not_present
mptsas_process_scsi_io_request
pl181_command_response_pending
hpet_ram_write_counter_written
hpet_ram_write_counter_write_while_enabled
avr_timer16_interrupt_overflow
aspeed_timer_ctrl_pulse_enable
aspeed_timer_ctrl_overflow_interrupt
aspeed_timer_ctrl_external_clock
slavio_timer_mem_writel_invalid
slavio_timer_mem_writel_mode_invalid
slavio_timer_mem_writel_mode_counter
slavio_timer_mem_writel_mode_user
slavio_timer_mem_writel_status_stop
slavio_timer_mem_writel_status_start
slavio_timer_mem_writel_counter_invalid
slavio_timer_mem_readl_invalid
tpm_spapr_do_crq_unknown_msg_type
tpm_spapr_do_crq_prepare_to_suspend
tpm_spapr_do_crq_tpm_get_rtce_buffer_size
tpm_spapr_do_crq_crq_complete_result
tpm_tis_mmio_write_lowering_irq
